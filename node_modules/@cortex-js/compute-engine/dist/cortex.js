(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.Cortex = {}));
}(this, (function (exports) { 'use strict';

  function stringToCodepoints(string) {
      const result = [];
      for (let i = 0; i < string.length; i++) {
          let code = string.charCodeAt(i);
          // if (code === 0x0d && string.charCodeAt(i + 1) === 0x0a) {
          //   code = 0x0a;
          //   i++;
          // }
          // if (code === 0x0d || code === 0x0c) code = 0x0a;
          // if (code === 0x00) code = 0xfffd;
          // Decode a surrogate pair into an astral codepoint.
          if (code >= 0xd800 && code <= 0xdbff) {
              const nextCode = string.charCodeAt(i + 1);
              if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {
                  const lead = code - 0xd800;
                  const trail = nextCode - 0xdc00;
                  code = 2 ** 16 + lead * 2 ** 10 + trail;
                  // N = ((H - 0xD800) * 0x400) + (L - 0xDC00) + 0x10000;
                  i++;
              }
          }
          result.push(code);
      }
      return result;
  }
  const ZWJ = 0x200d; // Zero-width joiner
  // const ZWSP = 0x200b; // Zero-width space
  // Regional indicator: a pair of codepoints indicating some flags
  const REGIONAL_INDICATOR = [0x1f1e6, 0x1f1ff];
  function isEmojiCombinator(code) {
      // Zero-width joiner
      if (code === ZWJ)
          return true;
      // VS-15: text presentation, VS-16: Emoji presentation
      if (code === 0xfe0e || code === 0xfe0f)
          return true;
      // EMOJI_MODIFIER_FITZPATRICK_TYPE 1-6
      if (code >= 0x1f3fb && code <= 0x1f3fb + 5)
          return true;
      // Red hair..white hair
      if (code >= 0x1f9b0 && code <= 0x1f9b0 + 4)
          return true;
      // EMOJI_TAG
      if (code >= 0xe0020 && code <= 0xe0020 + 96)
          return true;
      return false;
  }
  function isRegionalIndicator(code) {
      return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
  }
  /**
   * Return a string or an array of graphemes.
   *
   * This includes:
   * - emoji with skin and hair modifiers
   * - emoji combination (for example "female pilot")
   * - text emoji with an emoji presentation style modifier
   *      - U+1F512 U+FE0E ðŸ”’ï¸Ž
   *      - U+1F512 U+FE0F ðŸ”’ï¸
   * - flags represented as two regional indicator codepoints
   * - flags represented as a flag emoji + zwj + an emoji tag
   * - other combinations (for example, rainbow flag)
   */
  function splitGraphemes(string) {
      // If it's all ASCII, short-circuit the grapheme splitting...
      if (/^[\u0020-\u00FF]*$/.test(string))
          return string;
      const result = [];
      const codePoints = stringToCodepoints(string);
      let index = 0;
      while (index < codePoints.length) {
          const code = codePoints[index++];
          const next = codePoints[index];
          // Combine sequences
          if (next === ZWJ) {
              // Zero-width joiner sequences are:
              // ZWJ_SEQUENCE := (CHAR + ZWJ)+
              const baseIndex = index - 1;
              index += 2;
              while (codePoints[index] === ZWJ) {
                  index += 2;
              }
              result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex + 1)));
          }
          else if (isEmojiCombinator(next)) {
              // Combine emoji sequences
              // See http://unicode.org/reports/tr51/#def_emoji_tag_sequence
              const baseIndex = index - 1; // The previous character is the 'base'
              while (isEmojiCombinator(codePoints[index])) {
                  index += codePoints[index] === ZWJ ? 2 : 1;
              }
              result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)));
          }
          else if (isRegionalIndicator(code)) {
              // Some (but not all) flags are represented by a sequence of two
              // "regional indicators" codepoints.
              index += 1;
              result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
          }
          else {
              result.push(String.fromCodePoint(code));
          }
      }
      return result;
  }

  /**
   * ## Reference
   * TeX source code:
   * {@link  http://tug.org/texlive/devsrc/Build/source/texk/web2c/tex.web | Tex.web}
   *
   */
  /**
   * Given a LaTeX expression represented as a character string,
   * the Lexer class will scan and return Tokens for the lexical
   * units in the string.
   *
   * @param s A string of LaTeX
   */
  class Tokenizer {
      constructor(s) {
          this.obeyspaces = false;
          this.s = splitGraphemes(s);
          this.pos = 0;
      }
      /**
       * @return True if we reached the end of the stream
       */
      end() {
          return this.pos >= this.s.length;
      }
      /**
       * Return the next char and advance
       */
      get() {
          return this.pos < this.s.length ? this.s[this.pos++] : '';
      }
      /**
       * Return the next char, but do not advance
       */
      peek() {
          return this.s[this.pos];
      }
      /**
       * Return the next substring matching regEx and advance.
       */
      match(regEx) {
          // this.s can either be a string, if it's made up only of ASCII chars
          // or an array of graphemes, if it's more complicated.
          let execResult;
          if (typeof this.s === 'string') {
              execResult = regEx.exec(this.s.slice(this.pos));
          }
          else {
              execResult = regEx.exec(this.s.slice(this.pos).join(''));
          }
          if (execResult === null || execResult === void 0 ? void 0 : execResult[0]) {
              this.pos += execResult[0].length;
              return execResult[0];
          }
          return null;
      }
      /**
       * Return the next token, or null.
       */
      next() {
          // If we've reached the end, exit
          if (this.end())
              return null;
          // Handle white space
          // In text mode, spaces are significant,
          // however they are coalesced unless \obeyspaces
          if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) {
              // Note that browsers are inconsistent in their definitions of the
              // `\s` metacharacter, so we use an explicit pattern instead.
              // - IE:          `[ \f\n\r\t\v]`
              // - Chrome:      `[ \f\n\r\t\v\u00A0]`
              // - Firefox:     `[ \f\n\r\t\v\u00A0\u2028\u2029]`
              // - \f \u000C: form feed (FORM FEED)
              // - \n \u000A: linefeed (LINE FEED)
              // - \r \u000D: carriage return
              // - \t \u0009: tab (CHARACTER TABULATION)
              // - \v \u000B: vertical tab (LINE TABULATION)
              // - \u00A0: NON-BREAKING SPACE
              // - \u2028: LINE SEPARATOR
              // - \u2029: PARAGRAPH SEPARATOR
              return '<space>';
          }
          else if (this.obeyspaces &&
              this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) {
              // Don't coalesce when this.obeyspaces is true (different regex from above)
              return '<space>';
          }
          const next = this.get();
          // Is it a command?
          if (next === '\\') {
              if (!this.end()) {
                  // A command is either a string of letters and asterisks...
                  let command = this.match(/^[a-zA-Z*]+/);
                  if (command) {
                      // Spaces after a 'control word' are ignored
                      // (but not after a 'control symbol' (single char)
                      this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
                  }
                  else {
                      // ... or a single non-letter character
                      command = this.get();
                      if (command === ' ') {
                          // The `\ ` command is equivalent to a single space
                          return '<space>';
                      }
                  }
                  return '\\' + command;
              }
          }
          else if (next === '{') {
              // This is a group start
              return '<{>';
          }
          else if (next === '}') {
              // This is a group end
              return '<}>';
          }
          else if (next === '^') {
              if (this.peek() === '^') {
                  // It might be a ^^ command (inline hex character)
                  this.get();
                  // There can be zero to six carets with the same number of hex digits
                  const hex = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
                  if (hex) {
                      return String.fromCodePoint(parseInt(hex.slice(hex.lastIndexOf('^') + 1), 16));
                  }
              }
              return next;
          }
          else if (next === '#') {
              // This could be either a param token, or a literal # (used for
              // colorspecs, for example). A param token is a '#' followed by
              // - a digit 0-9 followed by a non-alpha, non-digit
              // - or '?'.
              // Otherwise, it's a literal '#'.
              if (!this.end()) {
                  let isParam = false;
                  if (/[0-9?]/.test(this.peek())) {
                      // Could be a param
                      isParam = true;
                      // Need to look ahead to the following char
                      if (this.pos + 1 < this.s.length) {
                          const after = this.s[this.pos + 1];
                          isParam = /[^0-9A-Za-z]/.test(after);
                      }
                  }
                  if (isParam) {
                      return '#' + this.get();
                  }
                  return '#';
              }
          }
          else if (next === '$') {
              // Mode switch
              if (this.peek() === '$') {
                  // $$
                  this.get();
                  return '<$$>';
              }
              // $
              return '<$>';
          }
          return next;
      }
  }
  // Some primitive commands need to be handled in the expansion phase
  // (the 'gullet')
  function expand$1(lex, args) {
      var _a, _b, _c, _d;
      let result = [];
      let token = lex.next();
      if (token) {
          if (token === '\\relax') ;
          else if (token === '\\noexpand') {
              // Do not expand the next token
              token = lex.next();
              if (token) {
                  result.push(token);
              }
          }
          else if (token === '\\obeyspaces') {
              lex.obeyspaces = true;
          }
          else if (token === '\\space' || token === '~') {
              // The `\space` command is equivalent to a single space
              // The ~ is an 'active character' (a single character macro)
              // that maps to <space>
              result.push('<space>');
          }
          else if (token === '\\bgroup') {
              // Begin group, synonym for opening brace
              result.push('<{>');
          }
          else if (token === '\\egroup') {
              // End group, synonym for closing brace
              result.push('<}>');
          }
          else if (token === '\\string') {
              // Turn the next token into a string
              token = lex.next();
              if (token) {
                  if (token[0] === '\\') {
                      Array.from(token).forEach((x) => result.push(x === '\\' ? '\\backslash' : x));
                  }
                  else if (token === '<{>') {
                      result.push('\\{');
                  }
                  else if (token === '<space>') {
                      result.push('~');
                  }
                  else if (token === '<}>') {
                      result.push('\\}');
                  }
              }
          }
          else if (token === '\\csname') {
              // Turn the next tokens, until `\endcsname`, into a command
              while (lex.peek() === '<space>') {
                  lex.next();
              }
              let command = '';
              let done = false;
              let tokens = [];
              do {
                  if (tokens.length === 0) {
                      // We're out of tokens to look at, get some more
                      if (/^#[0-9?]$/.test(lex.peek())) {
                          // Expand parameters (but not commands)
                          const param = lex.get().slice(1);
                          tokens = tokenize((_b = (_a = args === null || args === void 0 ? void 0 : args[param]) !== null && _a !== void 0 ? _a : args === null || args === void 0 ? void 0 : args['?']) !== null && _b !== void 0 ? _b : '\\placeholder{}', args);
                          token = tokens[0];
                      }
                      else {
                          token = lex.next();
                          tokens = token ? [token] : [];
                      }
                  }
                  done = tokens.length === 0;
                  if (!done && token === '\\endcsname') {
                      done = true;
                      tokens.shift();
                  }
                  if (!done) {
                      done =
                          token === '<$>' ||
                              token === '<$$>' ||
                              token === '<{>' ||
                              token === '<}>' ||
                              (!!token && token.length > 1 && token[0] === '\\');
                  }
                  if (!done) {
                      command += tokens.shift();
                  }
              } while (!done);
              if (command) {
                  result.push('\\' + command);
              }
              result = result.concat(tokens);
          }
          else if (token === '\\endcsname') ;
          else if (token.length > 1 && token[0] === '#') {
              // It's a parameter to expand
              const param = token.slice(1);
              result = result.concat(tokenize((_d = (_c = args === null || args === void 0 ? void 0 : args[param]) !== null && _c !== void 0 ? _c : args === null || args === void 0 ? void 0 : args['?']) !== null && _d !== void 0 ? _d : '\\placeholder{}', args));
          }
          else {
              result.push(token);
          }
      }
      return result;
  }
  /**
   * Create Tokens from a stream of LaTeX
   *
   * @param s - A string of LaTeX. It can include comments (with the `%`
   * marker) and multiple lines.
   */
  function tokenize(s, args) {
      // Merge multiple lines into one, and remove comments
      const lines = s.toString().split(/\r?\n/);
      let stream = '';
      let sep = '';
      for (const line of lines) {
          stream += sep;
          sep = ' ';
          // Remove everything after a % (comment marker)
          // (but \% should be preserved...)
          const m = line.match(/((?:\\%)|[^%])*/);
          if (m !== null)
              stream += m[0];
      }
      const tokenizer = new Tokenizer(stream);
      let result = [];
      do {
          result = result.concat(expand$1(tokenizer, args));
      } while (!tokenizer.end());
      return result;
  }
  function joinLatex(segments) {
      let sep = '';
      let result = '';
      for (const segment of segments) {
          if (segment) {
              if (/[a-zA-Z*]/.test(segment[0])) {
                  // If the segment begins with a char that *could* be in a command
                  // name... insert a separator (if one was needed for the previous segment)
                  result += sep;
              }
              // If the segment ends in a command...
              if (/\\[a-zA-Z]+\*?$/.test(segment)) {
                  // ... potentially add a space before the next segment
                  sep = ' ';
              }
              else {
                  sep = '';
              }
              result += segment;
          }
      }
      return result;
  }
  function tokensToString(tokens) {
      let flat = [];
      if (Array.isArray(tokens)) {
          for (const item of tokens) {
              if (Array.isArray(item)) {
                  flat = [...flat, ...item];
              }
              else {
                  flat.push(item);
              }
          }
      }
      else {
          flat = [tokens];
      }
      const result = joinLatex(flat.map((token) => {
          var _a;
          return ((_a = {
              '<space>': ' ',
              '<$$>': '$$',
              '<$>': '$',
              '<{>': '{',
              '<}>': '}',
          }[token]) !== null && _a !== void 0 ? _a : token);
      }));
      return result;
  }

  const DEFINITIONS_INEQUALITIES = [
      {
          name: 'NotLess',
          trigger: { infix: ['!', '<'] },
          associativity: 'right',
          precedence: 246,
      },
      {
          name: 'NotLess',
          trigger: { infix: '\\nless' },
          associativity: 'right',
          precedence: 246,
      },
      {
          name: 'Less',
          trigger: { infix: '<' },
          associativity: 'right',
          precedence: 245,
      },
      {
          name: 'Less',
          trigger: { infix: '\\lt' },
          associativity: 'right',
          precedence: 245,
      },
      {
          name: 'LessEqual',
          trigger: { infix: ['<', '='] },
          associativity: 'right',
          precedence: 241,
      },
      {
          name: 'LessEqual',
          trigger: { infix: '\\le' },
          associativity: 'right',
          precedence: 241,
      },
      {
          name: 'LessEqual',
          trigger: { infix: '\\leq' },
          associativity: 'right',
          precedence: 241,
      },
      {
          name: 'LessEqual',
          trigger: { infix: '\\leqslant' },
          associativity: 'right',
          precedence: 265, // Note different precendence than `<=` as per MathML
      },
      {
          name: 'LessNotEqual',
          trigger: { infix: '\\lneqq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotLessNotEqual',
          trigger: { infix: '\\nleqq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'LessOverEqual',
          trigger: { infix: '\\leqq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'GreaterOverEqual',
          trigger: { infix: '\\geqq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'Equal',
          trigger: { infix: '=' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'StarEqual',
          trigger: { infix: ['*', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'StarEqual',
          trigger: { infix: ['\\star', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'PlusEqual',
          trigger: { infix: ['+', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'MinusEqual',
          trigger: { infix: ['-', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'SlashEqual',
          trigger: { infix: ['/', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'EqualEqual',
          trigger: { infix: ['=', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'EqualEqualEqual',
          trigger: { infix: ['=', '=', '='] },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'TildeFullEqual',
          trigger: { infix: '\\cong' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotTildeFullEqual',
          trigger: { infix: '\\ncong' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Assign',
          trigger: { infix: [':', '='] },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Assign',
          trigger: { infix: '\\coloneq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Approx',
          trigger: { infix: '\\approx' },
          associativity: 'right',
          precedence: 247,
      },
      {
          name: 'NotApprox',
          trigger: { infix: '\\approx' },
          associativity: 'right',
          precedence: 247,
      },
      {
          name: 'ApproxEqual',
          trigger: { infix: '\\approxeq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotApproxEqual',
          trigger: { infix: ['!', '\\approxeq'] },
          associativity: 'right',
          precedence: 250,
      },
      {
          name: 'NotEqual',
          trigger: { infix: '\\ne' },
          associativity: 'right',
          precedence: 255,
      },
      {
          name: 'Unequal',
          trigger: { infix: ['!', '='] },
          associativity: 'right',
          precedence: 260, // Note different precendence than \\ne per MathML
      },
      {
          name: 'GreaterEqual',
          trigger: { infix: '\\ge' },
          associativity: 'right',
          precedence: 242, // Note: different precendence than `>=` as per MathML
      },
      {
          name: 'GreaterEqual',
          trigger: { infix: '\\geq' },
          associativity: 'right',
          precedence: 242, // Note: different precendence than `>=` as per MathML
      },
      {
          name: 'GreaterEqual',
          trigger: { infix: ['>', '='] },
          associativity: 'right',
          precedence: 243,
      },
      {
          name: 'GreaterEqual',
          trigger: { infix: '\\geqslant' },
          associativity: 'right',
          precedence: 265, // Note: different precendence than `>=` as per MathML
      },
      {
          name: 'GreaterNotEqual',
          trigger: { infix: '\\gneqq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotGreaterNotEqual',
          trigger: { infix: '\\ngeqq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Greater',
          trigger: { infix: '>' },
          associativity: 'right',
          precedence: 245,
      },
      {
          name: 'Greater',
          trigger: { infix: '\\gt' },
          associativity: 'right',
          precedence: 245,
      },
      {
          name: 'NotGreater',
          trigger: { infix: '\\ngtr' },
          associativity: 'right',
          precedence: 244,
      },
      {
          name: 'NotGreater',
          trigger: { infix: ['!', '>'] },
          associativity: 'right',
          precedence: 244,
      },
      {
          name: 'RingEqual',
          trigger: { infix: '\\circeq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'TriangleEqual',
          trigger: { infix: '\\triangleq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'DotEqual',
          trigger: { infix: '\\doteq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'DotEqualDot',
          trigger: { infix: '\\doteqdot' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'FallingDotEqual',
          trigger: { infix: '\\fallingdotseq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'RisingDotEqual',
          trigger: { infix: '\\fallingdotseq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'QuestionEqual',
          trigger: { infix: '\\questeq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Equivalent',
          trigger: { infix: '\\equiv' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'MuchLess',
          trigger: { infix: '\\ll' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'MuchGreater',
          trigger: { infix: '\\gg' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Precedes',
          trigger: { infix: '\\prec' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Succeeds',
          trigger: { infix: '\\succ' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'PrecedesEqual',
          trigger: { infix: '\\preccurlyeq' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'SucceedsEqual',
          trigger: { infix: '\\curlyeqprec' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotPrecedes',
          trigger: { infix: '\\nprec' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'NotSucceeds',
          trigger: { infix: '\\nsucc' },
          associativity: 'right',
          precedence: 260,
      },
      {
          name: 'Between',
          trigger: { infix: '\\between' },
          associativity: 'right',
          precedence: 265,
      },
  ];

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var decimal = {exports: {}};

  (function (module) {
  (function (globalScope) {


    /*
     *  decimal.js v10.2.1
     *  An arbitrary-precision Decimal type for JavaScript.
     *  https://github.com/MikeMcl/decimal.js
     *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
     *  MIT Licence
     */


    // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


      // The maximum exponent magnitude.
      // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
    var EXP_LIMIT = 9e15,                      // 0 to 9e15

      // The limit on the value of `precision`, and on the value of the first argument to
      // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
      MAX_DIGITS = 1e9,                        // 0 to 1e9

      // Base conversion alphabet.
      NUMERALS = '0123456789abcdef',

      // The natural logarithm of 10 (1025 digits).
      LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

      // Pi (1025 digits).
      PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


      // The initial configuration properties of the Decimal constructor.
      DEFAULTS = {

        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.

        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,                         // 1 to MAX_DIGITS

        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,                           // 0 to 8

        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,                             // 0 to 9

        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,                          // 0 to -EXP_LIMIT

        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos:  21,                         // 0 to EXP_LIMIT

        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false                          // true/false
      },


    // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


      Decimal, inexact, noConflict, quadrant,
      external = true,

      decimalError = '[DecimalError] ',
      invalidArgument = decimalError + 'Invalid argument: ',
      precisionLimitExceeded = decimalError + 'Precision limit exceeded',
      cryptoUnavailable = decimalError + 'crypto unavailable',

      mathfloor = Math.floor,
      mathpow = Math.pow,

      isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
      isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
      isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
      isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

      BASE = 1e7,
      LOG_BASE = 7,
      MAX_SAFE_INTEGER = 9007199254740991,

      LN10_PRECISION = LN10.length - 1,
      PI_PRECISION = PI.length - 1,

      // Decimal.prototype object
      P = { name: '[object Decimal]' };


    // Decimal prototype methods


    /*
     *  absoluteValue             abs
     *  ceil
     *  comparedTo                cmp
     *  cosine                    cos
     *  cubeRoot                  cbrt
     *  decimalPlaces             dp
     *  dividedBy                 div
     *  dividedToIntegerBy        divToInt
     *  equals                    eq
     *  floor
     *  greaterThan               gt
     *  greaterThanOrEqualTo      gte
     *  hyperbolicCosine          cosh
     *  hyperbolicSine            sinh
     *  hyperbolicTangent         tanh
     *  inverseCosine             acos
     *  inverseHyperbolicCosine   acosh
     *  inverseHyperbolicSine     asinh
     *  inverseHyperbolicTangent  atanh
     *  inverseSine               asin
     *  inverseTangent            atan
     *  isFinite
     *  isInteger                 isInt
     *  isNaN
     *  isNegative                isNeg
     *  isPositive                isPos
     *  isZero
     *  lessThan                  lt
     *  lessThanOrEqualTo         lte
     *  logarithm                 log
     *  [maximum]                 [max]
     *  [minimum]                 [min]
     *  minus                     sub
     *  modulo                    mod
     *  naturalExponential        exp
     *  naturalLogarithm          ln
     *  negated                   neg
     *  plus                      add
     *  precision                 sd
     *  round
     *  sine                      sin
     *  squareRoot                sqrt
     *  tangent                   tan
     *  times                     mul
     *  toBinary
     *  toDecimalPlaces           toDP
     *  toExponential
     *  toFixed
     *  toFraction
     *  toHexadecimal             toHex
     *  toNearest
     *  toNumber
     *  toOctal
     *  toPower                   pow
     *  toPrecision
     *  toSignificantDigits       toSD
     *  toString
     *  truncated                 trunc
     *  valueOf                   toJSON
     */


    /*
     * Return a new Decimal whose value is the absolute value of this Decimal.
     *
     */
    P.absoluteValue = P.abs = function () {
      var x = new this.constructor(this);
      if (x.s < 0) x.s = 1;
      return finalise(x);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of positive Infinity.
     *
     */
    P.ceil = function () {
      return finalise(new this.constructor(this), this.e + 1, 2);
    };


    /*
     * Return
     *   1    if the value of this Decimal is greater than the value of `y`,
     *  -1    if the value of this Decimal is less than the value of `y`,
     *   0    if they have the same value,
     *   NaN  if the value of either Decimal is NaN.
     *
     */
    P.comparedTo = P.cmp = function (y) {
      var i, j, xdL, ydL,
        x = this,
        xd = x.d,
        yd = (y = new x.constructor(y)).d,
        xs = x.s,
        ys = y.s;

      // Either NaN or Â±Infinity?
      if (!xd || !yd) {
        return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
      }

      // Either zero?
      if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

      // Signs differ?
      if (xs !== ys) return xs;

      // Compare exponents.
      if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

      xdL = xd.length;
      ydL = yd.length;

      // Compare digit by digit.
      for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
        if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
      }

      // Compare lengths.
      return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
    };


    /*
     * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * cos(0)         = 1
     * cos(-0)        = 1
     * cos(Infinity)  = NaN
     * cos(-Infinity) = NaN
     * cos(NaN)       = NaN
     *
     */
    P.cosine = P.cos = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.d) return new Ctor(NaN);

      // cos(0) = cos(-0) = 1
      if (!x.d[0]) return new Ctor(1);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
    };


    /*
     *
     * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     *  cbrt(0)  =  0
     *  cbrt(-0) = -0
     *  cbrt(1)  =  1
     *  cbrt(-1) = -1
     *  cbrt(N)  =  N
     *  cbrt(-I) = -I
     *  cbrt(I)  =  I
     *
     * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
     *
     */
    P.cubeRoot = P.cbrt = function () {
      var e, m, n, r, rep, s, sd, t, t3, t3plusx,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);
      external = false;

      // Initial estimate.
      s = x.s * mathpow(x.s * x, 1 / 3);

       // Math.cbrt underflow/overflow?
       // Pass x to Math.pow as integer, then adjust the exponent of the result.
      if (!s || Math.abs(s) == 1 / 0) {
        n = digitsToString(x.d);
        e = x.e;

        // Adjust n exponent so it is a multiple of 3 away from x exponent.
        if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
        s = mathpow(n, 1 / 3);

        // Rarely, e may be one less than the result exponent value.
        e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
        r.s = x.s;
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Halley's method.
      // TODO? Compare Newton's method.
      for (;;) {
        t = r;
        t3 = t.times(t).times(t);
        t3plusx = t3.plus(x);
        r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
          // , i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return the number of decimal places of the value of this Decimal.
     *
     */
    P.decimalPlaces = P.dp = function () {
      var w,
        d = this.d,
        n = NaN;

      if (d) {
        w = d.length - 1;
        n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

        // Subtract the number of trailing zeros of the last word.
        w = d[w];
        if (w) for (; w % 10 == 0; w /= 10) n--;
        if (n < 0) n = 0;
      }

      return n;
    };


    /*
     *  n / 0 = I
     *  n / N = N
     *  n / I = 0
     *  0 / n = 0
     *  0 / 0 = N
     *  0 / N = N
     *  0 / I = 0
     *  N / n = N
     *  N / 0 = N
     *  N / N = N
     *  N / I = N
     *  I / n = I
     *  I / 0 = I
     *  I / N = N
     *  I / I = N
     *
     * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedBy = P.div = function (y) {
      return divide(this, new this.constructor(y));
    };


    /*
     * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
     * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.dividedToIntegerBy = P.divToInt = function (y) {
      var x = this,
        Ctor = x.constructor;
      return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
    };


    /*
     * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
     *
     */
    P.equals = P.eq = function (y) {
      return this.cmp(y) === 0;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
     * direction of negative Infinity.
     *
     */
    P.floor = function () {
      return finalise(new this.constructor(this), this.e + 1, 3);
    };


    /*
     * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
     * false.
     *
     */
    P.greaterThan = P.gt = function (y) {
      return this.cmp(y) > 0;
    };


    /*
     * Return true if the value of this Decimal is greater than or equal to the value of `y`,
     * otherwise return false.
     *
     */
    P.greaterThanOrEqualTo = P.gte = function (y) {
      var k = this.cmp(y);
      return k == 1 || k === 0;
    };


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [1, Infinity]
     *
     * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
     *
     * cosh(0)         = 1
     * cosh(-0)        = 1
     * cosh(Infinity)  = Infinity
     * cosh(-Infinity) = Infinity
     * cosh(NaN)       = NaN
     *
     *  x        time taken (ms)   result
     * 1000      9                 9.8503555700852349694e+433
     * 10000     25                4.4034091128314607936e+4342
     * 100000    171               1.4033316802130615897e+43429
     * 1000000   3817              1.5166076984010437725e+434294
     * 10000000  abandoned after 2 minute wait
     *
     * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
     *
     */
    P.hyperbolicCosine = P.cosh = function () {
      var k, n, pr, rm, len,
        x = this,
        Ctor = x.constructor,
        one = new Ctor(1);

      if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
      if (x.isZero()) return one;

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
      // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

      // Estimate the optimum number of times to use the argument reduction.
      // TODO? Estimation reused from cosine() and may not be optimal here.
      if (len < 32) {
        k = Math.ceil(len / 3);
        n = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        n = '2.3283064365386962890625e-10';
      }

      x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

      // Reverse argument reduction
      var cosh2_x,
        i = k,
        d8 = new Ctor(8);
      for (; i--;) {
        cosh2_x = x.times(x);
        x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
      }

      return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
     *
     * sinh(0)         = 0
     * sinh(-0)        = -0
     * sinh(Infinity)  = Infinity
     * sinh(-Infinity) = -Infinity
     * sinh(NaN)       = NaN
     *
     * x        time taken (ms)
     * 10       2 ms
     * 100      5 ms
     * 1000     14 ms
     * 10000    82 ms
     * 100000   886 ms            1.4033316802130615897e+43429
     * 200000   2613 ms
     * 300000   5407 ms
     * 400000   8824 ms
     * 500000   13026 ms          8.7080643612718084129e+217146
     * 1000000  48543 ms
     *
     * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
     *
     */
    P.hyperbolicSine = P.sinh = function () {
      var k, pr, rm, len,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
      Ctor.rounding = 1;
      len = x.d.length;

      if (len < 3) {
        x = taylorSeries(Ctor, 2, x, x, true);
      } else {

        // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
        // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
        // 3 multiplications and 1 addition

        // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
        // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
        // 4 multiplications and 2 additions

        // Estimate the optimum number of times to use the argument reduction.
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;

        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x, true);

        // Reverse argument reduction
        var sinh2_x,
          d5 = new Ctor(5),
          d16 = new Ctor(16),
          d20 = new Ctor(20);
        for (; k--;) {
          sinh2_x = x.times(x);
          x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
        }
      }

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * tanh(x) = sinh(x) / cosh(x)
     *
     * tanh(0)         = 0
     * tanh(-0)        = -0
     * tanh(Infinity)  = 1
     * tanh(-Infinity) = -1
     * tanh(NaN)       = NaN
     *
     */
    P.hyperbolicTangent = P.tanh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(x.s);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 7;
      Ctor.rounding = 1;

      return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
    };


    /*
     * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
     * this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [0, pi]
     *
     * acos(x) = pi/2 - asin(x)
     *
     * acos(0)       = pi/2
     * acos(-0)      = pi/2
     * acos(1)       = 0
     * acos(-1)      = pi
     * acos(1/2)     = pi/3
     * acos(-1/2)    = 2*pi/3
     * acos(|x| > 1) = NaN
     * acos(NaN)     = NaN
     *
     */
    P.inverseCosine = P.acos = function () {
      var halfPi,
        x = this,
        Ctor = x.constructor,
        k = x.abs().cmp(1),
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (k !== -1) {
        return k === 0
          // |x| is 1
          ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
          // |x| > 1 or x is NaN
          : new Ctor(NaN);
      }

      if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

      // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.asin();
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return halfPi.minus(x);
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
     * value of this Decimal.
     *
     * Domain: [1, Infinity]
     * Range: [0, Infinity]
     *
     * acosh(x) = ln(x + sqrt(x^2 - 1))
     *
     * acosh(x < 1)     = NaN
     * acosh(NaN)       = NaN
     * acosh(Infinity)  = Infinity
     * acosh(-Infinity) = NaN
     * acosh(0)         = NaN
     * acosh(-0)        = NaN
     * acosh(1)         = 0
     * acosh(-1)        = NaN
     *
     */
    P.inverseHyperbolicCosine = P.acosh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
      if (!x.isFinite()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).minus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * asinh(x) = ln(x + sqrt(x^2 + 1))
     *
     * asinh(NaN)       = NaN
     * asinh(Infinity)  = Infinity
     * asinh(-Infinity) = -Infinity
     * asinh(0)         = 0
     * asinh(-0)        = -0
     *
     */
    P.inverseHyperbolicSine = P.asinh = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite() || x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
      Ctor.rounding = 1;
      external = false;

      x = x.times(x).plus(1).sqrt().plus(x);

      external = true;
      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.ln();
    };


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
     * value of this Decimal.
     *
     * Domain: [-1, 1]
     * Range: [-Infinity, Infinity]
     *
     * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
     *
     * atanh(|x| > 1)   = NaN
     * atanh(NaN)       = NaN
     * atanh(Infinity)  = NaN
     * atanh(-Infinity) = NaN
     * atanh(0)         = 0
     * atanh(-0)        = -0
     * atanh(1)         = Infinity
     * atanh(-1)        = -Infinity
     *
     */
    P.inverseHyperbolicTangent = P.atanh = function () {
      var pr, rm, wpr, xsd,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      xsd = x.sd();

      if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

      Ctor.precision = wpr = xsd - x.e;

      x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

      Ctor.precision = pr + 4;
      Ctor.rounding = 1;

      x = x.ln();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(0.5);
    };


    /*
     * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
     * Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
     *
     * asin(0)       = 0
     * asin(-0)      = -0
     * asin(1/2)     = pi/6
     * asin(-1/2)    = -pi/6
     * asin(1)       = pi/2
     * asin(-1)      = -pi/2
     * asin(|x| > 1) = NaN
     * asin(NaN)     = NaN
     *
     * TODO? Compare performance of Taylor series.
     *
     */
    P.inverseSine = P.asin = function () {
      var halfPi, k,
        pr, rm,
        x = this,
        Ctor = x.constructor;

      if (x.isZero()) return new Ctor(x);

      k = x.abs().cmp(1);
      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (k !== -1) {

        // |x| is 1
        if (k === 0) {
          halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
          halfPi.s = x.s;
          return halfPi;
        }

        // |x| > 1 or x is NaN
        return new Ctor(NaN);
      }

      // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

      Ctor.precision = pr + 6;
      Ctor.rounding = 1;

      x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return x.times(2);
    };


    /*
     * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
     * of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi/2, pi/2]
     *
     * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
     *
     * atan(0)         = 0
     * atan(-0)        = -0
     * atan(1)         = pi/4
     * atan(-1)        = -pi/4
     * atan(Infinity)  = pi/2
     * atan(-Infinity) = -pi/2
     * atan(NaN)       = NaN
     *
     */
    P.inverseTangent = P.atan = function () {
      var i, j, k, n, px, t, r, wpr, x2,
        x = this,
        Ctor = x.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding;

      if (!x.isFinite()) {
        if (!x.s) return new Ctor(NaN);
        if (pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.5);
          r.s = x.s;
          return r;
        }
      } else if (x.isZero()) {
        return new Ctor(x);
      } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.25);
        r.s = x.s;
        return r;
      }

      Ctor.precision = wpr = pr + 10;
      Ctor.rounding = 1;

      // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

      // Argument reduction
      // Ensure |x| < 0.42
      // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

      k = Math.min(28, wpr / LOG_BASE + 2 | 0);

      for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

      external = false;

      j = Math.ceil(wpr / LOG_BASE);
      n = 1;
      x2 = x.times(x);
      r = new Ctor(x);
      px = x;

      // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
      for (; i !== -1;) {
        px = px.times(x2);
        t = r.minus(px.div(n += 2));

        px = px.times(x2);
        r = t.plus(px.div(n += 2));

        if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
      }

      if (k) r = r.times(2 << (k - 1));

      external = true;

      return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
    };


    /*
     * Return true if the value of this Decimal is a finite number, otherwise return false.
     *
     */
    P.isFinite = function () {
      return !!this.d;
    };


    /*
     * Return true if the value of this Decimal is an integer, otherwise return false.
     *
     */
    P.isInteger = P.isInt = function () {
      return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
    };


    /*
     * Return true if the value of this Decimal is NaN, otherwise return false.
     *
     */
    P.isNaN = function () {
      return !this.s;
    };


    /*
     * Return true if the value of this Decimal is negative, otherwise return false.
     *
     */
    P.isNegative = P.isNeg = function () {
      return this.s < 0;
    };


    /*
     * Return true if the value of this Decimal is positive, otherwise return false.
     *
     */
    P.isPositive = P.isPos = function () {
      return this.s > 0;
    };


    /*
     * Return true if the value of this Decimal is 0 or -0, otherwise return false.
     *
     */
    P.isZero = function () {
      return !!this.d && this.d[0] === 0;
    };


    /*
     * Return true if the value of this Decimal is less than `y`, otherwise return false.
     *
     */
    P.lessThan = P.lt = function (y) {
      return this.cmp(y) < 0;
    };


    /*
     * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
     *
     */
    P.lessThanOrEqualTo = P.lte = function (y) {
      return this.cmp(y) < 1;
    };


    /*
     * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * If no base is specified, return log[10](arg).
     *
     * log[base](arg) = ln(arg) / ln(base)
     *
     * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
     * otherwise:
     *
     * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
     * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
     * between the result and the correctly rounded result will be one ulp (unit in the last place).
     *
     * log[-b](a)       = NaN
     * log[0](a)        = NaN
     * log[1](a)        = NaN
     * log[NaN](a)      = NaN
     * log[Infinity](a) = NaN
     * log[b](0)        = -Infinity
     * log[b](-0)       = -Infinity
     * log[b](-a)       = NaN
     * log[b](1)        = 0
     * log[b](Infinity) = Infinity
     * log[b](NaN)      = NaN
     *
     * [base] {number|string|Decimal} The base of the logarithm.
     *
     */
    P.logarithm = P.log = function (base) {
      var isBase10, d, denominator, k, inf, num, sd, r,
        arg = this,
        Ctor = arg.constructor,
        pr = Ctor.precision,
        rm = Ctor.rounding,
        guard = 5;

      // Default base is 10.
      if (base == null) {
        base = new Ctor(10);
        isBase10 = true;
      } else {
        base = new Ctor(base);
        d = base.d;

        // Return NaN if base is negative, or non-finite, or is 0 or 1.
        if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

        isBase10 = base.eq(10);
      }

      d = arg.d;

      // Is arg negative, non-finite, 0 or 1?
      if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
        return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
      }

      // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
      // integer power of 10.
      if (isBase10) {
        if (d.length > 1) {
          inf = true;
        } else {
          for (k = d[0]; k % 10 === 0;) k /= 10;
          inf = k !== 1;
        }
      }

      external = false;
      sd = pr + guard;
      num = naturalLogarithm(arg, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

      // The result will have 5 rounding digits.
      r = divide(num, denominator, sd, 1);

      // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
      // calculate 10 further digits.
      //
      // If the result is known to have an infinite decimal expansion, repeat this until it is clear
      // that the result is above or below the boundary. Otherwise, if after calculating the 10
      // further digits, the last 14 are nines, round up and assume the result is exact.
      // Also assume the result is exact if the last 14 are zero.
      //
      // Example of a result that will be incorrectly rounded:
      // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
      // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
      // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
      // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
      // place is still 2.6.
      if (checkRoundingDigits(r.d, k = pr, rm)) {

        do {
          sd += 10;
          num = naturalLogarithm(arg, sd);
          denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
          r = divide(num, denominator, sd, 1);

          if (!inf) {

            // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
            if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }

            break;
          }
        } while (checkRoundingDigits(r.d, k += 10, rm));
      }

      external = true;

      return finalise(r, pr, rm);
    };


    /*
     * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.max = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'lt');
    };
     */


    /*
     * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
     *
     * arguments {number|string|Decimal}
     *
    P.min = function () {
      Array.prototype.push.call(arguments, this);
      return maxOrMin(this.constructor, arguments, 'gt');
    };
     */


    /*
     *  n - 0 = n
     *  n - N = N
     *  n - I = -I
     *  0 - n = -n
     *  0 - 0 = 0
     *  0 - N = N
     *  0 - I = -I
     *  N - n = N
     *  N - 0 = N
     *  N - N = N
     *  N - I = N
     *  I - n = I
     *  I - 0 = I
     *  I - N = N
     *  I - I = N
     *
     * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.minus = P.sub = function (y) {
      var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return y negated if x is finite and y is Â±Infinity.
        else if (x.d) y.s = -y.s;

        // Return x if y is finite and x is Â±Infinity.
        // Return x if both are Â±Infinity with different signs.
        // Return NaN if both are Â±Infinity with the same sign.
        else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

        return y;
      }

      // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.plus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return y negated if x is zero and y is non-zero.
        if (yd[0]) y.s = -y.s;

        // Return x if y is zero and x is non-zero.
        else if (xd[0]) y = new Ctor(x);

        // Return zero if both are zero.
        // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
        else return new Ctor(rm === 3 ? -0 : 0);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      e = mathfloor(y.e / LOG_BASE);
      xe = mathfloor(x.e / LOG_BASE);

      xd = xd.slice();
      k = xe - e;

      // If base 1e7 exponents differ...
      if (k) {
        xLTy = k < 0;

        if (xLTy) {
          d = xd;
          k = -k;
          len = yd.length;
        } else {
          d = yd;
          e = xe;
          len = xd.length;
        }

        // Numbers with massively different exponents would result in a very high number of
        // zeros needing to be prepended, but this can be avoided while still ensuring correct
        // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
        i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

        if (k > i) {
          k = i;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents.
        d.reverse();
        for (i = k; i--;) d.push(0);
        d.reverse();

      // Base 1e7 exponents equal.
      } else {

        // Check digits to determine which is the bigger number.

        i = xd.length;
        len = yd.length;
        xLTy = i < len;
        if (xLTy) len = i;

        for (i = 0; i < len; i++) {
          if (xd[i] != yd[i]) {
            xLTy = xd[i] < yd[i];
            break;
          }
        }

        k = 0;
      }

      if (xLTy) {
        d = xd;
        xd = yd;
        yd = d;
        y.s = -y.s;
      }

      len = xd.length;

      // Append zeros to `xd` if shorter.
      // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
      for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

      // Subtract yd from xd.
      for (i = yd.length; i > k;) {

        if (xd[--i] < yd[i]) {
          for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
          --xd[j];
          xd[i] += BASE;
        }

        xd[i] -= yd[i];
      }

      // Remove trailing zeros.
      for (; xd[--len] === 0;) xd.pop();

      // Remove leading zeros and adjust exponent accordingly.
      for (; xd[0] === 0; xd.shift()) --e;

      // Zero?
      if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     *   n % 0 =  N
     *   n % N =  N
     *   n % I =  n
     *   0 % n =  0
     *  -0 % n = -0
     *   0 % 0 =  N
     *   0 % N =  N
     *   0 % I =  0
     *   N % n =  N
     *   N % 0 =  N
     *   N % N =  N
     *   N % I =  N
     *   I % n =  N
     *   I % 0 =  N
     *   I % N =  N
     *   I % I =  N
     *
     * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * The result depends on the modulo mode.
     *
     */
    P.modulo = P.mod = function (y) {
      var q,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // Return NaN if x is Â±Infinity or NaN, or y is NaN or Â±0.
      if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

      // Return x if y is Â±Infinity or x is Â±0.
      if (!y.d || x.d && !x.d[0]) {
        return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
      }

      // Prevent rounding of intermediate calculations.
      external = false;

      if (Ctor.modulo == 9) {

        // Euclidian division: q = sign(y) * floor(x / abs(y))
        // result = x - q * y    where  0 <= result < abs(y)
        q = divide(x, y.abs(), 0, 3, 1);
        q.s *= y.s;
      } else {
        q = divide(x, y, 0, Ctor.modulo, 1);
      }

      q = q.times(y);

      external = true;

      return x.minus(q);
    };


    /*
     * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
     * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.naturalExponential = P.exp = function () {
      return naturalExponential(this);
    };


    /*
     * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     */
    P.naturalLogarithm = P.ln = function () {
      return naturalLogarithm(this);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
     * -1.
     *
     */
    P.negated = P.neg = function () {
      var x = new this.constructor(this);
      x.s = -x.s;
      return finalise(x);
    };


    /*
     *  n + 0 = n
     *  n + N = N
     *  n + I = I
     *  0 + n = n
     *  0 + 0 = 0
     *  0 + N = N
     *  0 + I = I
     *  N + n = N
     *  N + 0 = N
     *  N + N = N
     *  N + I = N
     *  I + n = I
     *  I + 0 = I
     *  I + N = N
     *  I + I = I
     *
     * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     */
    P.plus = P.add = function (y) {
      var carry, d, e, i, k, len, pr, rm, xd, yd,
        x = this,
        Ctor = x.constructor;

      y = new Ctor(y);

      // If either is not finite...
      if (!x.d || !y.d) {

        // Return NaN if either is NaN.
        if (!x.s || !y.s) y = new Ctor(NaN);

        // Return x if y is finite and x is Â±Infinity.
        // Return x if both are Â±Infinity with the same sign.
        // Return NaN if both are Â±Infinity with different signs.
        // Return y if x is finite and y is Â±Infinity.
        else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

        return y;
      }

       // If signs differ...
      if (x.s != y.s) {
        y.s = -y.s;
        return x.minus(y);
      }

      xd = x.d;
      yd = y.d;
      pr = Ctor.precision;
      rm = Ctor.rounding;

      // If either is zero...
      if (!xd[0] || !yd[0]) {

        // Return x if y is zero.
        // Return y if y is non-zero.
        if (!yd[0]) y = new Ctor(x);

        return external ? finalise(y, pr, rm) : y;
      }

      // x and y are finite, non-zero numbers with the same sign.

      // Calculate base 1e7 exponents.
      k = mathfloor(x.e / LOG_BASE);
      e = mathfloor(y.e / LOG_BASE);

      xd = xd.slice();
      i = k - e;

      // If base 1e7 exponents differ...
      if (i) {

        if (i < 0) {
          d = xd;
          i = -i;
          len = yd.length;
        } else {
          d = yd;
          e = k;
          len = xd.length;
        }

        // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
        k = Math.ceil(pr / LOG_BASE);
        len = k > len ? k + 1 : len + 1;

        if (i > len) {
          i = len;
          d.length = 1;
        }

        // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
        d.reverse();
        for (; i--;) d.push(0);
        d.reverse();
      }

      len = xd.length;
      i = yd.length;

      // If yd is longer than xd, swap xd and yd so xd points to the longer array.
      if (len - i < 0) {
        i = len;
        d = yd;
        yd = xd;
        xd = d;
      }

      // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
      for (carry = 0; i;) {
        carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
        xd[i] %= BASE;
      }

      if (carry) {
        xd.unshift(carry);
        ++e;
      }

      // Remove trailing zeros.
      // No need to check for zero, as +x + +y != 0 && -x + -y != 0
      for (len = xd.length; xd[--len] == 0;) xd.pop();

      y.d = xd;
      y.e = getBase10Exponent(xd, e);

      return external ? finalise(y, pr, rm) : y;
    };


    /*
     * Return the number of significant digits of the value of this Decimal.
     *
     * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
     *
     */
    P.precision = P.sd = function (z) {
      var k,
        x = this;

      if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

      if (x.d) {
        k = getPrecision(x.d);
        if (z && x.e + 1 > k) k = x.e + 1;
      } else {
        k = NaN;
      }

      return k;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
     * rounding mode `rounding`.
     *
     */
    P.round = function () {
      var x = this,
        Ctor = x.constructor;

      return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
    };


    /*
     * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-1, 1]
     *
     * sin(x) = x - x^3/3! + x^5/5! - ...
     *
     * sin(0)         = 0
     * sin(-0)        = -0
     * sin(Infinity)  = NaN
     * sin(-Infinity) = NaN
     * sin(NaN)       = NaN
     *
     */
    P.sine = P.sin = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
      Ctor.rounding = 1;

      x = sine(Ctor, toLessThanHalfPi(Ctor, x));

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
    };


    /*
     * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     *  sqrt(-n) =  N
     *  sqrt(N)  =  N
     *  sqrt(-I) =  N
     *  sqrt(I)  =  I
     *  sqrt(0)  =  0
     *  sqrt(-0) = -0
     *
     */
    P.squareRoot = P.sqrt = function () {
      var m, n, sd, r, rep, t,
        x = this,
        d = x.d,
        e = x.e,
        s = x.s,
        Ctor = x.constructor;

      // Negative/NaN/Infinity/zero?
      if (s !== 1 || !d || !d[0]) {
        return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
      }

      external = false;

      // Initial estimate.
      s = Math.sqrt(+x);

      // Math.sqrt underflow/overflow?
      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
      if (s == 0 || s == 1 / 0) {
        n = digitsToString(d);

        if ((n.length + e) % 2 == 0) n += '0';
        s = Math.sqrt(n);
        e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

        if (s == 1 / 0) {
          n = '5e' + e;
        } else {
          n = s.toExponential();
          n = n.slice(0, n.indexOf('e') + 1) + e;
        }

        r = new Ctor(n);
      } else {
        r = new Ctor(s.toString());
      }

      sd = (e = Ctor.precision) + 3;

      // Newton-Raphson iteration.
      for (;;) {
        t = r;
        r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

        // TODO? Replace with for-loop and checkRoundingDigits.
        if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
          n = n.slice(sd - 3, sd + 1);

          // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
          // 4999, i.e. approaching a rounding boundary, continue the iteration.
          if (n == '9999' || !rep && n == '4999') {

            // On the first iteration only, check to see if rounding up gives the exact result as the
            // nines may infinitely repeat.
            if (!rep) {
              finalise(t, e + 1, 0);

              if (t.times(t).eq(x)) {
                r = t;
                break;
              }
            }

            sd += 4;
            rep = 1;
          } else {

            // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
            // If not, then there are further digits and m will be truthy.
            if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

              // Truncate to the first rounding digit.
              finalise(r, e + 1, 1);
              m = !r.times(r).eq(x);
            }

            break;
          }
        }
      }

      external = true;

      return finalise(r, e, Ctor.rounding, m);
    };


    /*
     * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-Infinity, Infinity]
     *
     * tan(0)         = 0
     * tan(-0)        = -0
     * tan(Infinity)  = NaN
     * tan(-Infinity) = NaN
     * tan(NaN)       = NaN
     *
     */
    P.tangent = P.tan = function () {
      var pr, rm,
        x = this,
        Ctor = x.constructor;

      if (!x.isFinite()) return new Ctor(NaN);
      if (x.isZero()) return new Ctor(x);

      pr = Ctor.precision;
      rm = Ctor.rounding;
      Ctor.precision = pr + 10;
      Ctor.rounding = 1;

      x = x.sin();
      x.s = 1;
      x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

      Ctor.precision = pr;
      Ctor.rounding = rm;

      return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
    };


    /*
     *  n * 0 = 0
     *  n * N = N
     *  n * I = I
     *  0 * n = 0
     *  0 * 0 = 0
     *  0 * N = N
     *  0 * I = N
     *  N * n = N
     *  N * 0 = N
     *  N * N = N
     *  N * I = N
     *  I * n = I
     *  I * 0 = N
     *  I * N = N
     *  I * I = I
     *
     * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     */
    P.times = P.mul = function (y) {
      var carry, e, i, k, r, rL, t, xdL, ydL,
        x = this,
        Ctor = x.constructor,
        xd = x.d,
        yd = (y = new Ctor(y)).d;

      y.s *= x.s;

       // If either is NaN, Â±Infinity or Â±0...
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

          // Return NaN if either is NaN.
          // Return NaN if x is Â±0 and y is Â±Infinity, or y is Â±0 and x is Â±Infinity.
          ? NaN

          // Return Â±Infinity if either is Â±Infinity.
          // Return Â±0 if either is Â±0.
          : !xd || !yd ? y.s / 0 : y.s * 0);
      }

      e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
      xdL = xd.length;
      ydL = yd.length;

      // Ensure xd points to the longer array.
      if (xdL < ydL) {
        r = xd;
        xd = yd;
        yd = r;
        rL = xdL;
        xdL = ydL;
        ydL = rL;
      }

      // Initialise the result array with zeros.
      r = [];
      rL = xdL + ydL;
      for (i = rL; i--;) r.push(0);

      // Multiply!
      for (i = ydL; --i >= 0;) {
        carry = 0;
        for (k = xdL + i; k > i;) {
          t = r[k] + yd[i] * xd[k - i - 1] + carry;
          r[k--] = t % BASE | 0;
          carry = t / BASE | 0;
        }

        r[k] = (r[k] + carry) % BASE | 0;
      }

      // Remove trailing zeros.
      for (; !r[--rL];) r.pop();

      if (carry) ++e;
      else r.shift();

      y.d = r;
      y.e = getBase10Exponent(r, e);

      return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
    };


    /*
     * Return a string representing the value of this Decimal in base 2, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toBinary = function (sd, rm) {
      return toStringBinary(this, 2, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
     * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
     *
     * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toDecimalPlaces = P.toDP = function (dp, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);
      if (dp === void 0) return x;

      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      return finalise(x, dp + x.e + 1, rm);
    };


    /*
     * Return a string representing the value of this Decimal in exponential notation rounded to
     * `dp` fixed decimal places using rounding mode `rounding`.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toExponential = function (dp, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x, true);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), dp + 1, rm);
        str = finiteToString(x, true, dp + 1);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a string representing the value of this Decimal in normal (fixed-point) notation to
     * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
     * omitted.
     *
     * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
     *
     * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
     * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
     * (-0).toFixed(3) is '0.000'.
     * (-0.5).toFixed(0) is '-0'.
     *
     */
    P.toFixed = function (dp, rm) {
      var str, y,
        x = this,
        Ctor = x.constructor;

      if (dp === void 0) {
        str = finiteToString(x);
      } else {
        checkInt32(dp, 0, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        y = finalise(new Ctor(x), dp + x.e + 1, rm);
        str = finiteToString(y, false, dp + y.e + 1);
      }

      // To determine whether to add the minus sign look at the value before it was rounded,
      // i.e. look at `x` rather than `y`.
      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return an array representing the value of this Decimal as a simple fraction with an integer
     * numerator and an integer denominator.
     *
     * The denominator will be a positive non-zero value less than or equal to the specified maximum
     * denominator. If a maximum denominator is not specified, the denominator will be the lowest
     * value necessary to represent the number exactly.
     *
     * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
     *
     */
    P.toFraction = function (maxD) {
      var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
        x = this,
        xd = x.d,
        Ctor = x.constructor;

      if (!xd) return new Ctor(x);

      n1 = d0 = new Ctor(1);
      d1 = n0 = new Ctor(0);

      d = new Ctor(d1);
      e = d.e = getPrecision(xd) - x.e - 1;
      k = e % LOG_BASE;
      d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

      if (maxD == null) {

        // d is 10**e, the minimum max-denominator needed.
        maxD = e > 0 ? d : n1;
      } else {
        n = new Ctor(maxD);
        if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
        maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
      }

      external = false;
      n = new Ctor(digitsToString(xd));
      pr = Ctor.precision;
      Ctor.precision = e = xd.length * LOG_BASE * 2;

      for (;;)  {
        q = divide(n, d, 0, 1, 1);
        d2 = d0.plus(q.times(d1));
        if (d2.cmp(maxD) == 1) break;
        d0 = d1;
        d1 = d2;
        d2 = n1;
        n1 = n0.plus(q.times(d2));
        n0 = d2;
        d2 = d;
        d = n.minus(q.times(d2));
        n = d2;
      }

      d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
      n0 = n0.plus(d2.times(n1));
      d0 = d0.plus(d2.times(d1));
      n0.s = n1.s = x.s;

      // Determine which fraction is closer to x, n0/d0 or n1/d1?
      r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
          ? [n1, d1] : [n0, d0];

      Ctor.precision = pr;
      external = true;

      return r;
    };


    /*
     * Return a string representing the value of this Decimal in base 16, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toHexadecimal = P.toHex = function (sd, rm) {
      return toStringBinary(this, 16, sd, rm);
    };


    /*
     * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
     * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
     *
     * The return value will always have the same sign as this Decimal, unless either this Decimal
     * or `y` is NaN, in which case the return value will be also be NaN.
     *
     * The return value is not affected by the value of `precision`.
     *
     * y {number|string|Decimal} The magnitude to round to a multiple of.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toNearest() rounding mode not an integer: {rm}'
     * 'toNearest() rounding mode out of range: {rm}'
     *
     */
    P.toNearest = function (y, rm) {
      var x = this,
        Ctor = x.constructor;

      x = new Ctor(x);

      if (y == null) {

        // If x is not finite, return x.
        if (!x.d) return x;

        y = new Ctor(1);
        rm = Ctor.rounding;
      } else {
        y = new Ctor(y);
        if (rm === void 0) {
          rm = Ctor.rounding;
        } else {
          checkInt32(rm, 0, 8);
        }

        // If x is not finite, return x if y is not NaN, else NaN.
        if (!x.d) return y.s ? x : y;

        // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
        if (!y.d) {
          if (y.s) y.s = x.s;
          return y;
        }
      }

      // If y is not zero, calculate the nearest multiple of y to x.
      if (y.d[0]) {
        external = false;
        x = divide(x, y, 0, rm, 1).times(y);
        external = true;
        finalise(x);

      // If y is zero, return zero with the sign of x.
      } else {
        y.s = x.s;
        x = y;
      }

      return x;
    };


    /*
     * Return the value of this Decimal converted to a number primitive.
     * Zero keeps its sign.
     *
     */
    P.toNumber = function () {
      return +this;
    };


    /*
     * Return a string representing the value of this Decimal in base 8, round to `sd` significant
     * digits using rounding mode `rm`.
     *
     * If the optional `sd` argument is present then return binary exponential notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toOctal = function (sd, rm) {
      return toStringBinary(this, 8, sd, rm);
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
     * to `precision` significant digits using rounding mode `rounding`.
     *
     * ECMAScript compliant.
     *
     *   pow(x, NaN)                           = NaN
     *   pow(x, Â±0)                            = 1

     *   pow(NaN, non-zero)                    = NaN
     *   pow(abs(x) > 1, +Infinity)            = +Infinity
     *   pow(abs(x) > 1, -Infinity)            = +0
     *   pow(abs(x) == 1, Â±Infinity)           = NaN
     *   pow(abs(x) < 1, +Infinity)            = +0
     *   pow(abs(x) < 1, -Infinity)            = +Infinity
     *   pow(+Infinity, y > 0)                 = +Infinity
     *   pow(+Infinity, y < 0)                 = +0
     *   pow(-Infinity, odd integer > 0)       = -Infinity
     *   pow(-Infinity, even integer > 0)      = +Infinity
     *   pow(-Infinity, odd integer < 0)       = -0
     *   pow(-Infinity, even integer < 0)      = +0
     *   pow(+0, y > 0)                        = +0
     *   pow(+0, y < 0)                        = +Infinity
     *   pow(-0, odd integer > 0)              = -0
     *   pow(-0, even integer > 0)             = +0
     *   pow(-0, odd integer < 0)              = -Infinity
     *   pow(-0, even integer < 0)             = +Infinity
     *   pow(finite x < 0, finite non-integer) = NaN
     *
     * For non-integer or very large exponents pow(x, y) is calculated using
     *
     *   x^y = exp(y*ln(x))
     *
     * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
     * probability of an incorrectly rounded result
     * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
     * i.e. 1 in 250,000,000,000,000
     *
     * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
     *
     * y {number|string|Decimal} The power to which to raise this Decimal.
     *
     */
    P.toPower = P.pow = function (y) {
      var e, k, pr, r, rm, s,
        x = this,
        Ctor = x.constructor,
        yn = +(y = new Ctor(y));

      // Either Â±Infinity, NaN or Â±0?
      if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

      x = new Ctor(x);

      if (x.eq(1)) return x;

      pr = Ctor.precision;
      rm = Ctor.rounding;

      if (y.eq(1)) return finalise(x, pr, rm);

      // y exponent
      e = mathfloor(y.e / LOG_BASE);

      // If y is a small integer use the 'exponentiation by squaring' algorithm.
      if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
        r = intPow(Ctor, x, k, pr);
        return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
      }

      s = x.s;

      // if x is negative
      if (s < 0) {

        // if y is not an integer
        if (e < y.d.length - 1) return new Ctor(NaN);

        // Result is positive if x is negative and the last digit of integer y is even.
        if ((y.d[e] & 1) == 0) s = 1;

        // if x.eq(-1)
        if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
          x.s = s;
          return x;
        }
      }

      // Estimate result exponent.
      // x^y = 10^e,  where e = y * log10(x)
      // log10(x) = log10(x_significand) + x_exponent
      // log10(x_significand) = ln(x_significand) / ln(10)
      k = mathpow(+x, yn);
      e = k == 0 || !isFinite(k)
        ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
        : new Ctor(k + '').e;

      // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

      // Overflow/underflow?
      if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

      external = false;
      Ctor.rounding = x.s = 1;

      // Estimate the extra guard digits needed to ensure five correct rounding digits from
      // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
      // new Decimal(2.32456).pow('2087987436534566.46411')
      // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
      k = Math.min(12, (e + '').length);

      // r = x^y = exp(y*ln(x))
      r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

      // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
      if (r.d) {

        // Truncate to the required precision plus five rounding digits.
        r = finalise(r, pr + 5, 1);

        // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
        // the result.
        if (checkRoundingDigits(r.d, pr, rm)) {
          e = pr + 10;

          // Truncate to the increased precision plus five rounding digits.
          r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

          // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
          if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
        }
      }

      r.s = s;
      external = true;
      Ctor.rounding = rm;

      return finalise(r, pr, rm);
    };


    /*
     * Return a string representing the value of this Decimal rounded to `sd` significant digits
     * using rounding mode `rounding`.
     *
     * Return exponential notation if `sd` is less than the number of digits necessary to represent
     * the integer part of the value in normal notation.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     */
    P.toPrecision = function (sd, rm) {
      var str,
        x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);

        x = finalise(new Ctor(x), sd, rm);
        str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
      }

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
     * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
     * omitted.
     *
     * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
     *
     * 'toSD() digits out of range: {sd}'
     * 'toSD() digits not an integer: {sd}'
     * 'toSD() rounding mode not an integer: {rm}'
     * 'toSD() rounding mode out of range: {rm}'
     *
     */
    P.toSignificantDigits = P.toSD = function (sd, rm) {
      var x = this,
        Ctor = x.constructor;

      if (sd === void 0) {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      } else {
        checkInt32(sd, 1, MAX_DIGITS);

        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      }

      return finalise(new Ctor(x), sd, rm);
    };


    /*
     * Return a string representing the value of this Decimal.
     *
     * Return exponential notation if this Decimal has a positive exponent equal to or greater than
     * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
     *
     */
    P.toString = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() && !x.isZero() ? '-' + str : str;
    };


    /*
     * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
     *
     */
    P.truncated = P.trunc = function () {
      return finalise(new this.constructor(this), this.e + 1, 1);
    };


    /*
     * Return a string representing the value of this Decimal.
     * Unlike `toString`, negative zero will include the minus sign.
     *
     */
    P.valueOf = P.toJSON = function () {
      var x = this,
        Ctor = x.constructor,
        str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

      return x.isNeg() ? '-' + str : str;
    };


    /*
    // Add aliases to match BigDecimal method names.
    // P.add = P.plus;
    P.subtract = P.minus;
    P.multiply = P.times;
    P.divide = P.div;
    P.remainder = P.mod;
    P.compareTo = P.cmp;
    P.negate = P.neg;
     */


    // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


    /*
     *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
     *                           finiteToString, naturalExponential, naturalLogarithm
     *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
     *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
     *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
     *  convertBase              toStringBinary, parseOther
     *  cos                      P.cos
     *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
     *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
     *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
     *                           taylorSeries, atan2, parseOther
     *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
     *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
     *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
     *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
     *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
     *                           P.truncated, divide, getLn10, getPi, naturalExponential,
     *                           naturalLogarithm, ceil, floor, round, trunc
     *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
     *                           toStringBinary
     *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
     *  getLn10                  P.logarithm, naturalLogarithm
     *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
     *  getPrecision             P.precision, P.toFraction
     *  getZeroString            digitsToString, finiteToString
     *  intPow                   P.toPower, parseOther
     *  isOdd                    toLessThanHalfPi
     *  maxOrMin                 max, min
     *  naturalExponential       P.naturalExponential, P.toPower
     *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
     *                           P.toPower, naturalExponential
     *  nonFiniteToString        finiteToString, toStringBinary
     *  parseDecimal             Decimal
     *  parseOther               Decimal
     *  sin                      P.sin
     *  taylorSeries             P.cosh, P.sinh, cos, sin
     *  toLessThanHalfPi         P.cos, P.sin
     *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
     *  truncate                 intPow
     *
     *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
     *                           naturalLogarithm, config, parseOther, random, Decimal
     */


    function digitsToString(d) {
      var i, k, ws,
        indexOfLastWord = d.length - 1,
        str = '',
        w = d[0];

      if (indexOfLastWord > 0) {
        str += w;
        for (i = 1; i < indexOfLastWord; i++) {
          ws = d[i] + '';
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
          str += ws;
        }

        w = d[i];
        ws = w + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
      } else if (w === 0) {
        return '0';
      }

      // Remove trailing zeros of last w.
      for (; w % 10 === 0;) w /= 10;

      return str + w;
    }


    function checkInt32(i, min, max) {
      if (i !== ~~i || i < min || i > max) {
        throw Error(invalidArgument + i);
      }
    }


    /*
     * Check 5 rounding digits if `repeating` is null, 4 otherwise.
     * `repeating == null` if caller is `log` or `pow`,
     * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
     */
    function checkRoundingDigits(d, i, rm, repeating) {
      var di, k, r, rd;

      // Get the length of the first word of the array d.
      for (k = d[0]; k >= 10; k /= 10) --i;

      // Is the rounding digit in the first word of d?
      if (--i < 0) {
        i += LOG_BASE;
        di = 0;
      } else {
        di = Math.ceil((i + 1) / LOG_BASE);
        i %= LOG_BASE;
      }

      // i is the index (0 - 6) of the rounding digit.
      // E.g. if within the word 3487563 the first rounding digit is 5,
      // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
      k = mathpow(10, LOG_BASE - i);
      rd = d[di] % k | 0;

      if (repeating == null) {
        if (i < 3) {
          if (i == 0) rd = rd / 100 | 0;
          else if (i == 1) rd = rd / 10 | 0;
          r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
        } else {
          r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
            (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
              (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
        }
      } else {
        if (i < 4) {
          if (i == 0) rd = rd / 1000 | 0;
          else if (i == 1) rd = rd / 100 | 0;
          else if (i == 2) rd = rd / 10 | 0;
          r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
        } else {
          r = ((repeating || rm < 4) && rd + 1 == k ||
          (!repeating && rm > 3) && rd + 1 == k / 2) &&
            (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
        }
      }

      return r;
    }


    // Convert string of `baseIn` to an array of numbers of `baseOut`.
    // Eg. convertBase('255', 10, 16) returns [15, 15].
    // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
    function convertBase(str, baseIn, baseOut) {
      var j,
        arr = [0],
        arrL,
        i = 0,
        strL = str.length;

      for (; i < strL;) {
        for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
        arr[0] += NUMERALS.indexOf(str.charAt(i++));
        for (j = 0; j < arr.length; j++) {
          if (arr[j] > baseOut - 1) {
            if (arr[j + 1] === void 0) arr[j + 1] = 0;
            arr[j + 1] += arr[j] / baseOut | 0;
            arr[j] %= baseOut;
          }
        }
      }

      return arr.reverse();
    }


    /*
     * cos(x) = 1 - x^2/2! + x^4/4! - ...
     * |x| < pi/2
     *
     */
    function cosine(Ctor, x) {
      var k, y,
        len = x.d.length;

      // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
      // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

      // Estimate the optimum number of times to use the argument reduction.
      if (len < 32) {
        k = Math.ceil(len / 3);
        y = (1 / tinyPow(4, k)).toString();
      } else {
        k = 16;
        y = '2.3283064365386962890625e-10';
      }

      Ctor.precision += k;

      x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

      // Reverse argument reduction
      for (var i = k; i--;) {
        var cos2x = x.times(x);
        x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
      }

      Ctor.precision -= k;

      return x;
    }


    /*
     * Perform division in the specified base.
     */
    var divide = (function () {

      // Assumes non-zero x and k, and hence non-zero result.
      function multiplyInteger(x, k, base) {
        var temp,
          carry = 0,
          i = x.length;

        for (x = x.slice(); i--;) {
          temp = x[i] * k + carry;
          x[i] = temp % base | 0;
          carry = temp / base | 0;
        }

        if (carry) x.unshift(carry);

        return x;
      }

      function compare(a, b, aL, bL) {
        var i, r;

        if (aL != bL) {
          r = aL > bL ? 1 : -1;
        } else {
          for (i = r = 0; i < aL; i++) {
            if (a[i] != b[i]) {
              r = a[i] > b[i] ? 1 : -1;
              break;
            }
          }
        }

        return r;
      }

      function subtract(a, b, aL, base) {
        var i = 0;

        // Subtract b from a.
        for (; aL--;) {
          a[aL] -= i;
          i = a[aL] < b[aL] ? 1 : 0;
          a[aL] = i * base + a[aL] - b[aL];
        }

        // Remove leading zeros.
        for (; !a[0] && a.length > 1;) a.shift();
      }

      return function (x, y, pr, rm, dp, base) {
        var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
          yL, yz,
          Ctor = x.constructor,
          sign = x.s == y.s ? 1 : -1,
          xd = x.d,
          yd = y.d;

        // Either NaN, Infinity or 0?
        if (!xd || !xd[0] || !yd || !yd[0]) {

          return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
            !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

            // Return Â±0 if x is 0 or y is Â±Infinity, or return Â±Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
        }

        if (base) {
          logBase = 1;
          e = x.e - y.e;
        } else {
          base = BASE;
          logBase = LOG_BASE;
          e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
        }

        yL = yd.length;
        xL = xd.length;
        q = new Ctor(sign);
        qd = q.d = [];

        // Result exponent may be one less than e.
        // The digit array of a Decimal from toStringBinary may have trailing zeros.
        for (i = 0; yd[i] == (xd[i] || 0); i++);

        if (yd[i] > (xd[i] || 0)) e--;

        if (pr == null) {
          sd = pr = Ctor.precision;
          rm = Ctor.rounding;
        } else if (dp) {
          sd = pr + (x.e - y.e) + 1;
        } else {
          sd = pr;
        }

        if (sd < 0) {
          qd.push(1);
          more = true;
        } else {

          // Convert precision in number of base 10 digits to base 1e7 digits.
          sd = sd / logBase + 2 | 0;
          i = 0;

          // divisor < 1e7
          if (yL == 1) {
            k = 0;
            yd = yd[0];
            sd++;

            // k is the carry.
            for (; (i < xL || k) && sd--; i++) {
              t = k * base + (xd[i] || 0);
              qd[i] = t / yd | 0;
              k = t % yd | 0;
            }

            more = k || i < xL;

          // divisor >= 1e7
          } else {

            // Normalise xd and yd so highest order digit of yd is >= base/2
            k = base / (yd[0] + 1) | 0;

            if (k > 1) {
              yd = multiplyInteger(yd, k, base);
              xd = multiplyInteger(xd, k, base);
              yL = yd.length;
              xL = xd.length;
            }

            xi = yL;
            rem = xd.slice(0, yL);
            remL = rem.length;

            // Add zeros to make remainder as long as divisor.
            for (; remL < yL;) rem[remL++] = 0;

            yz = yd.slice();
            yz.unshift(0);
            yd0 = yd[0];

            if (yd[1] >= base / 2) ++yd0;

            do {
              k = 0;

              // Compare divisor and remainder.
              cmp = compare(yd, rem, yL, remL);

              // If divisor < remainder.
              if (cmp < 0) {

                // Calculate trial digit, k.
                rem0 = rem[0];
                if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

                // k will be how many times the divisor goes into the current remainder.
                k = rem0 / yd0 | 0;

                //  Algorithm:
                //  1. product = divisor * trial digit (k)
                //  2. if product > remainder: product -= divisor, k--
                //  3. remainder -= product
                //  4. if product was < remainder at 2:
                //    5. compare new remainder and divisor
                //    6. If remainder > divisor: remainder -= divisor, k++

                if (k > 1) {
                  if (k >= base) k = base - 1;

                  // product = divisor * trial digit.
                  prod = multiplyInteger(yd, k, base);
                  prodL = prod.length;
                  remL = rem.length;

                  // Compare product and remainder.
                  cmp = compare(prod, rem, prodL, remL);

                  // product > remainder.
                  if (cmp == 1) {
                    k--;

                    // Subtract divisor from product.
                    subtract(prod, yL < prodL ? yz : yd, prodL, base);
                  }
                } else {

                  // cmp is -1.
                  // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                  // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                  if (k == 0) cmp = k = 1;
                  prod = yd.slice();
                }

                prodL = prod.length;
                if (prodL < remL) prod.unshift(0);

                // Subtract product from remainder.
                subtract(rem, prod, remL, base);

                // If product was < previous remainder.
                if (cmp == -1) {
                  remL = rem.length;

                  // Compare divisor and new remainder.
                  cmp = compare(yd, rem, yL, remL);

                  // If divisor < new remainder, subtract divisor from remainder.
                  if (cmp < 1) {
                    k++;

                    // Subtract divisor from remainder.
                    subtract(rem, yL < remL ? yz : yd, remL, base);
                  }
                }

                remL = rem.length;
              } else if (cmp === 0) {
                k++;
                rem = [0];
              }    // if cmp === 1, k will be 0

              // Add the next digit, k, to the result array.
              qd[i++] = k;

              // Update the remainder.
              if (cmp && rem[0]) {
                rem[remL++] = xd[xi] || 0;
              } else {
                rem = [xd[xi]];
                remL = 1;
              }

            } while ((xi++ < xL || rem[0] !== void 0) && sd--);

            more = rem[0] !== void 0;
          }

          // Leading zero?
          if (!qd[0]) qd.shift();
        }

        // logBase is 1 when divide is being used for base conversion.
        if (logBase == 1) {
          q.e = e;
          inexact = more;
        } else {

          // To calculate q.e, first get the number of digits of qd[0].
          for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
          q.e = i + e * logBase - 1;

          finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
        }

        return q;
      };
    })();


    /*
     * Round `x` to `sd` significant digits using rounding mode `rm`.
     * Check for over/under-flow.
     */
     function finalise(x, sd, rm, isTruncated) {
      var digits, i, j, k, rd, roundUp, w, xd, xdi,
        Ctor = x.constructor;

      // Don't round if sd is null or undefined.
      out: if (sd != null) {
        xd = x.d;

        // Infinity/NaN.
        if (!xd) return x;

        // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
        // w: the word of xd containing rd, a base 1e7 number.
        // xdi: the index of w within xd.
        // digits: the number of digits of w.
        // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
        // they had leading zeros)
        // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

        // Get the length of the first word of the digits array xd.
        for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
        i = sd - digits;

        // Is the rounding digit in the first word of xd?
        if (i < 0) {
          i += LOG_BASE;
          j = sd;
          w = xd[xdi = 0];

          // Get the rounding digit at index j of w.
          rd = w / mathpow(10, digits - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {

              // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
              for (; k++ <= xdi;) xd.push(0);
              w = rd = 0;
              digits = 1;
              i %= LOG_BASE;
              j = i - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w = k = xd[xdi];

            // Get the number of digits of w.
            for (digits = 1; k >= 10; k /= 10) digits++;

            // Get the index of rd within w.
            i %= LOG_BASE;

            // Get the index of rd within w, adjusted for leading zeros.
            // The number of leading zeros of w is given by LOG_BASE - digits.
            j = i - LOG_BASE + digits;

            // Get the rounding digit at index j of w.
            rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
          }
        }

        // Are there any non-zero digits after the rounding digit?
        isTruncated = isTruncated || sd < 0 ||
          xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

        // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
        // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
        // will give 714.

        roundUp = rm < 4
          ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
          : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

            // Check whether the digit to the left of the rounding digit is odd.
            ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
              rm == (x.s < 0 ? 8 : 7));

        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {

            // Convert sd to decimal places.
            sd -= x.e + 1;

            // 1, 0.1, 0.01, 0.001, 0.0001 etc.
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {

            // Zero.
            xd[0] = x.e = 0;
          }

          return x;
        }

        // Remove excess digits.
        if (i == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i);

          // E.g. 56700 becomes 56000 if 7 is the rounding digit.
          // j > 0 means i > number of leading zeros of w.
          xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
        }

        if (roundUp) {
          for (;;) {

            // Is the digit to be rounded up in the first word of xd?
            if (xdi == 0) {

              // i will be the length of xd[0] before k is added.
              for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10) k++;

              // if i != k the length has increased.
              if (i != k) {
                x.e++;
                if (xd[0] == BASE) xd[0] = 1;
              }

              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE) break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }

        // Remove trailing zeros.
        for (i = xd.length; xd[--i] === 0;) xd.pop();
      }

      if (external) {

        // Overflow?
        if (x.e > Ctor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < Ctor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // Ctor.underflow = true;
        } // else Ctor.underflow = false;
      }

      return x;
    }


    function finiteToString(x, isExp, sd) {
      if (!x.isFinite()) return nonFiniteToString(x);
      var k,
        e = x.e,
        str = digitsToString(x.d),
        len = str.length;

      if (isExp) {
        if (sd && (k = sd - len) > 0) {
          str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
        } else if (len > 1) {
          str = str.charAt(0) + '.' + str.slice(1);
        }

        str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
      } else if (e < 0) {
        str = '0.' + getZeroString(-e - 1) + str;
        if (sd && (k = sd - len) > 0) str += getZeroString(k);
      } else if (e >= len) {
        str += getZeroString(e + 1 - len);
        if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
      } else {
        if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
        if (sd && (k = sd - len) > 0) {
          if (e + 1 === len) str += '.';
          str += getZeroString(k);
        }
      }

      return str;
    }


    // Calculate the base 10 exponent from the base 1e7 exponent.
    function getBase10Exponent(digits, e) {
      var w = digits[0];

      // Add the number of digits of the first word of the digits array.
      for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
      return e;
    }


    function getLn10(Ctor, sd, pr) {
      if (sd > LN10_PRECISION) {

        // Reset global state in case the exception is caught.
        external = true;
        if (pr) Ctor.precision = pr;
        throw Error(precisionLimitExceeded);
      }
      return finalise(new Ctor(LN10), sd, 1, true);
    }


    function getPi(Ctor, sd, rm) {
      if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
      return finalise(new Ctor(PI), sd, rm, true);
    }


    function getPrecision(digits) {
      var w = digits.length - 1,
        len = w * LOG_BASE + 1;

      w = digits[w];

      // If non-zero...
      if (w) {

        // Subtract the number of trailing zeros of the last word.
        for (; w % 10 == 0; w /= 10) len--;

        // Add the number of digits of the first word.
        for (w = digits[0]; w >= 10; w /= 10) len++;
      }

      return len;
    }


    function getZeroString(k) {
      var zs = '';
      for (; k--;) zs += '0';
      return zs;
    }


    /*
     * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
     * integer of type number.
     *
     * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
     *
     */
    function intPow(Ctor, x, n, pr) {
      var isTruncated,
        r = new Ctor(1),

        // Max n of 9007199254740991 takes 53 loop iterations.
        // Maximum digits array length; leaves [28, 34] guard digits.
        k = Math.ceil(pr / LOG_BASE + 4);

      external = false;

      for (;;) {
        if (n % 2) {
          r = r.times(x);
          if (truncate(r.d, k)) isTruncated = true;
        }

        n = mathfloor(n / 2);
        if (n === 0) {

          // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
          n = r.d.length - 1;
          if (isTruncated && r.d[n] === 0) ++r.d[n];
          break;
        }

        x = x.times(x);
        truncate(x.d, k);
      }

      external = true;

      return r;
    }


    function isOdd(n) {
      return n.d[n.d.length - 1] & 1;
    }


    /*
     * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
     */
    function maxOrMin(Ctor, args, ltgt) {
      var y,
        x = new Ctor(args[0]),
        i = 0;

      for (; ++i < args.length;) {
        y = new Ctor(args[i]);
        if (!y.s) {
          x = y;
          break;
        } else if (x[ltgt](y)) {
          x = y;
        }
      }

      return x;
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
     * digits.
     *
     * Taylor/Maclaurin series.
     *
     * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
     *
     * Argument reduction:
     *   Repeat x = x / 32, k += 5, until |x| < 0.1
     *   exp(x) = exp(x / 2^k)^(2^k)
     *
     * Previously, the argument was initially reduced by
     * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
     * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
     * found to be slower than just dividing repeatedly by 32 as above.
     *
     * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
     * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
     * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
     *
     *  exp(Infinity)  = Infinity
     *  exp(-Infinity) = 0
     *  exp(NaN)       = NaN
     *  exp(Â±0)        = 1
     *
     *  exp(x) is non-terminating for any finite, non-zero x.
     *
     *  The result will always be correctly rounded.
     *
     */
    function naturalExponential(x, sd) {
      var denominator, guard, j, pow, sum, t, wpr,
        rep = 0,
        i = 0,
        k = 0,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // 0/NaN/Infinity?
      if (!x.d || !x.d[0] || x.e > 17) {

        return new Ctor(x.d
          ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
          : x.s ? x.s < 0 ? 0 : x : 0 / 0);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      t = new Ctor(0.03125);

      // while abs(x) >= 0.1
      while (x.e > -2) {

        // x = x / 2^5
        x = x.times(t);
        k += 5;
      }

      // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
      // necessary to ensure the first 4 rounding digits are correct.
      guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
      wpr += guard;
      denominator = pow = sum = new Ctor(1);
      Ctor.precision = wpr;

      for (;;) {
        pow = finalise(pow.times(x), wpr, 1);
        denominator = denominator.times(++i);
        t = sum.plus(divide(pow, denominator, wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          j = k;
          while (j--) sum = finalise(sum.times(sum), wpr, 1);

          // Check to see if the first 4 rounding digits are [49]999.
          // If so, repeat the summation with a higher precision, otherwise
          // e.g. with precision: 18, rounding: 1
          // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {

            if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += 10;
              denominator = pow = t = new Ctor(1);
              i = 0;
              rep++;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
      }
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
     * digits.
     *
     *  ln(-n)        = NaN
     *  ln(0)         = -Infinity
     *  ln(-0)        = -Infinity
     *  ln(1)         = 0
     *  ln(Infinity)  = Infinity
     *  ln(-Infinity) = NaN
     *  ln(NaN)       = NaN
     *
     *  ln(n) (n != 1) is non-terminating.
     *
     */
    function naturalLogarithm(y, sd) {
      var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
        n = 1,
        guard = 10,
        x = y,
        xd = x.d,
        Ctor = x.constructor,
        rm = Ctor.rounding,
        pr = Ctor.precision;

      // Is x negative or Infinity, NaN, 0 or 1?
      if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
        return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
      }

      if (sd == null) {
        external = false;
        wpr = pr;
      } else {
        wpr = sd;
      }

      Ctor.precision = wpr += guard;
      c = digitsToString(xd);
      c0 = c.charAt(0);

      if (Math.abs(e = x.e) < 1.5e15) {

        // Argument reduction.
        // The series converges faster the closer the argument is to 1, so using
        // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
        // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
        // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
        // later be divided by this number, then separate out the power of 10 using
        // ln(a*10^b) = ln(a) + b*ln(10).

        // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
        //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
        // max n is 6 (gives 0.7 - 1.3)
        while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
          x = x.times(y);
          c = digitsToString(x.d);
          c0 = c.charAt(0);
          n++;
        }

        e = x.e;

        if (c0 > 1) {
          x = new Ctor('0.' + c);
          e++;
        } else {
          x = new Ctor(c0 + '.' + c.slice(1));
        }
      } else {

        // The argument reduction method above may result in overflow if the argument y is a massive
        // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
        // function using ln(x*10^e) = ln(x) + e*ln(10).
        t = getLn10(Ctor, wpr + 2, pr).times(e + '');
        x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
        Ctor.precision = pr;

        return sd == null ? finalise(x, pr, rm, external = true) : x;
      }

      // x1 is x reduced to a value near 1.
      x1 = x;

      // Taylor series.
      // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
      // where x = (y - 1)/(y + 1)    (|x| < 1)
      sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
      x2 = finalise(x.times(x), wpr, 1);
      denominator = 3;

      for (;;) {
        numerator = finalise(numerator.times(x2), wpr, 1);
        t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

        if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
          sum = sum.times(2);

          // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
          // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
          if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
          sum = divide(sum, new Ctor(n), wpr, 1);

          // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
          // been repeated previously) and the first 4 rounding digits 9999?
          // If so, restart the summation with a higher precision, otherwise
          // e.g. with precision: 12, rounding: 1
          // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
          // `wpr - guard` is the index of first rounding digit.
          if (sd == null) {
            if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
              Ctor.precision = wpr += guard;
              t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
              x2 = finalise(x.times(x), wpr, 1);
              denominator = rep = 1;
            } else {
              return finalise(sum, Ctor.precision = pr, rm, external = true);
            }
          } else {
            Ctor.precision = pr;
            return sum;
          }
        }

        sum = t;
        denominator += 2;
      }
    }


    // Â±Infinity, NaN.
    function nonFiniteToString(x) {
      // Unsigned.
      return String(x.s * x.s / 0);
    }


    /*
     * Parse the value of a new Decimal `x` from string `str`.
     */
    function parseDecimal(x, str) {
      var e, i, len;

      // Decimal point?
      if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

      // Exponential form?
      if ((i = str.search(/e/i)) > 0) {

        // Determine exponent.
        if (e < 0) e = i;
        e += +str.slice(i + 1);
        str = str.substring(0, i);
      } else if (e < 0) {

        // Integer.
        e = str.length;
      }

      // Determine leading zeros.
      for (i = 0; str.charCodeAt(i) === 48; i++);

      // Determine trailing zeros.
      for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
      str = str.slice(i, len);

      if (str) {
        len -= i;
        x.e = e = e - i - 1;
        x.d = [];

        // Transform base

        // e is the base 10 exponent.
        // i is where to slice str to get the first word of the digits array.
        i = (e + 1) % LOG_BASE;
        if (e < 0) i += LOG_BASE;

        if (i < len) {
          if (i) x.d.push(+str.slice(0, i));
          for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
          str = str.slice(i);
          i = LOG_BASE - str.length;
        } else {
          i -= len;
        }

        for (; i--;) str += '0';
        x.d.push(+str);

        if (external) {

          // Overflow?
          if (x.e > x.constructor.maxE) {

            // Infinity.
            x.d = null;
            x.e = NaN;

          // Underflow?
          } else if (x.e < x.constructor.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
            // x.constructor.underflow = true;
          } // else x.constructor.underflow = false;
        }
      } else {

        // Zero.
        x.e = 0;
        x.d = [0];
      }

      return x;
    }


    /*
     * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
     */
    function parseOther(x, str) {
      var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

      if (str === 'Infinity' || str === 'NaN') {
        if (!+str) x.s = NaN;
        x.e = NaN;
        x.d = null;
        return x;
      }

      if (isHex.test(str))  {
        base = 16;
        str = str.toLowerCase();
      } else if (isBinary.test(str))  {
        base = 2;
      } else if (isOctal.test(str))  {
        base = 8;
      } else {
        throw Error(invalidArgument + str);
      }

      // Is there a binary exponent part?
      i = str.search(/p/i);

      if (i > 0) {
        p = +str.slice(i + 1);
        str = str.substring(2, i);
      } else {
        str = str.slice(2);
      }

      // Convert `str` as an integer then divide the result by `base` raised to a power such that the
      // fraction part will be restored.
      i = str.indexOf('.');
      isFloat = i >= 0;
      Ctor = x.constructor;

      if (isFloat) {
        str = str.replace('.', '');
        len = str.length;
        i = len - i;

        // log[10](16) = 1.2041... , log[10](88) = 1.9444....
        divisor = intPow(Ctor, new Ctor(base), i, i * 2);
      }

      xd = convertBase(str, base, BASE);
      xe = xd.length - 1;

      // Remove trailing zeros.
      for (i = xe; xd[i] === 0; --i) xd.pop();
      if (i < 0) return new Ctor(x.s * 0);
      x.e = getBase10Exponent(xd, xe);
      x.d = xd;
      external = false;

      // At what precision to perform the division to ensure exact conversion?
      // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
      // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
      // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
      // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
      // Therefore using 4 * the number of digits of str will always be enough.
      if (isFloat) x = divide(x, divisor, len * 4);

      // Multiply by the binary exponent part if present.
      if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
      external = true;

      return x;
    }


    /*
     * sin(x) = x - x^3/3! + x^5/5! - ...
     * |x| < pi/2
     *
     */
    function sine(Ctor, x) {
      var k,
        len = x.d.length;

      if (len < 3) return taylorSeries(Ctor, 2, x, x);

      // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
      // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
      // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x);

      // Reverse argument reduction
      var sin2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sin2_x = x.times(x);
        x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
      }

      return x;
    }


    // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
    function taylorSeries(Ctor, n, x, y, isHyperbolic) {
      var j, t, u, x2,
        pr = Ctor.precision,
        k = Math.ceil(pr / LOG_BASE);

      external = false;
      x2 = x.times(x);
      u = new Ctor(y);

      for (;;) {
        t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
        u = isHyperbolic ? y.plus(t) : y.minus(t);
        y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
        t = u.plus(y);

        if (t.d[k] !== void 0) {
          for (j = k; t.d[j] === u.d[j] && j--;);
          if (j == -1) break;
        }

        j = u;
        u = y;
        y = t;
        t = j;
      }

      external = true;
      t.d.length = k + 1;

      return t;
    }


    // Exponent e must be positive and non-zero.
    function tinyPow(b, e) {
      var n = b;
      while (--e) n *= b;
      return n;
    }


    // Return the absolute value of `x` reduced to less than or equal to half pi.
    function toLessThanHalfPi(Ctor, x) {
      var t,
        isNeg = x.s < 0,
        pi = getPi(Ctor, Ctor.precision, 1),
        halfPi = pi.times(0.5);

      x = x.abs();

      if (x.lte(halfPi)) {
        quadrant = isNeg ? 4 : 1;
        return x;
      }

      t = x.divToInt(pi);

      if (t.isZero()) {
        quadrant = isNeg ? 3 : 2;
      } else {
        x = x.minus(t.times(pi));

        // 0 <= x < pi
        if (x.lte(halfPi)) {
          quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
          return x;
        }

        quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
      }

      return x.minus(pi).abs();
    }


    /*
     * Return the value of Decimal `x` as a string in base `baseOut`.
     *
     * If the optional `sd` argument is present include a binary exponent suffix.
     */
    function toStringBinary(x, baseOut, sd, rm) {
      var base, e, i, k, len, roundUp, str, xd, y,
        Ctor = x.constructor,
        isExp = sd !== void 0;

      if (isExp) {
        checkInt32(sd, 1, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
      } else {
        sd = Ctor.precision;
        rm = Ctor.rounding;
      }

      if (!x.isFinite()) {
        str = nonFiniteToString(x);
      } else {
        str = finiteToString(x);
        i = str.indexOf('.');

        // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
        // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
        // minBinaryExponent = floor(decimalExponent * log[2](10))
        // log[2](10) = 3.321928094887362347870319429489390175864

        if (isExp) {
          base = 2;
          if (baseOut == 16) {
            sd = sd * 4 - 3;
          } else if (baseOut == 8) {
            sd = sd * 3 - 2;
          }
        } else {
          base = baseOut;
        }

        // Convert the number as an integer then divide the result by its base raised to a power such
        // that the fraction part will be restored.

        // Non-integer.
        if (i >= 0) {
          str = str.replace('.', '');
          y = new Ctor(1);
          y.e = str.length - i;
          y.d = convertBase(finiteToString(y), 10, base);
          y.e = y.d.length;
        }

        xd = convertBase(str, 10, base);
        e = len = xd.length;

        // Remove trailing zeros.
        for (; xd[--len] == 0;) xd.pop();

        if (!xd[0]) {
          str = isExp ? '0p+0' : '0';
        } else {
          if (i < 0) {
            e--;
          } else {
            x = new Ctor(x);
            x.d = xd;
            x.e = e;
            x = divide(x, y, sd, rm, 0, base);
            xd = x.d;
            e = x.e;
            roundUp = inexact;
          }

          // The rounding digit, i.e. the digit after the digit that may be rounded up.
          i = xd[sd];
          k = base / 2;
          roundUp = roundUp || xd[sd + 1] !== void 0;

          roundUp = rm < 4
            ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
            : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
              rm === (x.s < 0 ? 8 : 7));

          xd.length = sd;

          if (roundUp) {

            // Rounding up may mean the previous digit has to be rounded up and so on.
            for (; ++xd[--sd] > base - 1;) {
              xd[sd] = 0;
              if (!sd) {
                ++e;
                xd.unshift(1);
              }
            }
          }

          // Determine trailing zeros.
          for (len = xd.length; !xd[len - 1]; --len);

          // E.g. [4, 11, 15] becomes 4bf.
          for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

          // Add binary exponent suffix?
          if (isExp) {
            if (len > 1) {
              if (baseOut == 16 || baseOut == 8) {
                i = baseOut == 16 ? 4 : 3;
                for (--len; len % i; len++) str += '0';
                xd = convertBase(str, base, baseOut);
                for (len = xd.length; !xd[len - 1]; --len);

                // xd[0] will always be be 1
                for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
              } else {
                str = str.charAt(0) + '.' + str.slice(1);
              }
            }

            str =  str + (e < 0 ? 'p' : 'p+') + e;
          } else if (e < 0) {
            for (; ++e;) str = '0' + str;
            str = '0.' + str;
          } else {
            if (++e > len) for (e -= len; e-- ;) str += '0';
            else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
          }
        }

        str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
      }

      return x.s < 0 ? '-' + str : str;
    }


    // Does not strip trailing zeros.
    function truncate(arr, len) {
      if (arr.length > len) {
        arr.length = len;
        return true;
      }
    }


    // Decimal methods


    /*
     *  abs
     *  acos
     *  acosh
     *  add
     *  asin
     *  asinh
     *  atan
     *  atanh
     *  atan2
     *  cbrt
     *  ceil
     *  clone
     *  config
     *  cos
     *  cosh
     *  div
     *  exp
     *  floor
     *  hypot
     *  ln
     *  log
     *  log2
     *  log10
     *  max
     *  min
     *  mod
     *  mul
     *  pow
     *  random
     *  round
     *  set
     *  sign
     *  sin
     *  sinh
     *  sqrt
     *  sub
     *  tan
     *  tanh
     *  trunc
     */


    /*
     * Return a new Decimal whose value is the absolute value of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function abs(x) {
      return new this(x).abs();
    }


    /*
     * Return a new Decimal whose value is the arccosine in radians of `x`.
     *
     * x {number|string|Decimal}
     *
     */
    function acos(x) {
      return new this(x).acos();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function acosh(x) {
      return new this(x).acosh();
    }


    /*
     * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function add(x, y) {
      return new this(x).plus(y);
    }


    /*
     * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function asin(x) {
      return new this(x).asin();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function asinh(x) {
      return new this(x).asinh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function atan(x) {
      return new this(x).atan();
    }


    /*
     * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
     * `precision` significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function atanh(x) {
      return new this(x).atanh();
    }


    /*
     * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
     * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * Domain: [-Infinity, Infinity]
     * Range: [-pi, pi]
     *
     * y {number|string|Decimal} The y-coordinate.
     * x {number|string|Decimal} The x-coordinate.
     *
     * atan2(Â±0, -0)               = Â±pi
     * atan2(Â±0, +0)               = Â±0
     * atan2(Â±0, -x)               = Â±pi for x > 0
     * atan2(Â±0, x)                = Â±0 for x > 0
     * atan2(-y, Â±0)               = -pi/2 for y > 0
     * atan2(y, Â±0)                = pi/2 for y > 0
     * atan2(Â±y, -Infinity)        = Â±pi for finite y > 0
     * atan2(Â±y, +Infinity)        = Â±0 for finite y > 0
     * atan2(Â±Infinity, x)         = Â±pi/2 for finite x
     * atan2(Â±Infinity, -Infinity) = Â±3*pi/4
     * atan2(Â±Infinity, +Infinity) = Â±pi/4
     * atan2(NaN, x) = NaN
     * atan2(y, NaN) = NaN
     *
     */
    function atan2(y, x) {
      y = new this(y);
      x = new this(x);
      var r,
        pr = this.precision,
        rm = this.rounding,
        wpr = pr + 4;

      // Either NaN
      if (!y.s || !x.s) {
        r = new this(NaN);

      // Both Â±Infinity
      } else if (!y.d && !x.d) {
        r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
        r.s = y.s;

      // x is Â±Infinity or y is Â±0
      } else if (!x.d || y.isZero()) {
        r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
        r.s = y.s;

      // y is Â±Infinity or x is Â±0
      } else if (!y.d || x.isZero()) {
        r = getPi(this, wpr, 1).times(0.5);
        r.s = y.s;

      // Both non-zero and finite
      } else if (x.s < 0) {
        this.precision = wpr;
        this.rounding = 1;
        r = this.atan(divide(y, x, wpr, 1));
        x = getPi(this, wpr, 1);
        this.precision = pr;
        this.rounding = rm;
        r = y.s < 0 ? r.minus(x) : r.plus(x);
      } else {
        r = this.atan(divide(y, x, wpr, 1));
      }

      return r;
    }


    /*
     * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function cbrt(x) {
      return new this(x).cbrt();
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
     *
     * x {number|string|Decimal}
     *
     */
    function ceil(x) {
      return finalise(x = new this(x), x.e + 1, 2);
    }


    /*
     * Configure global settings for a Decimal constructor.
     *
     * `obj` is an object with one or more of the following properties,
     *
     *   precision  {number}
     *   rounding   {number}
     *   toExpNeg   {number}
     *   toExpPos   {number}
     *   maxE       {number}
     *   minE       {number}
     *   modulo     {number}
     *   crypto     {boolean|number}
     *   defaults   {true}
     *
     * E.g. Decimal.config({ precision: 20, rounding: 4 })
     *
     */
    function config(obj) {
      if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
      var i, p, v,
        useDefaults = obj.defaults === true,
        ps = [
          'precision', 1, MAX_DIGITS,
          'rounding', 0, 8,
          'toExpNeg', -EXP_LIMIT, 0,
          'toExpPos', 0, EXP_LIMIT,
          'maxE', 0, EXP_LIMIT,
          'minE', -EXP_LIMIT, 0,
          'modulo', 0, 9
        ];

      for (i = 0; i < ps.length; i += 3) {
        if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
          else throw Error(invalidArgument + p + ': ' + v);
        }
      }

      if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (v === true || v === false || v === 0 || v === 1) {
          if (v) {
            if (typeof crypto != 'undefined' && crypto &&
              (crypto.getRandomValues || crypto.randomBytes)) {
              this[p] = true;
            } else {
              throw Error(cryptoUnavailable);
            }
          } else {
            this[p] = false;
          }
        } else {
          throw Error(invalidArgument + p + ': ' + v);
        }
      }

      return this;
    }


    /*
     * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cos(x) {
      return new this(x).cos();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function cosh(x) {
      return new this(x).cosh();
    }


    /*
     * Create and return a Decimal constructor with the same configuration properties as this Decimal
     * constructor.
     *
     */
    function clone(obj) {
      var i, p, ps;

      /*
       * The Decimal constructor and exported function.
       * Return a new Decimal instance.
       *
       * v {number|string|Decimal} A numeric value.
       *
       */
      function Decimal(v) {
        var e, i, t,
          x = this;

        // Decimal called without new.
        if (!(x instanceof Decimal)) return new Decimal(v);

        // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
        // which points to Object.
        x.constructor = Decimal;

        // Duplicate.
        if (v instanceof Decimal) {
          x.s = v.s;

          if (external) {
            if (!v.d || v.e > Decimal.maxE) {

              // Infinity.
              x.e = NaN;
              x.d = null;
            } else if (v.e < Decimal.minE) {

              // Zero.
              x.e = 0;
              x.d = [0];
            } else {
              x.e = v.e;
              x.d = v.d.slice();
            }
          } else {
            x.e = v.e;
            x.d = v.d ? v.d.slice() : v.d;
          }

          return;
        }

        t = typeof v;

        if (t === 'number') {
          if (v === 0) {
            x.s = 1 / v < 0 ? -1 : 1;
            x.e = 0;
            x.d = [0];
            return;
          }

          if (v < 0) {
            v = -v;
            x.s = -1;
          } else {
            x.s = 1;
          }

          // Fast path for small integers.
          if (v === ~~v && v < 1e7) {
            for (e = 0, i = v; i >= 10; i /= 10) e++;

            if (external) {
              if (e > Decimal.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (e < Decimal.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = e;
                x.d = [v];
              }
            } else {
              x.e = e;
              x.d = [v];
            }

            return;

          // Infinity, NaN.
          } else if (v * 0 !== 0) {
            if (!v) x.s = NaN;
            x.e = NaN;
            x.d = null;
            return;
          }

          return parseDecimal(x, v.toString());

        } else if (t !== 'string') {
          throw Error(invalidArgument + v);
        }

        // Minus sign?
        if ((i = v.charCodeAt(0)) === 45) {
          v = v.slice(1);
          x.s = -1;
        } else {
          // Plus sign?
          if (i === 43) v = v.slice(1);
          x.s = 1;
        }

        return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
      }

      Decimal.prototype = P;

      Decimal.ROUND_UP = 0;
      Decimal.ROUND_DOWN = 1;
      Decimal.ROUND_CEIL = 2;
      Decimal.ROUND_FLOOR = 3;
      Decimal.ROUND_HALF_UP = 4;
      Decimal.ROUND_HALF_DOWN = 5;
      Decimal.ROUND_HALF_EVEN = 6;
      Decimal.ROUND_HALF_CEIL = 7;
      Decimal.ROUND_HALF_FLOOR = 8;
      Decimal.EUCLID = 9;

      Decimal.config = Decimal.set = config;
      Decimal.clone = clone;
      Decimal.isDecimal = isDecimalInstance;

      Decimal.abs = abs;
      Decimal.acos = acos;
      Decimal.acosh = acosh;        // ES6
      Decimal.add = add;
      Decimal.asin = asin;
      Decimal.asinh = asinh;        // ES6
      Decimal.atan = atan;
      Decimal.atanh = atanh;        // ES6
      Decimal.atan2 = atan2;
      Decimal.cbrt = cbrt;          // ES6
      Decimal.ceil = ceil;
      Decimal.cos = cos;
      Decimal.cosh = cosh;          // ES6
      Decimal.div = div;
      Decimal.exp = exp;
      Decimal.floor = floor;
      Decimal.hypot = hypot;        // ES6
      Decimal.ln = ln;
      Decimal.log = log;
      Decimal.log10 = log10;        // ES6
      Decimal.log2 = log2;          // ES6
      Decimal.max = max;
      Decimal.min = min;
      Decimal.mod = mod;
      Decimal.mul = mul;
      Decimal.pow = pow;
      Decimal.random = random;
      Decimal.round = round;
      Decimal.sign = sign;          // ES6
      Decimal.sin = sin;
      Decimal.sinh = sinh;          // ES6
      Decimal.sqrt = sqrt;
      Decimal.sub = sub;
      Decimal.tan = tan;
      Decimal.tanh = tanh;          // ES6
      Decimal.trunc = trunc;        // ES6

      if (obj === void 0) obj = {};
      if (obj) {
        if (obj.defaults !== true) {
          ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
          for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
        }
      }

      Decimal.config(obj);

      return Decimal;
    }


    /*
     * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function div(x, y) {
      return new this(x).div(y);
    }


    /*
     * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The power to which to raise the base of the natural log.
     *
     */
    function exp(x) {
      return new this(x).exp();
    }


    /*
     * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
     *
     * x {number|string|Decimal}
     *
     */
    function floor(x) {
      return finalise(x = new this(x), x.e + 1, 3);
    }


    /*
     * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
     * rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
     *
     * arguments {number|string|Decimal}
     *
     */
    function hypot() {
      var i, n,
        t = new this(0);

      external = false;

      for (i = 0; i < arguments.length;) {
        n = new this(arguments[i++]);
        if (!n.d) {
          if (n.s) {
            external = true;
            return new this(1 / 0);
          }
          t = n;
        } else if (t.d) {
          t = t.plus(n.times(n));
        }
      }

      external = true;

      return t.sqrt();
    }


    /*
     * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
     * otherwise return false.
     *
     */
    function isDecimalInstance(obj) {
      return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;
    }


    /*
     * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function ln(x) {
      return new this(x).ln();
    }


    /*
     * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
     * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
     *
     * log[y](x)
     *
     * x {number|string|Decimal} The argument of the logarithm.
     * y {number|string|Decimal} The base of the logarithm.
     *
     */
    function log(x, y) {
      return new this(x).log(y);
    }


    /*
     * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log2(x) {
      return new this(x).log(2);
    }


    /*
     * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function log10(x) {
      return new this(x).log(10);
    }


    /*
     * Return a new Decimal whose value is the maximum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function max() {
      return maxOrMin(this, arguments, 'lt');
    }


    /*
     * Return a new Decimal whose value is the minimum of the arguments.
     *
     * arguments {number|string|Decimal}
     *
     */
    function min() {
      return maxOrMin(this, arguments, 'gt');
    }


    /*
     * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mod(x, y) {
      return new this(x).mod(y);
    }


    /*
     * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function mul(x, y) {
      return new this(x).mul(y);
    }


    /*
     * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} The base.
     * y {number|string|Decimal} The exponent.
     *
     */
    function pow(x, y) {
      return new this(x).pow(y);
    }


    /*
     * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
     * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
     * are produced).
     *
     * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
     *
     */
    function random(sd) {
      var d, e, k, n,
        i = 0,
        r = new this(1),
        rd = [];

      if (sd === void 0) sd = this.precision;
      else checkInt32(sd, 1, MAX_DIGITS);

      k = Math.ceil(sd / LOG_BASE);

      if (!this.crypto) {
        for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

      // Browsers supporting crypto.getRandomValues.
      } else if (crypto.getRandomValues) {
        d = crypto.getRandomValues(new Uint32Array(k));

        for (; i < k;) {
          n = d[i];

          // 0 <= n < 4294967296
          // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
          if (n >= 4.29e9) {
            d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
          } else {

            // 0 <= n <= 4289999999
            // 0 <= (n % 1e7) <= 9999999
            rd[i++] = n % 1e7;
          }
        }

      // Node.js supporting crypto.randomBytes.
      } else if (crypto.randomBytes) {

        // buffer
        d = crypto.randomBytes(k *= 4);

        for (; i < k;) {

          // 0 <= n < 2147483648
          n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

          // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
          if (n >= 2.14e9) {
            crypto.randomBytes(4).copy(d, i);
          } else {

            // 0 <= n <= 2139999999
            // 0 <= (n % 1e7) <= 9999999
            rd.push(n % 1e7);
            i += 4;
          }
        }

        i = k / 4;
      } else {
        throw Error(cryptoUnavailable);
      }

      k = rd[--i];
      sd %= LOG_BASE;

      // Convert trailing digits to zeros according to sd.
      if (k && sd) {
        n = mathpow(10, LOG_BASE - sd);
        rd[i] = (k / n | 0) * n;
      }

      // Remove trailing words which are zero.
      for (; rd[i] === 0; i--) rd.pop();

      // Zero?
      if (i < 0) {
        e = 0;
        rd = [0];
      } else {
        e = -1;

        // Remove leading words which are zero and adjust exponent accordingly.
        for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

        // Count the digits of the first word of rd to determine leading zeros.
        for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

        // Adjust the exponent for leading zeros of the first word of rd.
        if (k < LOG_BASE) e -= LOG_BASE - k;
      }

      r.e = e;
      r.d = rd;

      return r;
    }


    /*
     * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
     *
     * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
     *
     * x {number|string|Decimal}
     *
     */
    function round(x) {
      return finalise(x = new this(x), x.e + 1, this.rounding);
    }


    /*
     * Return
     *   1    if x > 0,
     *  -1    if x < 0,
     *   0    if x is 0,
     *  -0    if x is -0,
     *   NaN  otherwise
     *
     * x {number|string|Decimal}
     *
     */
    function sign(x) {
      x = new this(x);
      return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
    }


    /*
     * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sin(x) {
      return new this(x).sin();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function sinh(x) {
      return new this(x).sinh();
    }


    /*
     * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     *
     */
    function sqrt(x) {
      return new this(x).sqrt();
    }


    /*
     * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
     * using rounding mode `rounding`.
     *
     * x {number|string|Decimal}
     * y {number|string|Decimal}
     *
     */
    function sub(x, y) {
      return new this(x).sub(y);
    }


    /*
     * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
     * digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tan(x) {
      return new this(x).tan();
    }


    /*
     * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
     * significant digits using rounding mode `rounding`.
     *
     * x {number|string|Decimal} A value in radians.
     *
     */
    function tanh(x) {
      return new this(x).tanh();
    }


    /*
     * Return a new Decimal whose value is `x` truncated to an integer.
     *
     * x {number|string|Decimal}
     *
     */
    function trunc(x) {
      return finalise(x = new this(x), x.e + 1, 1);
    }


    // Create and configure initial Decimal constructor.
    Decimal = clone(DEFAULTS);

    Decimal['default'] = Decimal.Decimal = Decimal;

    // Create the internal constants from their string values.
    LN10 = new Decimal(LN10);
    PI = new Decimal(PI);


    // Export.


    // AMD.
    if (module.exports) {
      if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
        P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
        P[Symbol.toStringTag] = 'Decimal';
      }

      module.exports = Decimal;

    // Browser.
    } else {
      if (!globalScope) {
        globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
      }

      noConflict = globalScope.Decimal;
      Decimal.noConflict = function () {
        globalScope.Decimal = noConflict;
        return Decimal;
      };

      globalScope.Decimal = Decimal;
    }
  })(commonjsGlobal);
  }(decimal));

  var complex = {exports: {}};

  /**
   * @license Complex.js v2.0.13 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **/

  (function (module, exports) {
  /**
   *
   * This class allows the manipulation of complex numbers.
   * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
   *
   * Object form
   * { re: <real>, im: <imaginary> }
   * { arg: <angle>, abs: <radius> }
   * { phi: <angle>, r: <radius> }
   *
   * Array / Vector form
   * [ real, imaginary ]
   *
   * Double form
   * 99.3 - Single double value
   *
   * String form
   * '23.1337' - Simple real number
   * '15+3i' - a simple complex number
   * '3-i' - a simple complex number
   *
   * Example:
   *
   * var c = new Complex('99.3+8i');
   * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
   *
   */

  (function(root) {

    var cosh = function(x) {
      return (Math.exp(x) + Math.exp(-x)) * 0.5;
    };

    var sinh = function(x) {
      return (Math.exp(x) - Math.exp(-x)) * 0.5;
    };

    /**
     * Calculates cos(x) - 1 using Taylor series if x is small.
     *
     * @param {number} x
     * @returns {number} cos(x) - 1
     */

    var cosm1 = function(x) {
      var limit = Math.PI/4;
      if (x < -limit || x > limit) {
        return (Math.cos(x) - 1.0);
      }

      var xx = x * x;
      return xx *
        (-0.5 + xx *
          (1/24 + xx *
            (-1/720 + xx *
              (1/40320 + xx *
                (-1/3628800 + xx *
                  (1/4790014600 + xx *
                    (-1/87178291200 + xx *
                      (1/20922789888000)
                    )
                  )
                )
              )
            )
          )
        )
    };

    var hypot = function(x, y) {

      var a = Math.abs(x);
      var b = Math.abs(y);

      if (a < 3000 && b < 3000) {
        return Math.sqrt(a * a + b * b);
      }

      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };

    var parser_exit = function() {
      throw SyntaxError('Invalid Param');
    };

    /**
     * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
     *
     * @param {number} a
     * @param {number} b
     * @returns {number}
     */
    function logHypot(a, b) {

      var _a = Math.abs(a);
      var _b = Math.abs(b);

      if (a === 0) {
        return Math.log(_b);
      }

      if (b === 0) {
        return Math.log(_a);
      }

      if (_a < 3000 && _b < 3000) {
        return Math.log(a * a + b * b) * 0.5;
      }

      /* I got 4 ideas to compute this property without overflow:
       *
       * Testing 1000000 times with random samples for a,b âˆˆ [1, 1000000000] against a big decimal library to get an error estimate
       *
       * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

       Math.log(a * a + b * b) / 2

       *
       *
       * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

       var fn = function(a, b) {
       a = Math.abs(a);
       b = Math.abs(b);
       var t = Math.min(a, b);
       a = Math.max(a, b);
       t = t / a;

       return Math.log(a) + Math.log(1 + t * t) / 2;
       };

       * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

       Math.log(a / Math.cos(Math.atan2(b, a)))

       * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

       Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

       */

      return Math.log(a / Math.cos(Math.atan2(b, a)));
    }

    var parse = function(a, b) {

      var z = {'re': 0, 'im': 0};

      if (a === undefined || a === null) {
        z['re'] =
                z['im'] = 0;
      } else if (b !== undefined) {
        z['re'] = a;
        z['im'] = b;
      } else
        switch (typeof a) {

          case 'object':

            if ('im' in a && 're' in a) {
              z['re'] = a['re'];
              z['im'] = a['im'];
            } else if ('abs' in a && 'arg' in a) {
              if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['abs'] * Math.cos(a['arg']);
              z['im'] = a['abs'] * Math.sin(a['arg']);
            } else if ('r' in a && 'phi' in a) {
              if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
                return Complex['INFINITY'];
              }
              z['re'] = a['r'] * Math.cos(a['phi']);
              z['im'] = a['r'] * Math.sin(a['phi']);
            } else if (a.length === 2) { // Quick array check
              z['re'] = a[0];
              z['im'] = a[1];
            } else {
              parser_exit();
            }
            break;

          case 'string':

            z['im'] = /* void */
                    z['re'] = 0;

            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;

            if (tokens === null) {
              parser_exit();
            }

            for (var i = 0; i < tokens.length; i++) {

              var c = tokens[i];

              if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
                plus++;
              } else if (c === '-') {
                minus++;
              } else if (c === 'i' || c === 'I') {

                if (plus + minus === 0) {
                  parser_exit();
                }

                if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                  i++;
                } else {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
                }
                plus = minus = 0;

              } else {

                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }

                if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                  z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                  i++;
                } else {
                  z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
                }
                plus = minus = 0;
              }
            }

            // Still something on the stack
            if (plus + minus > 0) {
              parser_exit();
            }
            break;

          case 'number':
            z['im'] = 0;
            z['re'] = a;
            break;

          default:
            parser_exit();
        }

      if (isNaN(z['re']) || isNaN(z['im'])) ;

      return z;
    };

    /**
     * @constructor
     * @returns {Complex}
     */
    function Complex(a, b) {

      if (!(this instanceof Complex)) {
        return new Complex(a, b);
      }

      var z = parse(a, b);

      this['re'] = z['re'];
      this['im'] = z['im'];
    }

    Complex.prototype = {

      're': 0,
      'im': 0,

      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      'sign': function() {

        var abs = this['abs']();

        return new Complex(
                this['re'] / abs,
                this['im'] / abs);
      },

      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      'add': function(a, b) {

        var z = new Complex(a, b);

        // Infinity + Infinity = NaN
        if (this['isInfinite']() && z['isInfinite']()) {
          return Complex['NAN'];
        }

        // Infinity + z = Infinity { where z != Infinity }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        return new Complex(
                this['re'] + z['re'],
                this['im'] + z['im']);
      },

      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      'sub': function(a, b) {

        var z = new Complex(a, b);

        // Infinity - Infinity = NaN
        if (this['isInfinite']() && z['isInfinite']()) {
          return Complex['NAN'];
        }

        // Infinity - z = Infinity { where z != Infinity }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        return new Complex(
                this['re'] - z['re'],
                this['im'] - z['im']);
      },

      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      'mul': function(a, b) {

        var z = new Complex(a, b);

        // Infinity * 0 = NaN
        if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
          return Complex['NAN'];
        }

        // Infinity * z = Infinity { where z != 0 }
        if (this['isInfinite']() || z['isInfinite']()) {
          return Complex['INFINITY'];
        }

        // Short circuit for real values
        if (z['im'] === 0 && this['im'] === 0) {
          return new Complex(this['re'] * z['re'], 0);
        }

        return new Complex(
                this['re'] * z['re'] - this['im'] * z['im'],
                this['re'] * z['im'] + this['im'] * z['re']);
      },

      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      'div': function(a, b) {

        var z = new Complex(a, b);

        // 0 / 0 = NaN and Infinity / Infinity = NaN
        if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
          return Complex['NAN'];
        }

        // Infinity / 0 = Infinity
        if (this['isInfinite']() || z['isZero']()) {
          return Complex['INFINITY'];
        }

        // 0 / Infinity = 0
        if (this['isZero']() || z['isInfinite']()) {
          return Complex['ZERO'];
        }

        a = this['re'];
        b = this['im'];

        var c = z['re'];
        var d = z['im'];
        var t, x;

        if (0 === d) {
          // Divisor is real
          return new Complex(a / c, b / c);
        }

        if (Math.abs(c) < Math.abs(d)) {

          x = c / d;
          t = c * x + d;

          return new Complex(
                  (a * x + b) / t,
                  (b * x - a) / t);

        } else {

          x = d / c;
          t = d * x + c;

          return new Complex(
                  (a + b * x) / t,
                  (b - a * x) / t);
        }
      },

      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      'pow': function(a, b) {

        var z = new Complex(a, b);

        a = this['re'];
        b = this['im'];

        if (z['isZero']()) {
          return Complex['ONE'];
        }

        // If the exponent is real
        if (z['im'] === 0) {

          if (b === 0 && a > 0) {

            return new Complex(Math.pow(a, z['re']), 0);

          } else if (a === 0) { // If base is fully imaginary

            switch ((z['re'] % 4 + 4) % 4) {
              case 0:
                return new Complex(Math.pow(b, z['re']), 0);
              case 1:
                return new Complex(0, Math.pow(b, z['re']));
              case 2:
                return new Complex(-Math.pow(b, z['re']), 0);
              case 3:
                return new Complex(0, -Math.pow(b, z['re']));
            }
          }
        }

        /* I couldn't find a good formula, so here is a derivation and optimization
         *
         * z_1^z_2 = (a + bi)^(c + di)
         *         = exp((c + di) * log(a + bi)
         *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
         * =>...
         * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
         * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
         *
         * =>...
         * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
         * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
         *
         * =>
         * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
         * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
         *
         */

        if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
          return Complex['ZERO'];
        }

        var arg = Math.atan2(b, a);
        var loh = logHypot(a, b);

        a = Math.exp(z['re'] * loh - z['im'] * arg);
        b = z['im'] * loh + z['re'] * arg;
        return new Complex(
                a * Math.cos(b),
                a * Math.sin(b));
      },

      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      'sqrt': function() {

        var a = this['re'];
        var b = this['im'];
        var r = this['abs']();

        var re, im;

        if (a >= 0) {

          if (b === 0) {
            return new Complex(Math.sqrt(a), 0);
          }

          re = 0.5 * Math.sqrt(2.0 * (r + a));
        } else {
          re = Math.abs(b) / Math.sqrt(2 * (r - a));
        }

        if (a <= 0) {
          im = 0.5 * Math.sqrt(2.0 * (r - a));
        } else {
          im = Math.abs(b) / Math.sqrt(2 * (r + a));
        }

        return new Complex(re, b < 0 ? -im : im);
      },

      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      'exp': function() {

        var tmp = Math.exp(this['re']);

        if (this['im'] === 0) ;
        return new Complex(
                tmp * Math.cos(this['im']),
                tmp * Math.sin(this['im']));
      },

      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      'expm1': function() {

        /**
         * exp(a + i*b) - 1
         = exp(a) * (cos(b) + j*sin(b)) - 1
         = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
         */

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.expm1(a) * Math.cos(b) + cosm1(b),
                Math.exp(a) * Math.sin(b));
      },

      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      'log': function() {

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                logHypot(a, b),
                Math.atan2(b, a));
      },

      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      'abs': function() {

        return hypot(this['re'], this['im']);
      },

      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      'arg': function() {

        return Math.atan2(this['im'], this['re']);
      },

      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      'sin': function() {

        // sin(c) = (e^b - e^(-b)) / (2i)

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.sin(a) * cosh(b),
                Math.cos(a) * sinh(b));
      },

      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      'cos': function() {

        // cos(z) = (e^b + e^(-b)) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                Math.cos(a) * cosh(b),
                -Math.sin(a) * sinh(b));
      },

      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      'tan': function() {

        // tan(c) = (e^(ci) - e^(-ci)) / (i(e^(ci) + e^(-ci)))

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = Math.cos(a) + cosh(b);

        return new Complex(
                Math.sin(a) / d,
                sinh(b) / d);
      },

      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      'cot': function() {

        // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = Math.cos(a) - cosh(b);

        return new Complex(
                -Math.sin(a) / d,
                sinh(b) / d);
      },

      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      'sec': function() {

        // sec(c) = 2 / (e^(ci) + e^(-ci))

        var a = this['re'];
        var b = this['im'];
        var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

        return new Complex(
                Math.cos(a) * cosh(b) / d,
                Math.sin(a) * sinh(b) / d);
      },

      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      'csc': function() {

        // csc(c) = 2i / (e^(ci) - e^(-ci))

        var a = this['re'];
        var b = this['im'];
        var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

        return new Complex(
                Math.sin(a) * cosh(b) / d,
                -Math.cos(a) * sinh(b) / d);
      },

      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      'asin': function() {

        // asin(c) = -i * log(ci + sqrt(1 - c^2))

        var a = this['re'];
        var b = this['im'];

        var t1 = new Complex(
                b * b - a * a + 1,
                -2 * a * b)['sqrt']();

        var t2 = new Complex(
                t1['re'] - b,
                t1['im'] + a)['log']();

        return new Complex(t2['im'], -t2['re']);
      },

      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      'acos': function() {

        // acos(c) = i * log(c - i * sqrt(1 - c^2))

        var a = this['re'];
        var b = this['im'];

        var t1 = new Complex(
                b * b - a * a + 1,
                -2 * a * b)['sqrt']();

        var t2 = new Complex(
                t1['re'] - b,
                t1['im'] + a)['log']();

        return new Complex(Math.PI / 2 - t2['im'], t2['re']);
      },

      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      'atan': function() {

        // atan(c) = i / 2 log((i + x) / (i - x))

        var a = this['re'];
        var b = this['im'];

        if (a === 0) {

          if (b === 1) {
            return new Complex(0, Infinity);
          }

          if (b === -1) {
            return new Complex(0, -Infinity);
          }
        }

        var d = a * a + (1.0 - b) * (1.0 - b);

        var t1 = new Complex(
                (1 - b * b - a * a) / d,
                -2 * a / d).log();

        return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
      },

      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      'acot': function() {

        // acot(c) = i / 2 log((c - i) / (c + i))

        var a = this['re'];
        var b = this['im'];

        if (b === 0) {
          return new Complex(Math.atan2(1, a), 0);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).atan()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).atan();
      },

      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      'asec': function() {

        // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(0, Infinity);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).acos()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).acos();
      },

      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      'acsc': function() {

        // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(Math.PI / 2, Infinity);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).asin()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).asin();
      },

      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      'sinh': function() {

        // sinh(c) = (e^c - e^-c) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                sinh(a) * Math.cos(b),
                cosh(a) * Math.sin(b));
      },

      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      'cosh': function() {

        // cosh(c) = (e^c + e^-c) / 2

        var a = this['re'];
        var b = this['im'];

        return new Complex(
                cosh(a) * Math.cos(b),
                sinh(a) * Math.sin(b));
      },

      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      'tanh': function() {

        // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = cosh(a) + Math.cos(b);

        return new Complex(
                sinh(a) / d,
                Math.sin(b) / d);
      },

      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      'coth': function() {

        // coth(c) = (e^c + e^-c) / (e^c - e^-c)

        var a = 2 * this['re'];
        var b = 2 * this['im'];
        var d = cosh(a) - Math.cos(b);

        return new Complex(
                sinh(a) / d,
                -Math.sin(b) / d);
      },

      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      'csch': function() {

        // csch(c) = 2 / (e^c - e^-c)

        var a = this['re'];
        var b = this['im'];
        var d = Math.cos(2 * b) - cosh(2 * a);

        return new Complex(
                -2 * sinh(a) * Math.cos(b) / d,
                2 * cosh(a) * Math.sin(b) / d);
      },

      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      'sech': function() {

        // sech(c) = 2 / (e^c + e^-c)

        var a = this['re'];
        var b = this['im'];
        var d = Math.cos(2 * b) + cosh(2 * a);

        return new Complex(
                2 * cosh(a) * Math.cos(b) / d,
                -2 * sinh(a) * Math.sin(b) / d);
      },

      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      'asinh': function() {

        // asinh(c) = log(c + sqrt(c^2 + 1))

        var tmp = this['im'];
        this['im'] = -this['re'];
        this['re'] = tmp;
        var res = this['asin']();

        this['re'] = -this['im'];
        this['im'] = tmp;
        tmp = res['re'];

        res['re'] = -res['im'];
        res['im'] = tmp;
        return res;
      },

      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      'acosh': function() {

        // acosh(c) = log(c + sqrt(c^2 - 1))

        var res = this['acos']();
        if (res['im'] <= 0) {
          var tmp = res['re'];
          res['re'] = -res['im'];
          res['im'] = tmp;
        } else {
          var tmp = res['im'];
          res['im'] = -res['re'];
          res['re'] = tmp;
        }
        return res;
      },

      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      'atanh': function() {

        // atanh(c) = log((1+c) / (1-c)) / 2

        var a = this['re'];
        var b = this['im'];

        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;

        var x = (d !== 0)
                ? new Complex(
                        (onePlus * oneMinus - b * b) / d,
                        (b * oneMinus + onePlus * b) / d)
                : new Complex(
                        (a !== -1) ? (a / 0) : 0,
                        (b !== 0) ? (b / 0) : 0);

        var temp = x['re'];
        x['re'] = logHypot(x['re'], x['im']) / 2;
        x['im'] = Math.atan2(x['im'], temp) / 2;
        if (noIM) {
          x['im'] = -x['im'];
        }
        return x;
      },

      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      'acoth': function() {

        // acoth(c) = log((c+1) / (c-1)) / 2

        var a = this['re'];
        var b = this['im'];

        if (a === 0 && b === 0) {
          return new Complex(0, Math.PI / 2);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).atanh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).atanh();
      },

      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      'acsch': function() {

        // acsch(c) = log((1+sqrt(1+c^2))/c)

        var a = this['re'];
        var b = this['im'];

        if (b === 0) {

          return new Complex(
                  (a !== 0)
                  ? Math.log(a + Math.sqrt(a * a + 1))
                  : Infinity, 0);
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).asinh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).asinh();
      },

      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      'asech': function() {

        // asech(c) = log((1+sqrt(1-c^2))/c)

        var a = this['re'];
        var b = this['im'];

        if (this['isZero']()) {
          return Complex['INFINITY'];
        }

        var d = a * a + b * b;
        return (d !== 0)
                ? new Complex(
                        a / d,
                        -b / d).acosh()
                : new Complex(
                        (a !== 0) ? a / 0 : 0,
                        (b !== 0) ? -b / 0 : 0).acosh();
      },

      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      'inverse': function() {

        // 1 / 0 = Infinity and 1 / Infinity = 0
        if (this['isZero']()) {
          return Complex['INFINITY'];
        }

        if (this['isInfinite']()) {
          return Complex['ZERO'];
        }

        var a = this['re'];
        var b = this['im'];

        var d = a * a + b * b;

        return new Complex(a / d, -b / d);
      },

      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      'conjugate': function() {

        return new Complex(this['re'], -this['im']);
      },

      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      'neg': function() {

        return new Complex(-this['re'], -this['im']);
      },

      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      'ceil': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.ceil(this['re'] * places) / places,
                Math.ceil(this['im'] * places) / places);
      },

      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      'floor': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.floor(this['re'] * places) / places,
                Math.floor(this['im'] * places) / places);
      },

      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      'round': function(places) {

        places = Math.pow(10, places || 0);

        return new Complex(
                Math.round(this['re'] * places) / places,
                Math.round(this['im'] * places) / places);
      },

      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      'equals': function(a, b) {

        var z = new Complex(a, b);

        return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
                Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
      },

      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      'clone': function() {

        return new Complex(this['re'], this['im']);
      },

      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      'toString': function() {

        var a = this['re'];
        var b = this['im'];
        var ret = "";

        if (this['isNaN']()) {
          return 'NaN';
        }

        if (this['isInfinite']()) {
          return 'Infinity';
        }

        if (Math.abs(a) < Complex['EPSILON']) {
          a = 0;
        }

        if (Math.abs(b) < Complex['EPSILON']) {
          b = 0;
        }

        // If is real number
        if (b === 0) {
          return ret + a;
        }

        if (a !== 0) {
          ret+= a;
          ret+= " ";
          if (b < 0) {
            b = -b;
            ret+= "-";
          } else {
            ret+= "+";
          }
          ret+= " ";
        } else if (b < 0) {
          b = -b;
          ret+= "-";
        }

        if (1 !== b) { // b is the absolute imaginary part
          ret+= b;
        }
        return ret + "i";
      },

      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      'toVector': function() {

        return [this['re'], this['im']];
      },

      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      'valueOf': function() {

        if (this['im'] === 0) {
          return this['re'];
        }
        return null;
      },

      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      'isNaN': function() {
        return isNaN(this['re']) || isNaN(this['im']);
      },

      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isZero': function() {
        return this['im'] === 0 && this['re'] === 0;
      },

      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isFinite': function() {
        return isFinite(this['re']) && isFinite(this['im']);
      },

      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      'isInfinite': function() {
        return !(this['isNaN']() || this['isFinite']());
      }
    };

    Complex['ZERO'] = new Complex(0, 0);
    Complex['ONE'] = new Complex(1, 0);
    Complex['I'] = new Complex(0, 1);
    Complex['PI'] = new Complex(Math.PI, 0);
    Complex['E'] = new Complex(Math.E, 0);
    Complex['INFINITY'] = new Complex(Infinity, Infinity);
    Complex['NAN'] = new Complex(NaN, NaN);
    Complex['EPSILON'] = 1e-15;

    {
      Object.defineProperty(Complex, "__esModule", {'value': true});
      Complex['default'] = Complex;
      Complex['Complex'] = Complex;
      module['exports'] = Complex;
    }

  })();
  }(complex));

  const DECIMAL_ZERO = new decimal.exports.Decimal(0);
  const DECIMAL_ONE = new decimal.exports.Decimal(1);
  const DECIMAL_MINUS_ONE = new decimal.exports.Decimal(-1);
  const DECIMAL_NAN = new decimal.exports.Decimal(NaN);
  const DECIMAL_POS_INFINITY = new decimal.exports.Decimal(+Infinity);
  const DECIMAL_NEG_INFINITY = new decimal.exports.Decimal(-Infinity);
  function factorial$1(n) {
      if (typeof n === 'number')
          n = new decimal.exports.Decimal(n);
      if (!n.isInteger() || n.isNegative())
          return DECIMAL_NAN;
      if (n.lessThan(10)) {
          return new decimal.exports.Decimal([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800][n.toNumber()]);
      }
      if (n.gt(Number.MAX_SAFE_INTEGER)) {
          let val = DECIMAL_ONE;
          let i = new decimal.exports.Decimal(2);
          while (i.lessThan(n)) {
              val = val.mul(i);
              i = i.add(1);
          }
          return val;
      }
      if (n.modulo(2).eq(1)) {
          return n.times(factorial$1(n.minus(1)));
      }
      let loop = n.toNumber();
      let sum = n.toNumber();
      let val = n;
      while (loop > 2) {
          loop -= 2;
          sum += loop;
          val = val.mul(sum);
      }
      return val;
  }
  const gammaG$1 = 7;
  const p$1 = [
      0.99999999999980993, 676.5203681218851, -1259.1392167224028,
      771.32342877765313, -176.61502916214059, 12.507343278686905,
      -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
  ].map((x) => new decimal.exports.Decimal(x));
  const gammaGLn$1 = new decimal.exports.Decimal(607).div(128);
  const gammaPLn$1 = [
      0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
      14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
      0.46523628927048575665e-4, -0.98374475304879564677e-4,
      0.15808870322491248884e-3, -0.21026444172410488319e-3,
      0.2174396181152126432e-3, -0.16431810653676389022e-3,
      0.84418223983852743293e-4, -0.2619083840158140867e-4,
      0.36899182659531622704e-5,
  ].map((x) => new decimal.exports.Decimal(x));
  // Spouge approximation (suitable for large arguments)
  function lngamma$1(z) {
      if (typeof z === 'number')
          z = new decimal.exports.Decimal(z);
      if (z.isNegative())
          return DECIMAL_NAN;
      let x = gammaPLn$1[0];
      for (let i = gammaPLn$1.length - 1; i > 0; --i) {
          x = x.add(gammaPLn$1[i].div(z.add(i)));
      }
      const t = z.add(gammaGLn$1).add(0.5);
      return decimal.exports.Decimal.acos(-1)
          .mul(2)
          .log()
          .mul(0.5)
          .add(t.log().mul(z.add(0.5)).minus(t).add(x.log()).minus(z.log()));
  }
  // From https://github.com/substack/gamma.js/blob/master/index.js
  function gamma$2(z) {
      if (typeof z === 'number')
          z = new decimal.exports.Decimal(z);
      if (z.lessThan(0.5)) {
          const pi = decimal.exports.Decimal.acos(-1);
          return pi.div(pi
              .mul(z)
              .sin()
              .mul(gamma$2(decimal.exports.Decimal.sub(1, z))));
      }
      else if (z.greaterThan(100)) {
          return lngamma$1(z).exp();
      }
      else {
          z = z.sub(1);
          let x = p$1[0];
          for (let i = 1; i < gammaG$1 + 2; i++) {
              x = x.add(p$1[i].div(z.add(i)));
          }
          const t = z.add(gammaG$1).add(0.5);
          return decimal.exports.Decimal.acos(-1)
              .times(2)
              .sqrt()
              .mul(x.mul(t.neg().exp()).mul(decimal.exports.Decimal.pow(t, z.add(0.5))));
      }
  }

  const MACHINE_PRECISION_BITS = 53;
  const MACHINE_PRECISION = Math.log10(Math.pow(2, MACHINE_PRECISION_BITS)); // â‰ˆ 15.95 = number of digits of precision
  // Positive values smaller than NUMERICAL_TOLERANCE are considered to be zero
  const NUMERICAL_TOLERANCE = Math.pow(10, -10);
  // prettier-ignore
  const SMALL_PRIMES = new Set([
      2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71,
      73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151,
      157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233,
      239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317,
      331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419,
      421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503,
      509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607,
      613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701,
      709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811,
      821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911,
      919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019,
      1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097,
      1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201,
      1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291,
      1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409,
      1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487,
      1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579,
      1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667,
      1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777,
      1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877,
      1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993,
      1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083,
      2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179,
      2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287,
      2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381,
      2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473,
      2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609,
      2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693,
      2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789,
      2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887,
      2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001,
      3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119,
      3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229,
      3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331,
      3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457,
      3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541,
      3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637,
      3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739,
      3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853,
      3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947,
      3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073,
      4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177,
      4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273,
      4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409,
      4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517,
      4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639,
      4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733,
      4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871,
      4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969,
      4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077,
      5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189,
      5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309,
      5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431,
      5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521,
      5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651,
      5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743,
      5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851,
      5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981,
      5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091,
      6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211,
      6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311,
      6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397,
      6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553,
      6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673,
      6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781,
      6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883,
      6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991,
      6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121,
      7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237,
      7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369,
      7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507,
      7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589,
      7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699,
      7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829,
      7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919,
  ]);
  const LARGEST_SMALL_PRIME = 7919;
  function gcd(a, b) {
      //https://github.com/Yaffle/bigint-gcd/blob/main/gcd.js
      if (!Number.isInteger(a) || !Number.isInteger(b))
          return NaN;
      while (b !== 0)
          [a, b] = [b, a % b];
      return a < 0 ? -a : a;
  }
  function factorial(n) {
      if (!Number.isInteger(n) || n < 0)
          return NaN;
      let val = 1;
      for (let i = 2; i <= n; i++)
          val = val * i;
      return val;
  }
  const gammaG = 7;
  const p = [
      0.99999999999980993, 676.5203681218851, -1259.1392167224028,
      771.32342877765313, -176.61502916214059, 12.507343278686905,
      -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
  ];
  const gammaGLn = 607 / 128;
  const gammaPLn = [
      0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
      14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
      0.46523628927048575665e-4, -0.98374475304879564677e-4,
      0.15808870322491248884e-3, -0.21026444172410488319e-3,
      0.2174396181152126432e-3, -0.16431810653676389022e-3,
      0.84418223983852743293e-4, -0.2619083840158140867e-4,
      0.36899182659531622704e-5,
  ];
  // Spouge approximation (suitable for large arguments)
  function lngamma(z) {
      if (z < 0)
          return NaN;
      let x = gammaPLn[0];
      for (let i = gammaPLn.length - 1; i > 0; --i)
          x += gammaPLn[i] / (z + i);
      const t = z + gammaGLn + 0.5;
      return (0.5 * Math.log(2 * Math.PI) +
          (z + 0.5) * Math.log(t) -
          t +
          Math.log(x) -
          Math.log(z));
  }
  // From https://github.com/substack/gamma.js/blob/master/index.js
  function gamma$1(z) {
      if (z < 0.5) {
          return Math.PI / (Math.sin(Math.PI * z) * gamma$1(1 - z));
      }
      else if (z > 100) {
          return Math.exp(lngamma(z));
      }
      else {
          z -= 1;
          let x = p[0];
          for (let i = 1; i < gammaG + 2; i++) {
              x += p[i] / (z + i);
          }
          const t = z + gammaG + 0.5;
          return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
      }
  }

  /**
   * These constants are the 'primitive' functions and constants that are used
   * for some basic manipulations such as parsing, and transforming to canonical
   * form.
   *
   */
  const PARENTHESES = 'Parentheses';
  const IDENTITY = 'Identity';
  const LATEX_TOKENS = 'LatexTokens';
  const LIST = 'List';
  const MISSING = 'Missing';
  const NOTHING = 'Nothing';
  const SEQUENCE = 'Sequence';
  const SEQUENCE2 = 'Sequence2';
  const ADD = 'Add';
  const DERIVATIVE = 'Derivative';
  const DIVIDE = 'Divide';
  const EXP = 'Exp';
  const INVERSE_FUNCTION = 'InverseFunction';
  const MULTIPLY = 'Multiply';
  const NEGATE = 'Negate';
  const POWER = 'Power';
  const PRIME = 'Prime';
  const ROOT = 'Root';
  const SQRT = 'Sqrt';
  const SUBTRACT = 'Subtract';
  const COMPLEX_INFINITY = 'ComplexInfinity';
  const PI = 'Pi';
  const EXPONENTIAL_E = 'ExponentialE';
  const IMAGINARY_UNIT = 'ImaginaryUnit';
  function isNumberObject(expr) {
      return expr !== null && typeof expr === 'object' && 'num' in expr;
  }
  function isSymbolObject(expr) {
      return expr !== null && typeof expr === 'object' && 'sym' in expr;
  }
  function isStringObject(expr) {
      return expr !== null && typeof expr === 'object' && 'str' in expr;
  }
  function isFunctionObject(expr) {
      return expr !== null && typeof expr === 'object' && 'fn' in expr;
  }
  function isDictionaryObject(expr) {
      return expr !== null && typeof expr === 'object' && 'dict' in expr;
  }
  function getNumberValue(expr) {
      if (typeof expr === 'number')
          return expr;
      if (expr === null)
          return null;
      if (isNumberObject(expr)) {
          if (expr.num.endsWith('d') || expr.num.endsWith('n'))
              return null;
          return parseFloat(expr.num);
      }
      const symbol = getSymbolName(expr);
      if (symbol === null)
          return null;
      if (symbol === 'NaN')
          return NaN;
      if (symbol === '+Infinity')
          return Infinity;
      if (symbol === '-Infinity')
          return -Infinity;
      if (getFunctionName(expr) === 'Complex') {
          if (getNumberValue(getArg(expr, 2)) === 0) {
              return getNumberValue(getArg(expr, 1));
          }
      }
      return null;
  }
  /** Only return non-null if the expression is a Complex number.
   * Return null if it's a number, or a symbol (other than  `ImaginaryUnit` or
   * `ComplexInfinity`)
   *
   */
  function getComplexValue(expr) {
      if (expr === null)
          return null;
      if (expr instanceof complex.exports.Complex)
          return expr;
      const symbol = getSymbolName(expr);
      if (symbol !== null) {
          if (symbol === 'ComplexInfinity')
              return complex.exports.Complex.INFINITY;
          if (symbol === IMAGINARY_UNIT)
              return complex.exports.Complex.I;
      }
      const name = getFunctionName(expr);
      if (name === 'Complex') {
          const re1 = getNumberValue(getArg(expr, 1));
          const im1 = getNumberValue(getArg(expr, 2));
          if (re1 === null || im1 === null)
              return null;
          return new complex.exports.Complex(re1, im1);
      }
      let im = getImaginaryValue(expr);
      if (im !== null)
          return new complex.exports.Complex(0, im);
      if (name === 'Add' && getArgCount(expr) === 2) {
          let re = getNumberValue(getArg(expr, 1));
          if (re !== null) {
              im = getImaginaryValue(getArg(expr, 2));
          }
          else {
              im = getImaginaryValue(getArg(expr, 1));
              if (im !== null) {
                  re = getNumberValue(getArg(expr, 2));
              }
          }
          if (re !== null && im !== null)
              return new complex.exports.Complex(re, im);
      }
      if (name === 'Subtract') {
          const re = getNumberValue(getArg(expr, 1));
          const arg2 = getArg(expr, 2);
          if (re !== null) {
              if (getSymbolName(arg2) === IMAGINARY_UNIT) {
                  return new complex.exports.Complex(re, -1);
              }
              if (getFunctionName(arg2) === 'Multiply' &&
                  getArg(arg2, 2) === IMAGINARY_UNIT) {
                  const im = getNumberValue(getArg(arg2, 1));
                  if (im !== null)
                      return new complex.exports.Complex(re, -im);
              }
          }
      }
      if (name === 'Multiply' && getArgCount(expr) === 2) {
          let factor = null;
          if (getSymbolName(getArg(expr, 2)) === IMAGINARY_UNIT) {
              factor = getNumberValue(getArg(expr, 2));
          }
          else if (getSymbolName(getArg(expr, 1)) === IMAGINARY_UNIT) {
              factor = getNumberValue(getArg(expr, 1));
          }
          if (factor !== null && Number.isInteger(factor)) {
              if (factor === 0)
                  return complex.exports.Complex.ZERO;
              if (factor === 1)
                  return complex.exports.Complex.ONE;
              if (factor === -1)
                  return complex.exports.Complex.ONE.neg();
              return new complex.exports.Complex(0, factor);
          }
      }
      if (name === 'Negate') {
          const c = getComplexValue(getArg(expr, 1));
          if (c !== null)
              return c.neg();
      }
      return null;
  }
  /**
   * Return a multiple of the imaginary unit, e.g.
   * - 'ImaginaryUnit'
   * - ['Negate', 'ImaginaryUnit']
   * - ['Multiply', 5, 'ImaginaryUnit']
   * - ['Multiply', 'ImaginaryUnit', 5]
   */
  function getImaginaryValue(expr) {
      if (getSymbolName(expr) === 'ImaginaryUnit')
          return 1;
      let val = null;
      const name = getFunctionName(expr);
      if (name === 'Multiply' && getArgCount(expr) === 2) {
          if (getSymbolName(getArg(expr, 1)) === 'ImaginaryUnit') {
              val = getNumberValue(getArg(expr, 2));
          }
          else if (getSymbolName(getArg(expr, 2)) === 'ImaginaryUnit') {
              val = getNumberValue(getArg(expr, 1));
          }
      }
      else if (name === 'Negate' && getArgCount(expr) === 1) {
          if (getSymbolName(getArg(expr, 1)) === 'ImaginaryUnit') {
              val = -1;
          }
      }
      return val === 0 ? null : val;
  }
  function getDecimalValue(expr) {
      var _a, _b;
      if (expr instanceof decimal.exports.Decimal)
          return expr;
      const symbol = getSymbolName(expr);
      if (symbol !== null) {
          if (symbol === 'NaN')
              return DECIMAL_NAN;
          if (symbol === '+Infinity')
              return DECIMAL_POS_INFINITY;
          if (symbol === '-Infinity')
              return DECIMAL_NEG_INFINITY;
      }
      if (isNumberObject(expr)) {
          if (expr.num.endsWith('d') || expr.num.endsWith('n')) {
              return new decimal.exports.Decimal(expr.num.slice(0, -1));
          }
          return new decimal.exports.Decimal((_a = getNumberValue(expr)) !== null && _a !== void 0 ? _a : NaN);
      }
      if (expr !== null && expr instanceof complex.exports.Complex) {
          const c = expr;
          if (c.im === 0)
              return new decimal.exports.Decimal(c.re);
          return null;
      }
      if (getFunctionName(expr) === 'Complex') {
          if (getNumberValue(getArg(expr, 2)) === 0) {
              return new decimal.exports.Decimal((_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : NaN);
          }
      }
      return null;
  }
  /**  If expr is a string literal, return it.
   *
   * A string literal is a JSON string that begins and ends with
   * **U+0027 APOSTROPHE** : **`'`** or an object literal with a `str` key.
   */
  function getStringValue(expr) {
      if (expr === null)
          return null;
      if (typeof expr === 'object' && 'str' in expr)
          return expr.str;
      if (typeof expr !== 'string')
          return null;
      if (expr.length < 2)
          return null;
      if (expr[0] !== "'" || expr[expr.length - 1] !== "'")
          return null;
      return expr.substring(1, expr.length - 1);
  }
  /**
   * Return a rational (numer over denom) representation of the expression,
   * if possible, `[null, null]` otherwise.
   *
   * The expression can be:
   * - Some symbols: "ThreeQuarte", "Half"...
   * - ["Power", d, -1]
   * - ["Power", n, 1]
   * - ["Divide", n, d]
   *
   * The denominator is always > 0.
   */
  function getRationalValue(expr) {
      var _a, _b, _c, _d, _e, _f;
      const symbol = getSymbolName(expr);
      if (symbol === 'ThreeQuarter')
          return [3, 4];
      if (symbol === 'TwoThird')
          return [2, 3];
      if (symbol === 'Half')
          return [1, 2];
      if (symbol === 'Third')
          return [1, 3];
      if (symbol === 'Quarter')
          return [1, 4];
      if (isAtomic(expr))
          return [null, null];
      const head = getFunctionName(expr);
      if (!head)
          return [null, null];
      let numer = null;
      let denom = null;
      if (head === POWER) {
          const exponent = getNumberValue(getArg(expr, 2));
          if (exponent === 1) {
              numer = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : null;
              denom = 1;
          }
          else if (exponent === -1) {
              numer = 1;
              denom = (_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : null;
          }
      }
      if (head === DIVIDE) {
          numer = (_c = getNumberValue(getArg(expr, 1))) !== null && _c !== void 0 ? _c : null;
          denom = (_d = getNumberValue(getArg(expr, 2))) !== null && _d !== void 0 ? _d : null;
      }
      if (head === MULTIPLY &&
          getFunctionName(getArg(expr, 2)) === POWER &&
          getNumberValue(getArg(getArg(expr, 2), 2)) === -1) {
          numer = (_e = getNumberValue(getArg(expr, 1))) !== null && _e !== void 0 ? _e : null;
          denom = (_f = getNumberValue(getArg(getArg(expr, 2), 1))) !== null && _f !== void 0 ? _f : null;
      }
      if (numer === null || denom === null)
          return [null, null];
      if (Number.isInteger(numer) && Number.isInteger(denom)) {
          return [numer, denom];
      }
      return [null, null];
  }
  /**
   *  Reduce the numerator and denominator:
   * `\frac{2}{4} -> \frac{1}{2})`
   */
  function simplifyRational([numer, denom]) {
      if (numer === null || denom === null)
          return [null, null];
      const g = gcd(numer, denom);
      if (denom < 0)
          return [-numer / g, -denom / g];
      return [numer / g, denom / g];
  }
  /**
   * Return the numerator and denominator of a product with the specified symbol.
   * For example:
   * `3Ï€` -> [3, 1]
   * `3Ï€/2` -> [3, 2]
   * `1/2 * Ï€` -> [1, 2]
   */
  function getRationalSymbolicValue(expr, symbol) {
      var _a, _b, _c, _d;
      if (getSymbolName(expr) === symbol)
          return [1, 1];
      const head = getFunctionName(expr);
      if (head === MULTIPLY) {
          // p/q * symbol
          if (getSymbolName((_a = getArg(expr, 2)) !== null && _a !== void 0 ? _a : MISSING) !== symbol) {
              return [null, null];
          }
          const arg1 = getArg(expr, 1);
          const val = getNumberValue(arg1);
          if (val !== null)
              return [val, 1];
          return getRationalValue(arg1 !== null && arg1 !== void 0 ? arg1 : MISSING);
      }
      else if (head === DIVIDE) {
          const denom = getNumberValue((_b = getArg(expr, 2)) !== null && _b !== void 0 ? _b : MISSING);
          if (denom === null || isNaN(denom))
              return [null, null];
          const arg1 = (_c = getArg(expr, 1)) !== null && _c !== void 0 ? _c : MISSING;
          const sym1 = getSymbolName(arg1);
          if (sym1 === symbol)
              return [1, denom];
          let numer = null;
          if (sym1 === 'MinusDoublePi') {
              numer = -2;
          }
          else if (sym1 === 'MinusPi') {
              numer = -1;
          }
          else if (sym1 === 'DoublePi') {
              numer = 2;
          }
          else {
              if (getFunctionName(arg1) !== MULTIPLY)
                  return [null, null];
              if (getSymbolName(getArg(arg1, 2)) !== symbol)
                  return [null, null];
              numer = getNumberValue(getArg(arg1, 1));
          }
          if (numer === null)
              return [null, null];
          return [numer, denom];
      }
      else if (head === NEGATE) {
          const [numer, denom] = getRationalSymbolicValue((_d = getArg(expr, 1)) !== null && _d !== void 0 ? _d : MISSING, symbol);
          if (numer === null || isNaN(numer))
              return [null, null];
          return [-numer, denom];
      }
      return [null, null];
  }
  /** True if the expression is of the form \frac{n}{m} where n and m are both integers
   *
   * Note this detects fewer patterns than `getRationalValue()`, but it is
   * intended to detect rational numbers used with invisible plus, i.e. `1\frac{1}{2}`
   *
   */
  function isRationalNumber(expr) {
      var _a, _b;
      const symbol = getSymbolName(expr);
      if (symbol !== null &&
          ['ThreeQuarter', 'TwoThird', 'Half', 'Third', 'Quarter'].includes(symbol)) {
          return true;
      }
      if (getFunctionName(expr) !== DIVIDE)
          return false;
      const numer = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : NaN;
      const denom = (_b = getNumberValue(getArg(expr, 2))) !== null && _b !== void 0 ? _b : NaN;
      return Number.isInteger(numer) && Number.isInteger(denom);
  }
  /**
   * Return the head of any expression, including symbols and numbers.
   *
   */
  function getHead(expr) {
      if (Array.isArray(expr))
          return expr[0];
      if (isFunctionObject(expr))
          return expr.fn[0];
      if (typeof expr === 'number' || isNumberObject(expr)) {
          return 'Number';
      }
      if (typeof expr === 'string')
          return 'String';
      if (isSymbolObject(expr))
          return 'Symbol';
      if (isDictionaryObject(expr))
          return 'Dictionary';
      return null;
  }
  /**
   * The head of a function can be a string or an expression.
   *
   * Return `null` if the expression is not a function.
   *
   * Examples:
   * * `["Negate", 5]`  -> `"Negate"`
   * * `[["Prime", "f"], "x"]` -> `["Prime", "f"]`
   */
  function getFunctionHead(expr) {
      if (expr === null)
          return null;
      if (Array.isArray(expr))
          return expr[0];
      if (isFunctionObject(expr))
          return expr.fn[0];
      return null;
  }
  /**
   * True if the expression is a number, a symbol or a string
   * (i.e. not a function and not a dictionary)
   */
  function isAtomic(expr) {
      return (expr === null ||
          (!Array.isArray(expr) &&
              (typeof expr !== 'object' || !('fn' in expr || 'dic' in expr))));
  }
  function getFunctionName(expr) {
      if (expr === null)
          return '';
      const head = getFunctionHead(expr);
      if (typeof head === 'string')
          return head;
      return '';
  }
  function getSymbolName(expr) {
      if (expr === null)
          return null;
      if (typeof expr === 'string') {
          if (expr.length >= 2 && expr[0] === "'" && expr[expr.length - 1] === "'") {
              // It's a string literal, not a symbol
              return null;
          }
          return expr;
      }
      if (isSymbolObject(expr))
          return expr.sym;
      return null;
  }
  /**
   * Return all the elements but the first one, i.e. the arguments of a
   * function.
   */
  function getTail(expr) {
      if (Array.isArray(expr)) {
          return expr.slice(1);
      }
      if (isFunctionObject(expr)) {
          return expr.fn.slice(1);
      }
      return [];
  }
  function applyRecursively(expr, fn) {
      const head = getFunctionHead(expr);
      if (head !== null) {
          return [fn(head), ...getTail(expr).map(fn)];
      }
      const dict = getDictionary(expr);
      if (dict !== null) {
          const keys = Object.keys(dict);
          const result = {};
          for (const key of keys)
              result[key] = fn(dict[key]);
          return { dict: result };
      }
      return fn(expr);
  }
  /**
   * Apply a function to the arguments of a function and return an array of T
   */
  function mapArgs(expr, fn) {
      let args = null;
      if (Array.isArray(expr))
          args = expr;
      if (isFunctionObject(expr))
          args = expr.fn;
      if (args === null)
          return [];
      let i = 1;
      const result = [];
      while (i < args.length) {
          result.push(fn(args[i]));
          i += 1;
      }
      return result;
  }
  function getArg(expr, n) {
      var _a, _b;
      if (expr === null)
          return null;
      if (Array.isArray(expr))
          return (_a = expr[n]) !== null && _a !== void 0 ? _a : null;
      if (isFunctionObject(expr))
          return (_b = expr.fn[n]) !== null && _b !== void 0 ? _b : null;
      return null;
  }
  function getArgCount(expr) {
      if (Array.isArray(expr)) {
          return Math.max(0, expr.length - 1);
      }
      if (isFunctionObject(expr)) {
          return Math.max(0, expr.fn.length - 1);
      }
      return 0;
  }
  function getDictionary(expr) {
      if (typeof expr === 'object' && 'dict' in expr)
          return expr.dict;
      return null;
  }
  /**
   * Structurally compare two expressions, ignoring metadata.
   *
   * Compare with `match()` which ignores differences in representation.
   *
   * @revisit: is this really needed? Or just use `match()`?
   */
  function equalExpr(lhs, rhs) {
      if (typeof lhs !== typeof rhs)
          return false;
      if (lhs === null)
          return rhs === null;
      if (lhs === undefined)
          return rhs === undefined;
      if (typeof lhs === 'number')
          return lhs === rhs;
      if (typeof lhs === 'string')
          return lhs === rhs;
      if (Array.isArray(lhs) && Array.isArray(rhs)) {
          if (!equalExpr(getHead(lhs), getHead(rhs)))
              return false;
          // Compare the arguments
          const count = getArgCount(lhs);
          if (getArgCount(rhs) !== count)
              return false;
          for (let i = 0; i < count; i++) {
              if (!equalExpr(getArg(lhs, i), getArg(rhs, i)))
                  return false;
          }
          return true;
      }
      if (typeof lhs === 'object') {
          if (isNumberObject(lhs) && isNumberObject(rhs)) {
              return getNumberValue(lhs) === getNumberValue(rhs);
          }
          if (isSymbolObject(lhs) && isSymbolObject(rhs)) {
              return getSymbolName(lhs) === getSymbolName(rhs);
          }
          if (isFunctionObject(lhs) && isFunctionObject(rhs)) {
              if (!equalExpr(getHead(lhs), getHead(rhs)))
                  return false;
              // Compare the arguments
              const count = getArgCount(lhs);
              if (getArgCount(rhs) !== count)
                  return false;
              for (let i = 0; i < count; i++) {
                  if (!equalExpr(getArg(lhs, i), getArg(rhs, i)))
                      return false;
              }
              return true;
          }
          if (isStringObject(lhs) && isStringObject(rhs)) {
              return getStringValue(lhs) === getStringValue(rhs);
          }
          if (isDictionaryObject(lhs) && isDictionaryObject(rhs)) {
              const lhsDic = getDictionary(lhs);
              const rhsDic = getDictionary(rhs);
              if (lhsDic === null && rhsDic !== null)
                  return false;
              if (lhsDic === null && rhsDic === null)
                  return true;
              const keys = Object.keys(lhsDic);
              if (rhsDic === null || keys.length !== Object.keys(rhsDic).length) {
                  return false;
              }
              for (const key of keys) {
                  if (!equalExpr(lhsDic[key], rhsDic[key]))
                      return false;
              }
              return true;
          }
      }
      return false;
  }

  const DEFINITIONS_OTHERS = [
      {
          name: 'Overscript',
          trigger: { infix: '\\overset' },
          precedence: 700, // @todo: not in MathML
      },
      {
          name: 'Underscript',
          trigger: { infix: '\\underset' },
          precedence: 700, // @todo: not in MathML
      },
      {
          name: 'Increment',
          trigger: { postfix: ['+', '+'] },
          precedence: 880,
      },
      {
          name: 'Decrement',
          trigger: { postfix: ['-', '-'] },
          precedence: 880,
      },
      {
          name: 'PreIncrement',
          trigger: { prefix: ['+', '+'] },
          precedence: 880,
      },
      {
          name: 'PreDecrement',
          trigger: { prefix: ['-', '-'] },
          precedence: 880,
      },
      {
          name: 'Ring',
          trigger: { infix: '\\circ' },
          precedence: 265,
      },
      {
          // @todo: if lhs is a list/tensor
          name: 'Transpose',
          trigger: { superfix: 'T' },
      },
      {
          // @todo: if lhs is a list/tensor
          name: 'ConjugateTranspose',
          trigger: { superfix: 'H' },
      },
      {
          name: 'StringJoin',
          trigger: { infix: ['\\lt', '\\gt'] },
          precedence: 780,
      },
      {
          name: 'Starstar',
          trigger: { infix: ['\\star', '\\star'] },
          precedence: 780,
      },
      {
          // Partial derivative using a variation of the Euler notation: `âˆ‚_xf(x)`
          // (the Euler notation uses `D_1f(x)` where "1" is for the first variable
          // For the Leibniz notation see 'Divide' that handles `âˆ‚f/âˆ‚x`
          name: 'PartialDerivative',
          trigger: { prefix: '\\partial' },
          parse: (lhs, scanner, _minPrec) => {
              var _a, _b;
              let done = false;
              let sup = NOTHING;
              let sub = NOTHING;
              while (!done) {
                  scanner.skipSpace();
                  if (scanner.match('_')) {
                      sub = scanner.matchRequiredLatexArgument();
                  }
                  else if (scanner.match('^')) {
                      sup = scanner.matchRequiredLatexArgument();
                  }
                  else {
                      done = true;
                  }
              }
              if (getFunctionName(sub) === SEQUENCE) {
                  sub = [LIST, ...getTail(sub)];
              }
              if (!sub || !sup)
                  return [lhs, null];
              let rhs = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : NOTHING;
              if (rhs !== NOTHING) {
                  const arg = (_b = scanner.matchArguments('group')) !== null && _b !== void 0 ? _b : NOTHING;
                  rhs = [rhs, ...arg];
              }
              return [null, ['PartialDerivative', rhs, sub, sup]];
          },
          serialize: (serializer, expr) => {
              let result = '\\partial';
              const fn = getArg(expr, 1);
              const vars = getArg(expr, 2);
              const degree = getArg(expr, 3);
              if (vars !== null && vars !== NOTHING) {
                  if (getFunctionHead(vars) === LIST) {
                      result +=
                          '_{' + serializer.serialize([SEQUENCE, ...getTail(vars)]) + '}';
                  }
                  else {
                      result += '_{' + serializer.serialize(vars) + '}';
                  }
              }
              if (degree !== null && degree !== NOTHING) {
                  result += '^{' + serializer.serialize(degree) + '}';
              }
              if (fn !== null && fn !== NOTHING) {
                  result += serializer.serialize(fn);
              }
              return result;
          },
          precedence: 740,
      },
      {
          name: 'OverBar',
          trigger: { symbol: '\\overline' },
          requiredLatexArg: 1,
      },
      {
          name: 'UnderBar',
          trigger: { symbol: '\\underline' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverVector',
          trigger: { symbol: '\\vec' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverTile',
          trigger: { symbol: '\\tilde' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverHat',
          trigger: { symbol: '\\hat' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverHat',
          trigger: { symbol: '\\hat' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverRightArrow',
          trigger: { symbol: '\\overrightarrow' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverLeftArrow',
          trigger: { symbol: '\\overleftarrow' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverRightDoubleArrow',
          trigger: { symbol: '\\Overrightarrow' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverLeftHarpoon',
          trigger: { symbol: '\\overleftharpoon' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverRightHarpoon',
          trigger: { symbol: '\\overrightharpoon' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverLeftRightArrow',
          trigger: { symbol: '\\overleftrightarrow' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverBrace',
          trigger: { symbol: '\\overbrace' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverLineSegment',
          trigger: { symbol: '\\overlinesegment' },
          requiredLatexArg: 1,
      },
      {
          name: 'OverGroup',
          trigger: { symbol: '\\overgroup' },
          requiredLatexArg: 1,
      },
      // {
      //     name: '',
      //     trigger: { symbol: '\\mathring' },
      //     requiredLatexArg: 1,
      // },
      // {
      //     name: '',
      //     trigger: { symbol: '\\check' },
      //     requiredLatexArg: 1,
      // },
  ];
  // https://reference.wolfram.com/language/tutorial/TextualInputAndOutput.html

  function getApplyFunctionStyle(_expr, _level) {
      return 'paren';
  }
  function getGroupStyle(_expr, _level) {
      return 'paren';
  }
  function getRootStyle(_expr, level) {
      if (level > 2)
          return 'solidus';
      return 'radical';
  }
  function getFractionStyle(_expr, level) {
      if (level > 3)
          return 'inline-solidus';
      return 'quotient';
  }

  function isSpacingToken(token) {
      return (token === '<space>' ||
          token === '\\qquad' ||
          token === '\\quad' ||
          token === '\\enskip' ||
          token === '\\;' ||
          token === '\\,' ||
          token === '\\ ' ||
          token === '~');
  }
  /**
   * Parse a sequence of expressions separated with ',' or ';'.
   * - ',' indicate a simple sequence
   * - ';' indicate a sequence of sequences
   */
  function parseSequence(head, prec, sep) {
      return (lhs, scanner, minPrec) => {
          if (minPrec >= prec)
              return [lhs, null];
          scanner.skipSpace();
          scanner.match(sep);
          if (lhs === 'Missing')
              lhs = NOTHING;
          const result = [head, lhs !== null && lhs !== void 0 ? lhs : NOTHING];
          let done = false;
          while (!done) {
              done = true;
              scanner.skipSpace();
              while (scanner.match(sep)) {
                  result.push(NOTHING);
                  scanner.skipSpace();
              }
              if (scanner.atEnd) {
                  result.push(NOTHING);
              }
              else {
                  const rhs = scanner.matchExpression(prec);
                  result.push(rhs !== null && rhs !== void 0 ? rhs : NOTHING);
                  done = rhs === null;
              }
              if (!done) {
                  scanner.skipSpace();
                  done = !scanner.match(sep);
              }
          }
          return [null, result];
      };
  }
  function serializeSequence(sep) {
      return (serializer, expr) => {
          return getTail(expr)
              .map((x) => serializer.serialize(x))
              .join(sep);
      };
  }
  function serializeLatex(serializer, expr) {
      console.assert(getFunctionHead(expr) === LATEX_TOKENS);
      // @todo: add onError handler to serialize()
      return getTail(expr)
          .map((x) => {
          const stringValue = getStringValue(x);
          // If not a string, serialize the expression to Latex
          if (stringValue === null)
              return serializer.serialize(x);
          if (stringValue === '<{>')
              return '{';
          if (stringValue === '<}>')
              return '}';
          if (stringValue === '<$>')
              return '$';
          if (stringValue === '<$$>')
              return '$$';
          if (stringValue === "<space>'")
              return ' ';
          return stringValue;
      })
          .join('');
  }
  const DEFINITIONS_CORE = [
      { name: LATEX_TOKENS, serialize: serializeLatex },
      {
          name: PARENTHESES,
          trigger: { matchfix: '(' },
          parse: (lhs, scanner, _minPrec) => {
              var _a;
              const originalIndex = scanner.index;
              if (!scanner.match('('))
                  return [lhs, null];
              //
              // 1. Attempt to scan a base-n number
              // i.e. `(deadbeef)_{16}`
              //
              let done = false;
              let couldBeBaseNumber = true;
              let wrappedInMathTt = false;
              let maxDigit = 0;
              let digits = '';
              while (!done && couldBeBaseNumber) {
                  const token = scanner.next();
                  if (scanner.atEnd || token === ')') {
                      done = true;
                  }
                  else if (token === '\\mathtt') {
                      scanner.match('<{>');
                      wrappedInMathTt = true;
                  }
                  else if (isSpacingToken(token)) ;
                  else if (!/^[0-9a-zA-Z]$/.test(token)) {
                      couldBeBaseNumber = false;
                  }
                  else {
                      maxDigit = Math.max(maxDigit, parseInt(token, 36));
                      digits += token;
                  }
                  if (wrappedInMathTt) {
                      scanner.match('<}>');
                  }
              }
              scanner.skipSpace();
              if (couldBeBaseNumber && scanner.match('_')) {
                  const radix = (_a = getNumberValue(scanner.matchRequiredLatexArgument())) !== null && _a !== void 0 ? _a : NaN;
                  if (!isFinite(radix) || radix < 2 || radix > 36 || maxDigit >= radix) {
                      scanner.onError({ code: 'base-out-of-range' });
                      return [lhs, NOTHING];
                  }
                  return [lhs, ['BaseForm', parseInt(digits, radix), radix]];
              }
              //
              // 2. It wasn't a number in a base. Scan a sequence
              //
              scanner.index = originalIndex;
              const seq = scanner.matchBalancedExpression('(', ')', scanner.onError);
              // If it's a simple sequence, 'upgrade it' to a group
              if (!seq)
                  return [lhs, [PARENTHESES]];
              if (getFunctionName(seq) === SEQUENCE) {
                  return [lhs, [PARENTHESES, ...getTail(seq)]];
              }
              return [lhs, [PARENTHESES, seq]];
          },
          serialize: (serializer, expr) => serializer.wrapString(serializeSequence(',')(serializer, expr), getGroupStyle(expr, serializer.level)),
          separator: ',',
          closeFence: ')',
          precedence: 20,
      },
      {
          name: LIST,
          trigger: { matchfix: '\\lbrack' },
          separator: ',',
          closeFence: '\\rbrack',
          precedence: 20,
          parse: (lhs, scanner, _minPrec) => {
              if (lhs === null) {
                  // No lhs -> it's a list
                  const seq = scanner.matchBalancedExpression('\\lbrack', '\\rbrack', scanner.onError);
                  if (!seq)
                      return [null, [LIST]];
                  if (getFunctionName(seq) === SEQUENCE) {
                      return [lhs, [LIST, ...getTail(seq)]];
                  }
                  return [lhs, [LIST, seq]];
              }
              return [lhs, null];
              // There is a lhs -> it might be an index accessor, i.e. `v[23]` @todo
          },
      },
      {
          name: 'BaseForm',
          serialize: (serializer, expr) => {
              var _a, _b;
              const radix = (_a = getNumberValue(getArg(expr, 2))) !== null && _a !== void 0 ? _a : NaN;
              if (isFinite(radix) && radix >= 2 && radix <= 36) {
                  const num = (_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : NaN;
                  if (isFinite(num)) {
                      let digits = Number(num).toString(radix);
                      let groupLength = 0;
                      if (radix === 2) {
                          groupLength = 4;
                      }
                      else if (radix === 10) {
                          groupLength = 4;
                      }
                      else if (radix === 16) {
                          groupLength = 2;
                      }
                      else if (radix > 16) {
                          groupLength = 4;
                      }
                      if (groupLength > 0) {
                          const oldDigits = digits;
                          digits = '';
                          for (let i = 0; i < oldDigits.length; i++) {
                              if (i > 0 && i % groupLength === 0) {
                                  digits = '\\, ' + digits;
                              }
                              digits = oldDigits[oldDigits.length - i - 1] + digits;
                          }
                      }
                      return `(\\mathtt{${digits}})_{${radix}}`;
                  }
              }
              return ('\\operatorname{BaseForm}(' +
                  serializer.serialize(getArg(expr, 1)) +
                  ', ' +
                  serializer.serialize(getArg(expr, 2)) +
                  ')');
          },
      },
      {
          name: 'Set',
          trigger: { matchfix: '\\lbrace' },
          separator: ',',
          closeFence: '\\rbrace',
          precedence: 20,
      },
      {
          name: SEQUENCE,
          trigger: { infix: ',' },
          // Unlike the matchfix version of List,
          // when the comma operator is used, the lhs and rhs are flattened,
          // i.e. `1,2,3` -> `["Sequence", 1, 2, 3],
          // but `1, (2, 3)` -> ["Sequence", 1, ["Parentheses", 2, 3]]`
          parse: parseSequence(SEQUENCE, 20, ','),
          serialize: serializeSequence(', '),
          precedence: 20,
      },
      {
          name: SEQUENCE2,
          trigger: { infix: ';' },
          parse: parseSequence(SEQUENCE2, 19, ';'),
          serialize: serializeSequence('; '),
          precedence: 19,
      },
      {
          name: MISSING,
          trigger: '\\placeholder',
          serialize: '\\placeholder',
          requiredLatexArg: 1,
      },
      {
          name: 'Subscript',
          trigger: { infix: '_' },
          precedence: 720,
          serialize: (serializer, expr) => {
              if (getArgCount(expr) === 2) {
                  return (serializer.serialize(getArg(expr, 1)) +
                      '_{' +
                      serializer.serialize(getArg(expr, 2)) +
                      '}');
              }
              return '_{' + serializer.serialize(getArg(expr, 1)) + '}';
          },
          parse: (lhs, scanner, _minPrec) => {
              var _a;
              if (!scanner.match('_'))
                  return [lhs, null];
              const rhs = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : MISSING;
              if (!lhs)
                  return [null, ['Subscript', rhs]];
              return [null, ['Subscript', lhs, rhs]];
          },
      },
      {
          name: 'Superplus',
          trigger: { superfix: '+' },
      },
      {
          name: 'Subplus',
          trigger: { subfix: '+' },
      },
      {
          name: 'Superminus',
          trigger: { superfix: '-' },
      },
      {
          name: 'Subminus',
          trigger: { subfix: '-' },
      },
      {
          // @todo: when lhs is a complex number, 'Conjugate'
          name: 'Superstar',
          trigger: { superfix: '*' },
      },
      {
          // @todo: when lhs is a complex number, 'Conjugate'
          name: 'Superstar',
          trigger: { superfix: '\\star' },
      },
      {
          name: 'Substar',
          trigger: { subfix: '*' },
      },
      {
          name: 'Substar',
          trigger: { subfix: '\\star' },
      },
      {
          name: 'Superdagger',
          trigger: { superfix: '\\dagger' },
      },
      {
          name: 'Superdagger',
          trigger: { superfix: '\\dag' },
      },
      {
          name: PRIME,
          trigger: { superfix: '\\prime' },
          arguments: 'group',
      },
      {
          // name: 'prime',
          trigger: { superfix: '\\doubleprime' },
          parse: (lhs, _scanner) => {
              return [null, [PRIME, lhs !== null && lhs !== void 0 ? lhs : NOTHING, 2]];
          },
          arguments: 'group',
      },
      {
          name: INVERSE_FUNCTION,
          serialize: (serializer, expr) => {
              return serializer.serialize(getArg(expr, 1)) + '^{-1}';
          },
      },
      {
          name: DERIVATIVE,
          trigger: 'D',
          parse: (lhs, _scanner) => {
              return [lhs, [DERIVATIVE, 1]];
          },
          serialize: (serializer, expr) => {
              var _a;
              const degree = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : NaN;
              if (!isFinite(degree))
                  return '';
              const base = serializer.serialize(getArg(expr, 2));
              if (degree === 1) {
                  return base + '^{\\prime}';
              }
              else if (degree === 2) {
                  return base + '^{\\doubleprime}';
              }
              return base + '^{(' + Number(degree).toString() + ')}';
          },
      },
      {
          name: 'Piecewise',
          trigger: { environment: 'cases' },
          parse: (lhs, scanner) => {
              var _a;
              return [lhs, ['Piecewise', (_a = scanner.matchTabular()) !== null && _a !== void 0 ? _a : NOTHING]];
          },
          serialize: (serialize, expr) => {
              if (getFunctionName(getArg(expr, 1)) !== LIST)
                  return '';
              const rows = getTail(getArg(expr, 1));
              let body = '';
              let rowSep = '';
              for (const row of rows) {
                  body += rowSep;
                  const arg1 = getArg(row, 1);
                  if (arg1 !== null) {
                      body += serialize.serialize(arg1);
                      const arg2 = getArg(row, 2);
                      if (arg2 !== null)
                          body += '&' + serialize.serialize(arg2);
                  }
                  rowSep = '\\\\';
              }
              return '\\begin{cases}' + body + '\\end{cases}';
          },
      },
  ];

  function isInteger(ce, expr) {
      // @todo
      const val = getNumberValue(expr);
      if (val === null)
          return false;
      return Number.isInteger(val);
  }
  function isNumeric(_ce, _expr) {
      // @todo
      return false;
  }
  function isZero(ce, expr) {
      const val = getNumberValue(expr);
      if (val !== null)
          return val === 0;
      if (ce.is(['Equal', expr, 0]))
          return true;
      // @todo matchAssumptions() equal not zero.
      if (ce.is(['NotEqual', expr, 0]) === true)
          return false;
      if (ce.is(['Greater', expr, 0]) === true)
          return false;
      if (ce.is(['Less', expr, 0]) === true)
          return false;
      // @todo
      // const match = engine.matchAssumptions(['Greater', expr, '_val']);
      // if (match.some((x) => x._val > 0)) return true;
      // If this is not a number, and there are no assumptions
      // about it, we can't tell if it's zero or not.
      if (val === null)
          return undefined;
      // It was a number, but not 0
      return false;
  }
  function isNotZero(engine, expr) {
      const result = isZero(engine, expr);
      return result === undefined ? undefined : !result;
  }
  function isInfinity(ce, expr) {
      if (expr === null)
          return undefined;
      const val = getNumberValue(expr);
      if (val !== null && !Number.isFinite(val))
          return true;
      if (val !== null && isNaN(val))
          return undefined;
      const symbol = getSymbolName(expr);
      if (symbol === COMPLEX_INFINITY)
          return true;
      if (symbol === MISSING || symbol === NOTHING)
          return false;
      if (ce.is(expr, 'ComplexNumber'))
          return false;
      const name = getFunctionName(expr);
      if (name === 'Negate') {
          if (isInfinity(ce, getArg(expr, 1)))
              return true;
      }
      else if (name === 'Multiply') {
          const args = getTail(expr);
          if (args.some((x) => isInfinity(ce, x) === true)) {
              if (args.every((x) => isNotZero(ce, x) === true)) {
                  return true;
              }
          }
      }
      return val === null ? undefined : false;
  }
  // @todo
  function isFinite$1(_ce, _expr) {
      return undefined;
  }
  function isPositive(ce, expr) {
      if (expr === null)
          return undefined;
      const val = getNumberValue(expr);
      if (val !== null)
          return val > 0;
      const symbol = getSymbolName(expr);
      if (symbol &&
          [
              'Quarter',
              'Third',
              'Half',
              'TwoThird',
              'ThreeQuarter',
              'MinusDoublePi',
              'MinusPi',
              'QuarterPi',
              'ThirdPi',
              'HalfPi',
              'TwoThirdPi',
              'ThreeQuarterPi',
              'Pi',
              'DoublePi',
              'MachineEpsilon',
              'CatalanConstant',
              'GoldenRatio',
              'EulerGamma',
              'ExponentialE',
          ].includes(symbol)) {
          return true;
      }
      if (ce.is(['Greater', expr, 0]))
          return true;
      if (ce.is(['LessEqual', expr, 0]))
          return false;
      if (ce.is(['Less', expr, 0]))
          return false;
      const name = getFunctionName(expr);
      if (name) {
          if (name === 'Cosh' || name === 'Exp') {
              if (isReal(ce, getArg(expr, 1)))
                  return true;
          }
          if (name === 'Sqrt') {
              if (isPositive(ce, getArg(expr, 1)))
                  return true;
          }
          if (name === MULTIPLY || name === ADD) {
              return getTail(expr).every((x) => isPositive(ce, x) === true);
          }
          if (name === DIVIDE) {
              if (isPositive(ce, getArg(expr, 1)) && isPositive(ce, getArg(expr, 2))) {
                  return true;
              }
          }
          if (name === POWER) {
              if (isPositive(ce, getArg(expr, 1)))
                  return true;
          }
      }
      return undefined;
  }
  function isOne(ce, expr) {
      return isEqual();
  }
  function isNegativeOne(ce, expr) {
      return isEqual();
  }
  /** Is `expr` >= 0? */
  function isNonNegative(ce, expr) {
      const result = ce.isZero(expr);
      if (result === undefined)
          return undefined;
      if (result === true)
          return true;
      return ce.isPositive(expr);
  }
  /** Is `expr` < 0? */
  function isNegative(ce, expr) {
      const result = isPositive(ce, expr);
      if (result === true)
          return false;
      if (result === undefined)
          return undefined;
      if (isZero(ce, expr) === false)
          return true;
      return false;
  }
  /** Is `expr` <= 0? */
  function isNonPositive(ce, expr) {
      const result = isPositive(ce, expr);
      if (result === undefined)
          return undefined;
      return !result;
  }
  function isReal(_ce, expr) {
      // @todo
      if (expr === null)
          return false;
      const val = getNumberValue(expr);
      if (val === null)
          return false;
      return true;
  }
  /** Is `expr` an element of RR, including Â±âˆž? */
  function isExtendedReal(_ce, _expr) {
      // @todo
      return undefined;
  }
  /** Is `expr` an element of QQ (can be written as p/q)? */
  function isRational(_ce, _expr) {
      // @todo
      return undefined;
  }
  /** Is `expr` an algebraic number, i.e. not transcendental (Ï€, e)? */
  function isAlgebraic(_ce, _expr) {
      // @todo
      return undefined;
  }
  /** Is `expr` a complex number? */
  function isComplex(_ce, _expr) {
      // @todo
      return undefined;
  }
  /** Is `expr` an element of `dom`? */
  function isElement(_ce, _expr, _set) {
      // @todo
      return undefined;
  }
  /** Test if `lhs` is a subset of `rhs`.
   *
   * `lhs` and `rhs` can be set expressions, i.e.
   * `["SetMinus", "ComplexNumber", 0]`
   *
   */
  function isSubsetOf(ce, lhs, rhs) {
      var _a, _b, _c;
      if (!lhs || !rhs)
          return false;
      if (typeof lhs === 'string' && lhs === rhs)
          return true;
      if (rhs === 'Anything')
          return true;
      if (rhs === 'Nothing')
          return false;
      //
      // 1. Set operations on lhs
      //
      // Union: lhs or rhs
      // Intersection: lhs and rhs
      // SetMinus: lhs and not rhs
      // Complement: not lhs
      const lhsFnName = getFunctionName(lhs);
      if (lhsFnName === 'Union') {
          return getTail(lhs).some((x) => isSubsetOf(ce, x, rhs));
      }
      else if (lhsFnName === 'Intersection') {
          return getTail(lhs).every((x) => isSubsetOf(ce, x, rhs));
      }
      else if (lhsFnName === 'SetMinus') {
          return (isSubsetOf(ce, getArg(lhs, 1), rhs) &&
              !isSubsetOf(ce, getArg(lhs, 2), rhs));
          // } else if (lhsFnName === 'Complement') {
          //   return !ce.isSubsetOf(getArg(lhs, 1), rhs);
      }
      //
      // 2. Set operations on rhs
      //
      const rhsFnName = getFunctionName(rhs);
      if (rhsFnName === 'Union') {
          return getTail(rhs).some((x) => isSubsetOf(ce, lhs, x));
      }
      else if (rhsFnName === 'Intersection') {
          return getTail(rhs).every((x) => isSubsetOf(ce, lhs, x));
      }
      else if (rhsFnName === 'SetMinus') {
          return (isSubsetOf(ce, lhs, getArg(rhs, 1)) &&
              !isSubsetOf(ce, lhs, getArg(rhs, 2)));
          // } else if (rhsFnName === 'Complement') {
          //   return !ce.isSubsetOf(lhs, getArg(rhs, 1));
      }
      //
      // 3. Not a set operation: a domain or a parametric domain
      //
      const rhsDomainName = (_a = getSymbolName(rhs)) !== null && _a !== void 0 ? _a : rhsFnName;
      if (!rhsDomainName) {
          const rhsVal = (_b = getNumberValue(rhs)) !== null && _b !== void 0 ? _b : NaN;
          if (Number.isNaN(rhsVal))
              return false;
          // If the rhs is a number, 'upgrade' it to a set singleton
          rhs = rhs === 0 ? 'NumberZero' : ['Set', rhs];
      }
      const rhsDef = ce.getSetDefinition(rhsDomainName);
      if (!rhsDef)
          return false;
      if (typeof rhsDef.isSubsetOf === 'function') {
          // 3.1 Parametric domain
          return rhsDef.isSubsetOf(this, lhs, rhs);
      }
      const lhsDomainName = (_c = getSymbolName(lhs)) !== null && _c !== void 0 ? _c : lhsFnName;
      if (!lhsDomainName)
          return false;
      const lhsDef = ce.getSetDefinition(lhsDomainName);
      if (!lhsDef)
          return false;
      // 3.2 Non-parametric domain:
      for (const parent of lhsDef.supersets) {
          if (isSubsetOf(ce, parent, rhs))
              return true;
      }
      return false;
  }
  function isEqual(_ce, _lhs, _rhs) {
      //@todo
      return undefined;
  }
  function isLess(_ce, _lhs, _rhs) {
      //@todo
      return undefined;
  }
  function isLessEqual(_ce, _lhs, _rhs) {
      //@todo
      return undefined;
  }
  function isGreater(_ce, _lhs, _rhs) {
      //@todo
      return undefined;
  }
  function isGreaterEqual(_ce, _lhs, _rhs) {
      //@todo
      return undefined;
  }

  function gamma(c) {
      // @todo
      // Consider: https://github.com/josdejong/mathjs/blob/develop/src/function/probability/gamma.js#L37-L76
      return c;
  }

  const ARITHMETIC_DICTIONARY = {
      //
      // Constants
      //
      MachineEpsilon: {
          /*
                  The difference between 1 and the next larger floating point number
                  
                  2^{âˆ’52}
                  
                  See https://en.wikipedia.org/wiki/Machine_epsilon
              */
          domain: 'RealNumber',
          constant: true,
          value: { num: Number.EPSILON.toString() },
      },
      ImaginaryUnit: {
          domain: 'ImaginaryNumber',
          constant: true,
          wikidata: 'Q193796',
      },
      ExponentialE: {
          domain: 'TranscendentalNumber',
          wikidata: 'Q82435',
          constant: true,
          value: (engine) => {
              if (engine.numericFormat === 'decimal')
                  return decimal.exports.Decimal.exp(1);
              if (engine.numericFormat === 'complex')
                  return complex.exports.Complex.E;
              return 2.7182818284590452354;
          },
      },
      GoldenRatio: {
          domain: 'IrrationalNumber',
          wikidata: 'Q41690',
          constant: true,
          hold: false,
          value: ['Divide', ['Add', 1, ['Sqrt', 5]], 2],
      },
      CatalanConstant: {
          domain: 'RealNumber',
          wikidata: 'Q855282',
          constant: true,
          value: { num: '0.91596559417721901505' },
      },
      EulerGamma: {
          domain: 'RealNumber',
          wikidata: 'Q273023',
          constant: true,
          value: { num: '0.577215664901532860606' },
      },
      Quarter: {
          domain: 'RationalNumber',
          wikidata: 'Q2310416',
          constant: true,
          hold: false,
          value: [DIVIDE, 3, 4],
      },
      Third: {
          domain: 'RationalNumber',
          wikidata: 'Q20021125',
          constant: true,
          hold: false,
          value: [DIVIDE, 1, 3],
      },
      Half: {
          domain: 'RationalNumber',
          wikidata: 'Q2114394',
          constant: true,
          hold: false,
          value: [DIVIDE, 1, 2],
      },
      TwoThird: {
          domain: 'RationalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, 2, 3],
      },
      ThreeQuarter: {
          domain: 'RationalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, 3, 4],
      },
      //
      // Functions
      //
      Abs: {
          domain: 'Function',
          wikidata: 'Q3317982',
          threadable: true,
          idempotent: true,
          numeric: true,
          range: ['Interval', 0, Infinity],
          evalNumber: (_ce, val) => Math.abs(val),
          evalComplex: (_ce, n) => complex.exports.Complex.abs(n),
          evalDecimal: (_ce, n) => decimal.exports.Decimal.abs(n),
      },
      Add: {
          domain: 'Function',
          wikidata: 'Q32043',
          associative: true,
          commutative: true,
          threadable: true,
          idempotent: true,
          range: 'Number',
          numeric: true,
          simplify: simplifyAdd,
          evalNumber: (_ce, ...args) => {
              if (args.length === 0)
                  return 0;
              let c = 0;
              for (const arg of args)
                  c += arg;
              return c;
          },
          evalComplex: (_ce, ...args) => {
              if (args.length === 0)
                  return complex.exports.Complex.ZERO;
              let c = complex.exports.Complex.ZERO;
              for (const arg of args)
                  c = c.add(arg);
              return c;
          },
          evalDecimal: (_ce, ...args) => {
              if (args.length === 0)
                  return DECIMAL_ZERO;
              let c = DECIMAL_ZERO;
              for (const arg of args)
                  c = c.add(arg);
              return c;
          },
          evaluate: (ce, ...args) => {
              // Some arguments could not be evaluated to numbers or there's a mix
              // of Decimal and Complex:
              // still try to add the ones that are numeric, keep the others as is.
              if (args.length === 0)
                  return 0;
              let result = ['Add'];
              const decimals = args.filter((x) => x instanceof decimal.exports.Decimal);
              if (decimals.length > 0) {
                  if (decimals.length === 1) {
                      result.push(decimals[0]);
                  }
                  else {
                      result.push(ce.N(['Add', ...decimals]));
                  }
              }
              const complexes = args.filter((x) => x instanceof complex.exports.Complex);
              if (complexes.length > 0) {
                  if (complexes.length === 1) {
                      result.push(complexes[0]);
                  }
                  else {
                      result.push(ce.N(['Add', ...complexes]));
                  }
              }
              const numbers = args.filter((x) => typeof x === 'number');
              if (numbers.length > 0) {
                  if (numbers.length === 1) {
                      result.push(numbers[0]);
                  }
                  else {
                      result.push(ce.N(['Add', ...numbers]));
                  }
              }
              const others = args.filter((x) => typeof x !== 'number' &&
                  !(x instanceof decimal.exports.Decimal) &&
                  !(x instanceof complex.exports.Complex));
              result = [...result, ...others];
              if (result.length === 0)
                  return 0;
              if (result.length === 1)
                  return result[1];
              return result;
          },
      },
      Chop: {
          domain: 'Function',
          associative: true,
          threadable: true,
          idempotent: true,
          numeric: true,
          range: 'Number',
          evalNumber: (ce, val) => ce.chop(val),
          evalComplex: (ce, n) => ce.chop(n),
          evalDecimal: (ce, n) => ce.chop(n),
      },
      Ceil: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          /** rounds a number up to the next largest integer */
          evalNumber: (_ce, val) => Math.ceil(val),
          evalComplex: (_ce, n) => complex.exports.Complex.ceil(n),
          evalDecimal: (_ce, n) => decimal.exports.Decimal.ceil(n),
      },
      Divide: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, lhs, rhs) => lhs / rhs,
          evalComplex: (_ce, lhs, rhs) => typeof lhs === 'number' ? new complex.exports.Complex(lhs).div(rhs) : lhs.div(rhs),
          evalDecimal: (_ce, lhs, rhs) => decimal.exports.Decimal.div(lhs, rhs),
      },
      Exp: {
          domain: ['ContinuousFunction', 'MonotonicFunction'],
          wikidata: 'Q168698',
          threadable: true,
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, val) => Math.exp(val),
          evalComplex: (_ce, val) => typeof val === 'number' ? new complex.exports.Complex(val).exp() : val.exp(),
          evalDecimal: (_ce, val) => decimal.exports.Decimal.exp(val),
      },
      Erf: {
          // Error function
          domain: ['ContinuousFunction', 'MonotonicFunction'],
          range: 'Number',
          numeric: true,
      },
      Erfc: {
          // Complementary Error Function
          domain: ['ContinuousFunction', 'MonotonicFunction'],
          range: 'Number',
          numeric: true,
      },
      Factorial: {
          wikidata: 'Q120976',
          domain: 'MonotonicFunction',
          range: 'Integer',
          numeric: true,
          evalNumber: (_ce, n) => factorial(n),
          evalComplex: (_ce, c) => typeof c === 'number'
              ? gamma(new complex.exports.Complex(c + 1))
              : gamma(c.add(1)),
          evalDecimal: (_ce, d) => factorial$1(d),
      },
      Floor: {
          domain: 'Function',
          wikidata: 'Q56860783',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, x) => Math.floor(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.floor(x),
      },
      Gamma: {
          domain: 'Function',
          wikidata: 'Q190573',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, n) => gamma$1(n),
          // evalComplex: (_ce, c: Complex): Complex => gammaComplex(c),
          evalDecimal: (_ce, d) => gamma$2(d),
      },
      LogGamma: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, n) => lngamma(n),
          // evalComplex: (_ce, c: Complex): Complex => lngammaComplex(c),
          evalDecimal: (_ce, d) => lngamma$1(d),
      },
      Ln: {
          domain: 'Function',
          wikidata: 'Q11197',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, x) => Math.log(x),
          evalComplex: (_ce, c) => typeof c === 'number' ? new complex.exports.Complex(c).log() : c.log(),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x),
      },
      Log: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, base, x) => Math.log(x) / Math.log(base),
          evalComplex: (_ce, base, x) => {
              const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
              const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
              return cX.log().div(cBase.log());
          },
          evalDecimal: (_ce, base, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(base)),
      },
      Lb: {
          domain: 'Function',
          wikidata: 'Q581168',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, x) => Math.log2(x),
          evalComplex: (_ce, base, x) => {
              const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
              return cX.log().div(complex.exports.Complex.log(2));
          },
          evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(2)),
      },
      Lg: {
          domain: 'Function',
          wikidata: 'Q966582',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, x) => Math.log10(x),
          evalComplex: (_ce, base, x) => {
              const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
              return cX.log().div(complex.exports.Complex.log(10));
          },
          evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(10)),
      },
      // LogOnePlus: { domain: 'Function' },
      Multiply: {
          domain: 'Function',
          wikidata: 'Q40276',
          associative: true,
          commutative: true,
          idempotent: true,
          range: 'Number',
          simplify: simplifyMultiply,
          numeric: true,
          evalNumber: evalNumberMultiply,
          evalComplex: (_ce, ...args) => {
              if (args.length === 0)
                  return complex.exports.Complex.ONE;
              let c = complex.exports.Complex.ONE;
              for (const arg of args)
                  c = c.mul(arg);
              return c;
          },
          evalDecimal: (_ce, ...args) => {
              if (args.length === 0)
                  return DECIMAL_ONE;
              let c = DECIMAL_ONE;
              for (const arg of args)
                  c = c.mul(arg);
              return c;
          },
          evaluate: (ce, ...args) => {
              // Some arguments could not be evaluated to numbers or there's a mix
              // of Decimal and Complex:
              // still try to add the ones that are numeric, keep the others as is.
              if (args.length === 0)
                  return 0;
              let result = ['Multiply'];
              const decimals = args.filter((x) => x instanceof decimal.exports.Decimal);
              if (decimals.length > 0) {
                  if (decimals.length === 1) {
                      result.push(decimals[0]);
                  }
                  else {
                      result.push(ce.N(['Multiply', ...decimals]));
                  }
              }
              const complexes = args.filter((x) => x instanceof complex.exports.Complex);
              if (complexes.length > 0) {
                  if (complexes.length === 1) {
                      result.push(complexes[0]);
                  }
                  else {
                      result.push(ce.N(['Multiply', ...complexes]));
                  }
              }
              const numbers = args.filter((x) => typeof x === 'number');
              if (numbers.length > 0) {
                  if (numbers.length === 1) {
                      result.push(numbers[0]);
                  }
                  else {
                      result.push(ce.N(['Multiply', ...numbers]));
                  }
              }
              const others = args.filter((x) => typeof x !== 'number' &&
                  !(x instanceof decimal.exports.Decimal) &&
                  !(x instanceof complex.exports.Complex));
              result = [...result, ...others];
              if (result.length === 0)
                  return 1;
              if (result.length === 1)
                  return result[1];
              return result;
          },
      },
      Negate: {
          domain: 'Function',
          wikidata: 'Q715358',
          range: 'Number',
          simplify: (_ce, x) => { var _a; return (_a = applyNegate(x)) !== null && _a !== void 0 ? _a : ['Negate', x]; },
          numeric: true,
          evalNumber: (_ce, val) => -val,
          evalComplex: (_ce, x) => typeof x === 'number' ? new complex.exports.Complex(-x) : x.neg(),
          evalDecimal: (_ce, x) => typeof x === 'number' ? new decimal.exports.Decimal(-x) : x.neg(),
      },
      Power: {
          domain: 'Function',
          wikidata: 'Q33456',
          commutative: false,
          numeric: true,
          range: 'Number',
          simplify: (ce, ...args) => applyPower(ce, ['Power', ...args]),
          evalNumber: (_ce, base, power) => Math.pow(base, power),
          evalComplex: (_ce, base, power) => {
              const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
              const cPower = typeof power === 'number' ? new complex.exports.Complex(power) : power;
              return complex.exports.Complex.pow(cBase, cPower);
          },
          evalDecimal: (_ce, base, power) => decimal.exports.Decimal.pow(base, power),
      },
      Round: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, val) => Math.round(val),
          evalComplex: (_ce, val) => typeof val === 'number' ? new complex.exports.Complex(val).round() : val.round(),
          evalDecimal: (_ce, val) => decimal.exports.Decimal.round(val),
      },
      Sign: {
          domain: 'Function',
          range: ['Range', -1, 1],
          numeric: true,
          simplify: (ce, x) => isZero(ce, x) ? 0 : isNegative(ce, x) ? -1 : 1,
          evalNumber: (_ce, val) => (val === 0 ? 0 : val < 0 ? -1 : 1),
          evalComplex: (_ce, z) => {
              const cZ = typeof z === 'number' ? new complex.exports.Complex(z) : z;
              return cZ.div(cZ.abs());
          },
          evalDecimal: (_ce, val) => {
              if (typeof val === 'number') {
                  return val === 0
                      ? DECIMAL_ZERO
                      : val < 0
                          ? DECIMAL_MINUS_ONE
                          : DECIMAL_ONE;
              }
              return val.isZero()
                  ? DECIMAL_ZERO
                  : val.isNeg()
                      ? DECIMAL_MINUS_ONE
                      : DECIMAL_ONE;
          },
      },
      SignGamma: {
          domain: 'Function',
          range: 'Number',
          numeric: true,
          /** The sign of the gamma function: -1 or +1 */
      },
      Sqrt: {
          domain: 'Function',
          wikidata: 'Q134237',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, val) => Math.sqrt(val),
          evalComplex: (_ce, z) => typeof z === 'number' ? new complex.exports.Complex(z).sqrt() : z.sqrt(),
          evalDecimal: (_ce, val) => decimal.exports.Decimal.sqrt(val),
      },
      Square: {
          domain: 'Function',
          wikidata: 'Q3075175',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, val) => val * val,
          evalComplex: (_ce, z) => typeof z === 'number' ? new complex.exports.Complex(z).multiply(z) : z.mul(z),
          evalDecimal: (_ce, val) => decimal.exports.Decimal.mul(val, val),
      },
      Root: {
          domain: 'Function',
          commutative: false,
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, base, power) => Math.pow(base, 1 / power),
          evalComplex: (_ce, base, power) => {
              const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
              const cPower = typeof power === 'number'
                  ? new complex.exports.Complex(1 / power)
                  : new complex.exports.Complex(complex.exports.Complex.ONE.div(power));
              return complex.exports.Complex.pow(cBase, cPower);
          },
          evalDecimal: (_ce, base, power) => decimal.exports.Decimal.pow(base, DECIMAL_ONE.div(power)),
      },
      Subtract: {
          domain: 'Function',
          wikidata: 'Q32043',
          range: 'Number',
          numeric: true,
          evalNumber: (_ce, lhs, rhs) => lhs - rhs,
          evalComplex: (_ce, lhs, rhs) => typeof lhs === 'number' ? new complex.exports.Complex(lhs).sub(rhs) : lhs.sub(rhs),
          evalDecimal: (_ce, lhs, rhs) => decimal.exports.Decimal.sub(lhs, rhs),
      },
      // @todo
      // mod (modulo). See https://numerics.diploid.ca/floating-point-part-4.html,
      // regarding 'remainder' and 'truncatingRemainder'
      // lcm
      // gcd
      // root
      // sum
      // product
  };
  function simplifyAdd(ce, ...args) {
      var _a, _b;
      if (args.length === 0)
          return 0;
      if (args.length === 1)
          return args[0];
      let numerTotal = 0;
      let denomTotal = 1;
      let dTotal = DECIMAL_ZERO;
      let cTotal = complex.exports.Complex.ZERO;
      let posInfinity = false;
      let negInfinity = false;
      const others = [];
      for (const arg of args) {
          const symbol = getSymbolName(arg);
          if (symbol === MISSING || symbol === NOTHING)
              return NaN;
          if (symbol === COMPLEX_INFINITY)
              return COMPLEX_INFINITY;
          if (isInfinity(ce, arg)) {
              if (isPositive(ce, arg)) {
                  posInfinity = true;
              }
              else {
                  negInfinity = true;
              }
          }
          const [n, d] = getRationalValue(arg);
          if (n !== null && d !== null) {
              if (isNaN(n) || isNaN(d))
                  return NaN;
              numerTotal = numerTotal * d + n * denomTotal;
              denomTotal = denomTotal * d;
          }
          else {
              const c = getComplexValue(arg);
              if (c !== null) {
                  if (Number.isInteger(c.re) && Number.isInteger(c.im)) {
                      cTotal = cTotal.add(c);
                  }
                  else {
                      others.push(arg);
                  }
              }
              else {
                  const d = getDecimalValue(arg);
                  if (d !== null && d.isInteger()) {
                      dTotal = dTotal.add(d);
                  }
                  else {
                      const val = getNumberValue(arg);
                      if (val !== null && Number.isInteger(val)) {
                          numerTotal += val;
                      }
                      else if (isNotZero(ce, arg) !== false) {
                          others.push(arg);
                      }
                  }
              }
          }
      }
      if (posInfinity && negInfinity)
          return NaN;
      if (posInfinity)
          return Infinity;
      if (negInfinity)
          return -Infinity;
      // Group similar terms
      // @todo
      // const terms: { [term: string]: number } = {};
      // for (const [term, coeff] of forEachTermCoeff(others)) {
      // }
      if (!dTotal.isZero())
          others.push(dTotal);
      if (!cTotal.isZero())
          others.push(cTotal);
      if (others.length === 0) {
          if (numerTotal === 0)
              return 0;
          if (denomTotal === 1)
              return numerTotal;
          return ['Divide', numerTotal, denomTotal];
      }
      if (numerTotal !== 0) {
          const g = gcd(numerTotal, denomTotal);
          numerTotal = numerTotal / g;
          denomTotal = denomTotal / g;
          if (denomTotal === 1) {
              others.push(numerTotal);
          }
          else {
              others.push(['Divide', numerTotal, denomTotal]);
          }
      }
      if (others.length === 1)
          return others[0];
      if (others.length === 2 && getFunctionName(others[1]) === NEGATE) {
          // a + (-b) -> a - b
          return ['Subtract', others[0], (_a = getArg(others[1], 1)) !== null && _a !== void 0 ? _a : MISSING];
      }
      else if (others.length === 2 && getFunctionName(others[0]) === NEGATE) {
          // (-a) + b -> b - a
          return ['Subtract', others[1], (_b = getArg(others[0], 1)) !== null && _b !== void 0 ? _b : MISSING];
      }
      return ['Add', ...others];
  }
  function simplifyMultiply(ce, ...args) {
      if (args.length === 0)
          return 1;
      if (args.length === 1)
          return args[0];
      const others = [];
      let numer = 1;
      let denom = 1;
      let c = complex.exports.Complex.ONE;
      for (const arg of args) {
          const val = getNumberValue(arg);
          if (val === 0)
              return 0;
          if (val !== null && (!Number.isFinite(val) || Number.isInteger(val))) {
              numer *= val;
          }
          else {
              const [n, d] = [null, null]; // getRationalValue(arg);
              if (n !== null && d !== null) {
                  numer *= n;
                  denom *= d;
              }
              else {
                  const cVal = getComplexValue(arg);
                  if (cVal !== null) {
                      if (Number.isInteger(cVal.re) && Number.isInteger(cVal.im)) {
                          c = c.mul(cVal);
                      }
                      else {
                          others.push(arg);
                      }
                  }
                  else {
                      // @todo: consider distributing if the head of arg is Add or Negate or Subtract or Divide
                      if (isZero(ce, arg))
                          return 0;
                      others.push(arg);
                  }
              }
          }
      }
      if (c.im !== 0) {
          c = c.mul(numer);
          numer = 1;
      }
      else {
          numer = numer * c.re;
          c = complex.exports.Complex.ONE;
      }
      // Divide numer by denom to get the proper signed infinite or NaN
      if (numer === 0 || !isFinite(numer))
          return numer / denom;
      if (!c.equals(complex.exports.Complex.ONE)) {
          others.push(['Complex', c.re, c.im]);
      }
      if (others.length === 0) {
          if (denom === 1)
              return numer;
          return ['Divide', numer, denom];
      }
      if (denom !== 1) {
          others.unshift(['Divide', numer, denom]);
          numer = 1;
          denom = 1;
      }
      if (others.length === 1 && numer === 1)
          return others[0];
      if (others.length === 1 && numer === -1)
          return ['Negate', others[0]];
      if (numer === 1)
          return ['Multiply', ...others];
      if (numer === -1)
          return ['Negate', ['Multiply', ...others]];
      return ['Multiply', numer, ...others];
  }
  /** Apply some simplifications for `Negate`.
   *  Used by `canonical-negate` and `simplify`
   */
  function applyNegate(expr) {
      var _a, _b, _c, _d;
      expr = ungroup(expr);
      if (typeof expr === 'number') {
          // Applying negation is safe on floating point numbers
          return -expr;
      }
      if (expr && isNumberObject(expr)) {
          if (expr.num[0] === '-') {
              return { num: expr.num.slice(1) };
          }
          else if (expr.num[0] === '+') {
              return { num: '-' + expr.num.slice(1) };
          }
          else {
              return { num: '-' + expr.num };
          }
      }
      if (expr instanceof decimal.exports.Decimal) {
          const d = expr;
          return d.mul(-1);
      }
      if (expr instanceof complex.exports.Complex) {
          const c = expr;
          return c.mul(-1);
      }
      const name = getFunctionName(expr);
      const argCount = getArgCount(expr);
      if (name === NEGATE && argCount === 1) {
          // [NEGATE, [NEGATE, x]] -> x
          return (_a = getArg(expr, 1)) !== null && _a !== void 0 ? _a : MISSING;
      }
      else if (name === MULTIPLY) {
          const arg = applyNegate((_b = getArg(expr, 1)) !== null && _b !== void 0 ? _b : MISSING);
          return [MULTIPLY, arg, ...getTail(expr).slice(1)];
      }
      else if (name === ADD) {
          return [ADD, ...mapArgs(expr, applyNegate)];
      }
      else if (name === SUBTRACT) {
          return [SUBTRACT, (_c = getArg(expr, 2)) !== null && _c !== void 0 ? _c : MISSING, (_d = getArg(expr, 1)) !== null && _d !== void 0 ? _d : MISSING];
      }
      else if (name === PARENTHESES && argCount === 1) {
          return applyNegate(getArg(getArg(expr, 1), 1));
      }
      return [NEGATE, expr !== null && expr !== void 0 ? expr : MISSING];
  }
  // The function is `numeric` so it will be passed numbers
  function evalNumberMultiply(_ce, ...args) {
      if (args.length === 0)
          return 1;
      if (args.length === 1)
          return args[0];
      let c = 1;
      for (const arg of args)
          c *= arg;
      return c;
  }
  function ungroup(expr) {
      if (expr === null)
          return NOTHING;
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) === PARENTHESES && getArgCount(expr) === 1) {
          return ungroup(getArg(expr, 1));
      }
      return applyRecursively(expr, ungroup);
  }
  // Used by `simplify()` and `canonical()`
  // @todo: see https://docs.sympy.org/1.6/modules/core.html#pow
  function applyPower(engine, expr) {
      var _a, _b;
      // @todo: using engine predicates (isEqual(x, 1)...)
      expr = ungroup(expr);
      console.assert(getFunctionName(expr) === 'Power');
      if (getArgCount(expr) !== 2)
          return expr;
      const arg1 = getArg(expr, 1);
      const val1 = (_a = getNumberValue(arg1)) !== null && _a !== void 0 ? _a : NaN;
      const arg2 = getArg(expr, 2);
      if (getSymbolName(arg2) === 'ComplexInfinity')
          return NaN;
      const val2 = (_b = getNumberValue(arg2)) !== null && _b !== void 0 ? _b : NaN;
      if (isZero(engine, arg2))
          return 1;
      if (val2 === 1)
          return arg1;
      if (val2 === 2)
          return ['Square', arg1];
      if (val2 === -1) {
          if (val1 === -1 || val1 === 1)
              return -1;
          if (!Number.isFinite(val1))
              return 0;
          return ['Divide', 1, arg1];
      }
      if (!Number.isFinite(val2)) {
          if (val1 === 0 && val2 < 0)
              return 'ComplexInfinity';
          if (val1 === 1 || val1 === -1)
              return NaN;
          if (val1 === Infinity) {
              if (val2 > 0)
                  return Infinity;
              if (val2 < 0)
                  return 0;
          }
          if (val1 === -Infinity && !Number.isFinite(val2))
              return NaN;
      }
      return expr;
  }
  /** Used by `simplify` and `canonical` to simplify some arithmetic
   * and trigonometric constants */
  function applyConstants(expr) {
      if (isAtomic(expr))
          return expr;
      let [numer, denom] = getRationalValue(expr);
      if (numer === 3 && denom === 4)
          return 'ThreeQuarter';
      if (numer === 2 && denom === 3)
          return 'TwoThird';
      if (numer === 1 && denom === 2)
          return 'Half';
      if (numer === 1 && denom === 4)
          return 'Quarter';
      // Trigonometric constants: -Ï€, Ï€/4, etc...
      [numer, denom] = getRationalSymbolicValue(expr, 'Pi');
      if (numer === null || denom === null) {
          return applyRecursively(expr, (x) => applyConstants(x));
      }
      if (numer === -2 && denom === 1)
          return 'MinusDoublePi';
      if (numer === -1 && denom === 2)
          return 'MinusHalfPi';
      if (numer === 1 && denom === 4)
          return 'QuarterPi';
      if (numer === 1 && denom === 3)
          return 'ThirdPi';
      if (numer === 1 && denom === 2)
          return 'HalfPi';
      if (numer === 2 && denom === 3)
          return 'TwoThirdPi';
      if (numer === 3 && denom === 4)
          return 'ThreeQuarterPi';
      if (numer === 2 && denom === 1)
          return 'DoublePi';
      if (numer === 1 && denom === 1)
          return 'Pi';
      if (numer === 1)
          return ['Divide', 'Pi', denom];
      if (denom === 1)
          return ['Multiply', numer, 'Pi'];
      return ['Multiply', ['Divide', numer, denom], 'Pi'];
  }
  // function* forEachTermCoeff(
  //   terms: Expression[]
  // ): Generator<[term: Expression, coef: number]> {
  //   return;
  // }

  /**
   * If expression is a product, collect all the terms with a
   * negative exponents in the denominator, and all the terms
   * with a positive exponent (or no exponent) in the numerator.
   */
  function numeratorDenominator(expr) {
      var _a, _b, _c, _d, _e, _f;
      if (getFunctionName(expr) !== MULTIPLY)
          return [[], []];
      const numerator = [];
      const denominator = [];
      const args = getTail(expr);
      for (const arg of args) {
          if (getFunctionName(arg) === POWER) {
              if (getFunctionName(getArg(arg, 2)) === NEGATE) {
                  const a = (_a = getArg(arg, 1)) !== null && _a !== void 0 ? _a : NOTHING;
                  const b = (_b = getArg(getArg(arg, 2), 1)) !== null && _b !== void 0 ? _b : NOTHING;
                  denominator.push([POWER, a, b]);
              }
              else {
                  const exponentVal = (_c = getNumberValue(getArg(arg, 2))) !== null && _c !== void 0 ? _c : NaN;
                  if (exponentVal === -1) {
                      denominator.push((_d = getArg(arg, 1)) !== null && _d !== void 0 ? _d : NOTHING);
                  }
                  else if (exponentVal < 0) {
                      denominator.push([
                          POWER,
                          (_e = getArg(arg, 1)) !== null && _e !== void 0 ? _e : NOTHING,
                          (_f = applyNegate(getArg(arg, 2))) !== null && _f !== void 0 ? _f : NOTHING,
                      ]);
                  }
                  else {
                      numerator.push(arg);
                  }
              }
          }
          else {
              numerator.push(arg);
          }
      }
      return [numerator, denominator];
  }
  function serializeRoot(serializer, style, base, degree) {
      if (base === null)
          return '\\sqrt{}';
      degree = degree !== null && degree !== void 0 ? degree : 2;
      if (style === 'solidus') {
          return (serializer.wrapShort(base) + '^{1\\/' + serializer.serialize(degree) + '}');
      }
      else if (style === 'quotient') {
          return (serializer.wrapShort(base) +
              '^{\\frac{1}{' +
              serializer.serialize(degree) +
              '}}');
      }
      const degreeValue = getNumberValue(degree);
      if (degreeValue === 2) {
          return '\\sqrt{' + serializer.serialize(base) + '}';
      }
      // It's the n-th root
      return ('\\sqrt[' +
          serializer.serialize(degree) +
          ']{' +
          serializer.serialize(base) +
          '}');
  }
  function parseRoot(lhs, scanner, _minPrec) {
      if (!scanner.match('\\sqrt'))
          return [lhs, null];
      const degree = scanner.matchOptionalLatexArgument();
      const base = scanner.matchRequiredLatexArgument();
      if (base === null) {
          if (degree !== null)
              return [lhs, [ROOT, NOTHING, degree]];
          return [lhs, [SQRT]];
      }
      if (degree !== null)
          return [lhs, [ROOT, base, degree]];
      return [lhs, [SQRT, base]];
  }
  function parseMinusSign(lhs, scanner, minPrec) {
      if (276 < minPrec)
          return [lhs, null];
      const index = scanner.index;
      if (!scanner.match('-'))
          return [lhs, null];
      const rhs = scanner.matchExpression(lhs === null ? 400 : 277);
      if (rhs === null) {
          scanner.index = index;
          return [lhs, null];
      }
      if (lhs === null)
          return [null, [NEGATE, rhs]];
      return [null, [SUBTRACT, lhs, rhs]];
  }
  function parsePlusSign(lhs, scanner, minPrec) {
      if (275 < minPrec)
          return [lhs, null];
      const index = scanner.index;
      if (!scanner.match('+'))
          return [lhs, null];
      const rhs = scanner.matchExpression(lhs === null ? 400 : 275);
      if (rhs === null) {
          scanner.index = index;
          return [lhs, null];
      }
      if (lhs === null)
          return [null, rhs];
      return scanner.applyOperator(ADD, lhs, rhs);
  }
  function serializeAdd(serializer, expr) {
      var _a, _b;
      // "add" doesn't increase the "level" for styling purposes
      // so, preventatively decrease it now.
      serializer.level -= 1;
      const name = getFunctionName(expr);
      let result = '';
      let arg = getArg(expr, 1);
      let argWasNumber = !Number.isNaN((_a = getNumberValue(arg)) !== null && _a !== void 0 ? _a : NaN);
      if (name === NEGATE) {
          result = '-' + serializer.wrap(arg, 276);
      }
      else if (name === ADD) {
          result = serializer.serialize(arg);
          const last = getArgCount(expr) + 1;
          for (let i = 2; i < last; i++) {
              arg = getArg(expr, i);
              const val = (_b = getNumberValue(arg)) !== null && _b !== void 0 ? _b : NaN;
              const argIsNumber = !Number.isNaN(val);
              let done = false;
              if (arg !== null) {
                  if (argWasNumber) {
                      // Check if we can convert to an invisible plus, e.g. "1\frac{1}{2}"
                      const [numer, denom] = getRationalValue(arg);
                      if (numer !== null && denom !== null) {
                          if (isFinite(numer) && isFinite(denom) && denom !== 1) {
                              // Don't include the '+' sign, it's a rational, use 'invisible plus'
                              result +=
                                  serializer.options.invisiblePlus + serializer.serialize(arg);
                              done = true;
                          }
                      }
                  }
              }
              if (!done) {
                  if (val < 0) {
                      // Don't include the minus sign, it will be serialized for the arg
                      result += serializer.serialize(arg);
                  }
                  else if (getFunctionName(arg) === NEGATE) {
                      result += serializer.wrap(arg, 275);
                  }
                  else {
                      const term = serializer.wrap(arg, 275);
                      if (term[0] === '-' || term[0] === '+') {
                          result += term;
                      }
                      else {
                          result = result + '+' + term;
                      }
                  }
              }
              argWasNumber = argIsNumber;
          }
      }
      else if (name === SUBTRACT) {
          const arg2 = getArg(expr, 2);
          if (arg2 !== null) {
              result = serializer.wrap(arg, 275) + '-' + serializer.wrap(arg2, 275);
          }
          else {
              result = serializer.wrap(arg, 275);
          }
      }
      // Restore the level
      serializer.level += 1;
      return result;
  }
  function serializeMultiply(serializer, expr) {
      var _a;
      if (expr === null)
          return '';
      // "Multiply" doesn't increase the "level" for styling purposes
      // so, preventively decrease it now.
      serializer.level -= 1;
      let result = '';
      //
      // Is it a fraction?
      // (i.e. does it have a denominator, i.e. some factors with a negative power)
      //
      const [numer, denom] = numeratorDenominator(expr);
      if (denom.length > 0) {
          if (denom.length === 1 && denom[0] === 1) {
              if (numer.length === 0) {
                  result = '1';
              }
              else if (numer.length === 1) {
                  result = serializer.serialize(numer[0]);
              }
              else {
                  result = serializeMultiply(serializer, [MULTIPLY, ...numer]);
              }
          }
          else {
              result = serializer.serialize([
                  DIVIDE,
                  numer.length === 1 ? numer[0] : [MULTIPLY, ...numer],
                  denom.length === 1 ? denom[0] : [MULTIPLY, ...denom],
              ]);
          }
      }
      if (result) {
          // Restore the level
          serializer.level += 1;
          return result;
      }
      let isNegative = false;
      let arg = null;
      const count = getArgCount(expr) + 1;
      let prevWasNumber = false;
      for (let i = 1; i < count; i++) {
          arg = getArg(expr, i);
          if (arg !== null) {
              let term;
              //
              // 1. Should the terms be separated by an explicit MULTIPLY?
              //
              if (typeof arg === 'number' || isNumberObject(arg)) {
                  term = serializer.serialize(arg);
                  if (term === '-1' && !result) {
                      result = '-';
                  }
                  else {
                      if (term[0] === '-') {
                          term = term.slice(1);
                          isNegative = !isNegative;
                      }
                      result = result
                          ? joinLatex([result, serializer.options.multiply, term])
                          : term;
                  }
                  prevWasNumber = true;
              }
              else if (getFunctionName(arg) === POWER &&
                  !isNaN((_a = getNumberValue(getArg(arg, 1))) !== null && _a !== void 0 ? _a : NaN)) {
                  // It's a power and the base is a number...
                  // add a multiply...
                  result = result
                      ? joinLatex([
                          result,
                          serializer.options.multiply,
                          serializer.serialize(arg),
                      ])
                      : serializer.serialize(arg);
                  prevWasNumber = true;
              }
              else {
                  if (getFunctionName(arg) === NEGATE) {
                      arg = getArg(arg, 1);
                      isNegative = !isNegative;
                  }
                  // 2.1 Wrap the term if necessary
                  // (if it's an operator of precedence less than 390)
                  term = serializer.wrap(arg, 390);
                  // 2.2. The terms can be separated by an invisible multiply.
                  if (!result) {
                      // First term
                      result = term;
                  }
                  else {
                      if (prevWasNumber && getFunctionName(arg) === DIVIDE) {
                          // Can't use an invisible multiply if a number
                          // multiplied by a fraction
                          result = joinLatex([result, '\\times', term]);
                      }
                      // Not first term, use invisible multiply
                      else if (!serializer.options.invisibleMultiply) {
                          // Replace, joining the terms correctly
                          // i.e. inserting a space between '\pi' and 'x'
                          result = joinLatex([result, term]);
                      }
                      else {
                          result = joinLatex([
                              result,
                              serializer.options.invisibleMultiply,
                              term,
                          ]);
                      }
                  }
                  prevWasNumber = false;
              }
          }
      }
      // Restore the level
      serializer.level += 1;
      return isNegative ? '-' + result : result;
  }
  function parseFraction(lhs, scanner, _minPrec) {
      var _a, _b, _c, _d;
      if (!scanner.match('\\frac'))
          return [lhs, null];
      const numer = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : MISSING;
      const denom = (_b = scanner.matchRequiredLatexArgument()) !== null && _b !== void 0 ? _b : MISSING;
      if (getFunctionName(numer) === 'PartialDerivative' &&
          (getFunctionName(denom) === 'PartialDerivative' ||
              (getFunctionName(denom) === MULTIPLY &&
                  getFunctionName(getArg(denom, 1)) === 'PartialDerivative'))) {
          // It's a Leibniz notation partial derivative
          // `âˆ‚f(x)/âˆ‚x` or `âˆ‚^2f(x)/âˆ‚xâˆ‚y` or `âˆ‚/âˆ‚x f(x)`
          const degree = (_c = getArg(numer, 3)) !== null && _c !== void 0 ? _c : NOTHING;
          // Expect: getArg(numer, 2) === NOTHING -- no args
          let fn = getArg(numer, 1);
          if (fn === null || fn === NOTHING) {
              fn = (_d = scanner.matchExpression()) !== null && _d !== void 0 ? _d : NOTHING;
          }
          let vars = [];
          if (getFunctionName(denom) === MULTIPLY) {
              // ?/âˆ‚xâˆ‚y
              for (const arg of getTail(denom)) {
                  if (getFunctionHead(arg) === 'PartialDerivative') {
                      const v = getArg(arg, 2);
                      if (v)
                          vars.push(v);
                  }
              }
          }
          else {
              // ?/âˆ‚x
              const v = getArg(denom, 2);
              if (v)
                  vars.push(v);
          }
          if (vars.length > 1) {
              vars = [LIST, ...vars];
          }
          return [
              lhs,
              ['PartialDerivative', fn, vars, degree === NOTHING ? 1 : degree],
          ];
      }
      return [lhs, [DIVIDE, numer, denom]];
  }
  function serializeFraction(serializer, expr) {
      console.assert(getFunctionName(expr) === DIVIDE);
      if (expr === null)
          return '';
      if (getArgCount(expr) === 1)
          return serializer.serialize(getArg(expr, 1));
      const style = getFractionStyle(expr, serializer.level);
      if (style === 'inline-solidus' || style === 'nice-solidus') {
          const numerStr = serializer.wrapShort(getArg(expr, 1));
          const denomStr = serializer.wrapShort(getArg(expr, 2));
          if (style === 'nice-solidus') {
              return `^{${numerStr}}\\!\\!/\\!_{${denomStr}}`;
          }
          return `${numerStr}\\/${denomStr}`;
      }
      else if (style === 'reciprocal') {
          return (serializer.wrap(getArg(expr, 1)) +
              serializer.wrap(getArg(expr, 2)) +
              '^{-1}');
      }
      else if (style === 'factor') {
          return ('\\frac{1}{' +
              serializer.serialize(getArg(expr, 2)) +
              '}' +
              serializer.wrap(getArg(expr, 1)));
      }
      // Quotient (default)
      return ('\\frac{' +
          serializer.serialize(getArg(expr, 1)) +
          '}{' +
          serializer.serialize(getArg(expr, 2)) +
          '}');
  }
  function serializePower(serializer, expr) {
      var _a;
      const arg1 = getArg(expr, 1);
      const arg2 = getArg(expr, 2);
      if (arg2 === null) {
          return serializer.serialize(arg1);
      }
      if (arg1 === null) {
          return '';
      }
      const name = getFunctionName(expr);
      if (name === SQRT || name === ROOT) {
          const style = getRootStyle(expr, serializer.level);
          return serializeRoot(serializer, style, getArg(expr, 1), getArg(expr, 2));
      }
      const val2 = (_a = getNumberValue(arg2)) !== null && _a !== void 0 ? _a : 1;
      if (val2 === -1) {
          return serializer.serialize([DIVIDE, '1', arg1]);
      }
      else if (val2 < 0) {
          return serializer.serialize([DIVIDE, '1', [POWER, arg1, -val2]]);
      }
      else if (getFunctionName(arg2) === DIVIDE) {
          if (getNumberValue(getArg(arg2, 1)) === 1) {
              // It's x^{1/n} -> it's a root
              const style = getRootStyle(expr, serializer.level);
              return serializeRoot(serializer, style, arg1, getArg(arg2, 2));
          }
      }
      else if (getFunctionName(arg2) === POWER) {
          if (getNumberValue(getArg(arg2, 2)) === -1) {
              // It's x^{n^-1} -> it's a root
              const style = getRootStyle(expr, serializer.level);
              return serializeRoot(serializer, style, arg1, getArg(arg2, 1));
          }
      }
      return serializer.wrapShort(arg1) + '^{' + serializer.serialize(arg2) + '}';
  }
  const DEFINITIONS_ARITHMETIC = [
      { name: 'ThreeQuarter', serialize: '\\frac{3}{4}' },
      { name: 'TwoThird', serialize: '\\frac{2}{3}' },
      { name: 'Half', serialize: '\\frac{1}{2}' },
      { name: 'Third', serialize: '\\frac{1}{3}' },
      { name: 'Quarter', serialize: '\\frac{1}{4}' },
      { name: 'CatalanConstant', serialize: 'G' },
      { name: 'GoldenRatio', serialize: '\\varphi' },
      { name: 'EulerGamma', serialize: '\\gamma' },
      { name: 'Degrees', serialize: '\\frac{\\pi}{180}' },
      { name: 'MinusDoublePi', serialize: '-2\\pi' },
      { name: 'MinusPi', serialize: '-\\pi' },
      { name: 'MinusHalfPi', serialize: '-\\frac{\\pi}{2}' },
      { name: 'QuarterPi', serialize: '\\frac{\\pi}{4}' },
      { name: 'ThirdPi', serialize: '\\frac{\\pi}{3}' },
      { name: 'HalfPi', serialize: '\\frac{\\pi}{2}' },
      { name: 'TwoThirdPi', serialize: '\\frac{2\\pi}{3}' },
      { name: 'ThreeQuarterPi', serialize: '\\frac{3\\pi}{4}' },
      { name: 'DoublePi', serialize: '2\\pi' },
      {
          name: 'Complex',
          precedence: 275,
          serialize: (serializer, expr) => {
              // Note: we should not have ['Complex'] functions in canonical expressions
              // but this is just in case...
              const re = getNumberValue(getArg(expr, 1));
              const im = getNumberValue(getArg(expr, 2));
              if (im === 0)
                  return serializer.serialize(getArg(expr, 1));
              const imPart = im === 1
                  ? '\\imaginaryI'
                  : im === -1
                      ? '-\\imaginaryI'
                      : joinLatex([serializer.serialize(getArg(expr, 2)), '\\imaginaryI']);
              if (re === 0)
                  return imPart;
              return joinLatex([serializer.serialize(getArg(expr, 1)), '+', imPart]);
          },
      },
      {
          name: 'Exp',
          serialize: (serializer, expr) => {
              var _a;
              return joinLatex([
                  '\\exponentialE^{',
                  serializer.serialize((_a = getArg(expr, 1)) !== null && _a !== void 0 ? _a : NOTHING),
                  '}',
              ]);
          },
      },
      {
          name: 'Square',
          serialize: (serializer, expr) => serializer.wrapShort(getArg(expr, 1)) + '^2',
      },
      { trigger: { symbol: '\\infty' }, parse: { num: '+Infinity' } },
      {
          name: COMPLEX_INFINITY,
          trigger: { symbol: ['\\tilde', '\\infty'] },
          serialize: '\\tilde\\infty',
      },
      {
          name: COMPLEX_INFINITY,
          trigger: { symbol: ['\\tilde', '<{>', '\\infty', '<}>'] },
          serialize: '\\tilde\\infty',
      },
      { name: PI, trigger: { symbol: '\\pi' } },
      { name: PI, trigger: { symbol: 'Ï€' }, serialize: '\\pi' },
      { name: EXPONENTIAL_E, trigger: { symbol: 'e' }, serialize: 'e' },
      { name: IMAGINARY_UNIT, trigger: { symbol: 'i' }, serialize: '\\imaginaryI' },
      { name: IMAGINARY_UNIT, trigger: { symbol: '\\imaginaryI' } },
      {
          name: ADD,
          trigger: { prefix: '+', infix: '+' },
          parse: parsePlusSign,
          serialize: serializeAdd,
          associativity: 'both',
          precedence: 275,
      },
      {
          name: NEGATE,
          trigger: { prefix: '-' },
          parse: parseMinusSign,
          associativity: 'left',
          precedence: 275,
      },
      {
          name: SUBTRACT,
          trigger: { infix: '-' },
          parse: parseMinusSign,
          associativity: 'both',
          precedence: 275,
      },
      {
          name: 'PlusMinus',
          trigger: { infix: '\\pm' },
          associativity: 'both',
          precedence: 270,
      },
      {
          name: 'MinusPlus',
          trigger: { infix: '\\mp' },
          associativity: 'both',
          precedence: 270,
      },
      {
          name: MULTIPLY,
          trigger: { infix: '\\times' },
          serialize: serializeMultiply,
          associativity: 'both',
          precedence: 390,
      },
      {
          name: MULTIPLY,
          trigger: { infix: '\\cdot' },
          serialize: serializeMultiply,
          associativity: 'both',
          precedence: 390,
      },
      {
          name: MULTIPLY,
          trigger: { infix: '*' },
          serialize: serializeMultiply,
          associativity: 'both',
          precedence: 390,
      },
      {
          name: DIVIDE,
          trigger: '\\frac',
          // For \frac specifically, not for \div, etc..
          // handles Leibnitz notation for partial derivatives
          parse: parseFraction,
          serialize: serializeFraction,
          requiredLatexArg: 2,
      },
      {
          name: DIVIDE,
          trigger: { infix: '\\/' },
          serialize: serializeFraction,
          associativity: 'non',
          precedence: 660, // ??? MathML has 265, but it's wrong.
          // It has to be at least higher than multiply
          // e.g. `1/2+3*x` -> `1/2 + 3*x` , not `1/(2+3*x)`
      },
      {
          name: DIVIDE,
          trigger: { infix: '/' },
          serialize: serializeFraction,
          associativity: 'non',
          precedence: 660,
      },
      {
          name: DIVIDE,
          trigger: { infix: '\\div' },
          serialize: serializeFraction,
          associativity: 'non',
          precedence: 660, // ??? according to MathML
      },
      {
          name: POWER,
          trigger: { infix: '^' },
          associativity: 'non',
          precedence: 720,
          serialize: serializePower,
      },
      {
          name: POWER,
          trigger: { infix: ['*', '*'] },
          associativity: 'non',
          precedence: 720,
          serialize: serializePower,
      },
      {
          name: SQRT,
          trigger: '\\sqrt',
          optionalLatexArg: 1,
          requiredLatexArg: 1,
          parse: parseRoot,
          serialize: serializePower,
      },
      {
          name: ROOT,
          trigger: '\\sqrt',
          optionalLatexArg: 1,
          requiredLatexArg: 1,
          parse: parseRoot,
      },
      {
          /** If the argument is a vector */
          /** @todo: domain check */
          name: 'Norm',
          trigger: { matchfix: '\\lVert' },
          closeFence: '\\rVert',
      },
      {
          /** If the argument is a vector */
          /** @todo: domain check */
          name: 'Norm',
          trigger: { matchfix: '\\|' },
          closeFence: '\\|',
      },
      {
          /** If the argument is a vector */
          /** @todo: domain check */
          name: 'Norm',
          trigger: { matchfix: ['|', '|'] },
          closeFence: ['|', '|'],
      },
      {
          /** Could be the determinant if the argument is a matrix */
          /** @todo: domain check */
          /** If a literal matrix, the `serialize` should be custom, the parens are
           * replaced with bars */
          name: 'Abs',
          trigger: { matchfix: '|' },
          closeFence: '|',
      },
      {
          name: 'Abs',
          trigger: { matchfix: '\\lvert' },
          closeFence: '\\rvert',
      },
      {
          name: 'Factorial',
          trigger: { postfix: '!' },
          precedence: 810,
      },
      {
          name: 'Factorial2',
          trigger: { postfix: ['!', '!'] },
          precedence: 810,
      },
      {
          name: 'Lcm',
          trigger: { symbol: ['\\operatorname', '<{>', 'l', 'c', 'm', '<}>'] },
      },
      {
          name: 'Gcd',
          trigger: { symbol: ['\\operatorname', '<{>', 'g', 'c', 'd', '<}>'] },
      },
      {
          name: 'Ceil',
          trigger: { symbol: ['\\operatorname', '<{>', 'c', 'e', 'i', 'l', '<}>'] },
      },
      {
          name: 'Floor',
          trigger: {
              symbol: ['\\operatorname', '<{>', 'f', 'l', 'o', 'o', 'r', '<}>'],
          },
      },
      {
          name: 'Round',
          trigger: {
              symbol: ['\\operatorname', '<{>', 'r', 'o', 'u', 'n', 'd', '<}>'],
          },
      },
      {
          name: 'Sign',
          trigger: {
              // As per ISO 80000-2, "signum" is 'sgn'
              symbol: ['\\operatorname', '<{>', 's', 'g', 'n', '<}>'],
          },
      },
  ];

  /**
   * Trigonometric functions have some special conventions that require a
   * custom parser: they can be followed by a "-1" superscript indicating
   * that the inversion function should be used, i.e. "\sin^{-1}" for "arcsin".
   *
   */
  function parseTrig(_lhs, scanner, _minPrec) {
      var _a;
      const op = scanner.next();
      let isInverse = false;
      let primeLevel = 0;
      scanner.skipSpace();
      if (scanner.match('^')) {
          scanner.skipSpace();
          if (scanner.match('<{>')) {
              scanner.skipSpace();
              // There's a superscript..., parse it.
              if (scanner.match('-') && scanner.match('1')) {
                  isInverse = true;
              }
              do {
                  if (scanner.match('\\doubleprime')) {
                      primeLevel += 2;
                  }
                  if (scanner.match('\\prime')) {
                      primeLevel += 1;
                  }
                  if (scanner.match("'")) {
                      primeLevel += 1;
                  }
              } while (!scanner.match('<}>') && !scanner.atEnd);
          }
          let done = false;
          while (!done) {
              scanner.skipSpace();
              if (scanner.match('\\doubleprime')) {
                  primeLevel += 2;
              }
              else if (scanner.match('\\prime')) {
                  primeLevel += 1;
              }
              else if (scanner.match("'")) {
                  primeLevel += 1;
              }
              else {
                  done = true;
              }
          }
      }
      // Note: names as per NIST-DLMF
      let head = (_a = {
          '\\arcsin': 'Arcsin',
          '\\arccos': 'Arccos',
          '\\arctan': 'Arctan',
          '\\arctg': 'Arctan',
          '\\arcctg': 'Arctan',
          '\\arcsec': 'Arcsec',
          '\\arccsc': ' Arccsc',
          '\\arsinh': 'Arsinh',
          '\\arcosh': 'Arcosh',
          '\\artanh': 'Artanh',
          '\\arcsech': 'Arcsech',
          '\\arccsch': 'Arcsch',
          // '\\arg',
          '\\ch': 'Cosh',
          '\\cos': 'Cos',
          '\\cosec': 'Csc',
          '\\cosh': 'Csch',
          '\\cot': 'Cot',
          '\\cotg': 'Cot',
          '\\coth': 'Coth',
          '\\csc': 'Csc',
          '\\ctg': 'Cot',
          '\\cth': 'Coth',
          '\\sec': 'Sec',
          '\\sin': 'Sin',
          '\\sinh': 'Sinh',
          '\\sh': 'Sinh',
          '\\tan': 'Tan',
          '\\tanh': 'Tanh',
          '\\tg': 'Tan',
          '\\th': 'Tanh',
      }[op]) !== null && _a !== void 0 ? _a : op;
      if (isInverse) {
          head = [INVERSE_FUNCTION, head];
      }
      if (primeLevel >= 1) {
          head = [DERIVATIVE, primeLevel, head];
      }
      const args = scanner.matchArguments('implicit');
      if (args === null) {
          return [null, head];
      }
      return [null, [head, ...args]];
  }
  const DEFINITIONS_TRIGONOMETRY = [
      {
          name: 'Arcsin',
          trigger: '\\arcsin',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arccos',
          trigger: '\\arccos',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arctan',
          trigger: '\\arctan',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arctan',
          trigger: '\\arctg',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arccot',
          trigger: '\\arcctg',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arcsec',
          trigger: '\\arcsec',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arccsc',
          trigger: '\\arccsc',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arsinh',
          trigger: '\\arsinh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arcosh',
          trigger: '\\arcosh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Artanh',
          trigger: '\\artanh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arsech',
          trigger: '\\arsech',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Arcsch',
          trigger: '\\arcsch',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cosh',
          trigger: '\\ch',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cosec',
          trigger: '\\cosec',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cosh',
          trigger: '\\cosh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cot',
          trigger: '\\cot',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cot',
          trigger: '\\cotg',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Coth',
          trigger: '\\coth',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Csc',
          trigger: '\\csc',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cot',
          trigger: '\\ctg',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Coth',
          trigger: '\\cth',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Sec',
          trigger: '\\sec',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Sinh',
          trigger: '\\sinh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Sinh',
          trigger: '\\sh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Tan',
          trigger: '\\tan',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Tan',
          trigger: '\\tg',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Tanh',
          trigger: '\\tanh',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Tanh',
          trigger: '\\th',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Cos',
          trigger: '\\cos',
          arguments: 'implicit',
          parse: parseTrig,
      },
      {
          name: 'Sin',
          trigger: '\\sin',
          arguments: 'implicit',
          parse: parseTrig,
      },
  ];

  const DEFINITIONS_ALGEBRA = [
      {
          name: 'To',
          trigger: { infix: '\\to' },
          precedence: 270, // MathML rightwards arrow
      },
  ];

  const DEFINITIONS_SETS = [
      // Sets
      { trigger: { symbol: '\\N' }, parse: 'NaturalNumber' },
      { trigger: { symbol: '\\Z' }, parse: 'Integer' },
      { trigger: { symbol: '\\Q' }, parse: 'RationalNumber' },
      {
          trigger: { symbol: ['\\mathbb', '<{>', 'A', '<}>'] },
          parse: 'AlgebraicNumber',
      },
      { trigger: { symbol: '\\R' }, parse: 'RealNumber' },
      { trigger: { symbol: '\\C' }, parse: 'ComplexNumber' },
      { trigger: { symbol: '\\varnothing' }, parse: 'EmptySet' },
      { trigger: { symbol: '\\emptyset' }, parse: 'EmptySet' },
      {
          name: 'Complement',
          trigger: { infix: '\\complement' },
          precedence: 240,
      },
      {
          name: 'Element',
          trigger: { infix: '\\in' },
          precedence: 240,
      },
      {
          name: 'Intersection',
          trigger: { infix: '\\Cap' },
          precedence: 350,
      },
      {
          name: 'NotElement',
          trigger: { infix: '\\notin' },
          precedence: 240,
      },
      {
          name: 'SetMinus',
          trigger: { infix: '\\setminus' },
          precedence: 650,
      },
      {
          name: 'SubsetEqual',
          trigger: { infix: '\\subseteq' },
          precedence: 240,
      },
      {
          name: 'SymmetricDifference',
          trigger: { infix: '\\triangle' },
          precedence: 260,
      },
      {
          name: 'Union',
          trigger: { infix: '\\cup' },
          precedence: 350,
      },
      {
          name: 'Contains',
          trigger: { infix: '\\ni' },
          associativity: 'right',
          precedence: 160, // As per MathML, lower precedence
      },
      {
          name: 'Subset',
          trigger: { infix: '\\subset' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SquareSubset',
          trigger: { infix: '\\sqsubset' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'SquareSubsetEqual',
          trigger: { infix: '\\sqsubseteq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'Superset',
          trigger: { infix: '\\supset' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SquareSuperset',
          trigger: { infix: '\\sqsupset' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'SquareSupersetEqual',
          trigger: { infix: '\\sqsupseteq' },
          associativity: 'right',
          precedence: 265,
      },
      {
          name: 'NotSubset',
          trigger: { infix: '\\nsubset' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'NotSuperset',
          trigger: { infix: '\\nsupset' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SupersetEqual',
          trigger: { infix: '\\supseteq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'NotSubsetNotEqual',
          trigger: { infix: '\\nsubseteq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'NotSupersetNotEqual',
          trigger: { infix: '\\nsupseteq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SubsetNotEqual',
          trigger: { infix: '\\subsetneq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SubsetNotEqual',
          trigger: { infix: '\\varsupsetneqq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SupersetNotEqual',
          trigger: { infix: '\\supsetneq' },
          associativity: 'right',
          precedence: 240,
      },
      {
          name: 'SupersetNotEqual',
          trigger: { infix: '\\varsupsetneq' },
          associativity: 'right',
          precedence: 240,
      },
  ];

  function parseIntegral(lhs, scanner, _minPrec) {
      if (!scanner.match('\\int'))
          return [lhs, null];
      // There could be some superscript and subscripts
      let sup = NOTHING;
      let sub = NOTHING;
      let done = false;
      while (!done) {
          scanner.skipSpace();
          if (scanner.match('_')) {
              sub = scanner.matchRequiredLatexArgument();
          }
          else if (scanner.match('^')) {
              sup = scanner.matchRequiredLatexArgument();
          }
          else {
              done = true;
          }
      }
      // @todo: that's not quite right: the integral of the function is denoted
      // by a `...dx` pattern, e.g. `\int \sin(x)dx`
      const fn = scanner.matchBalancedExpression('<{>', '<}>');
      return [lhs, ['Integral', fn !== null && fn !== void 0 ? fn : '', sup !== null && sup !== void 0 ? sup : NOTHING, sub !== null && sub !== void 0 ? sub : NOTHING]];
  }
  function serializeIntegral(_serializer, _expr) {
      return '';
  }
  const DEFINITIONS_CALCULUS = [
      {
          trigger: { symbol: '\\int' },
          parse: parseIntegral,
          serialize: serializeIntegral,
      },
  ];

  const DEFINITIONS_SYMBOLS = [
      // Greek
      { trigger: { symbol: '\\alpha' }, parse: '\u03b1' },
      { trigger: { symbol: '\\beta' }, parse: '\u03b2' },
      { trigger: { symbol: '\\gamma' }, parse: '\u03b3' },
      { trigger: { symbol: '\\delta' }, parse: '\u03b4' },
      { trigger: { symbol: '\\epsilon' }, parse: '\u03f5' },
      { trigger: { symbol: '\\varepsilon' }, parse: '\u03b5' },
      { trigger: { symbol: '\\zeta' }, parse: '\u03b6' },
      { trigger: { symbol: '\\eta' }, parse: '\u03b7' },
      { trigger: { symbol: '\\theta' }, parse: '\u03b8' },
      { trigger: { symbol: '\\vartheta' }, parse: '\u03d1' },
      { trigger: { symbol: '\\iota' }, parse: '\u03b9' },
      { trigger: { symbol: '\\kappa' }, parse: '\u03ba' },
      { trigger: { symbol: '\\varkappa' }, parse: '\u03f0' },
      { trigger: { symbol: '\\lambda' }, parse: '\u03bb' },
      { trigger: { symbol: '\\mu' }, parse: '\u03bc' },
      { trigger: { symbol: '\\nu' }, parse: '\u03bd' },
      { trigger: { symbol: '\\xi' }, parse: '\u03be' },
      { trigger: { symbol: '\\omicron' }, parse: '\u03bf' },
      // { trigger: { symbol: '\\pi' }, parse: '\u03c0' },
      { trigger: { symbol: '\\varpi' }, parse: '\u03d6' },
      { trigger: { symbol: '\\rho' }, parse: '\u03c1' },
      { trigger: { symbol: '\\varrho' }, parse: '\u03f1' },
      { trigger: { symbol: '\\sigma' }, parse: '\u03c3' },
      { trigger: { symbol: '\\varsigma' }, parse: '\u03c2' },
      { trigger: { symbol: '\\tau' }, parse: '\u03c4' },
      { trigger: { symbol: '\\phi' }, parse: '\u03d5' },
      { trigger: { symbol: '\\varphi' }, parse: '\u03c6' },
      { trigger: { symbol: '\\upsilon' }, parse: '\u03c5' },
      { trigger: { symbol: '\\chi' }, parse: '\u03c7' },
      { trigger: { symbol: '\\psi' }, parse: '\u03c8' },
      { trigger: { symbol: '\\omega' }, parse: '\u03c9' },
      { trigger: { symbol: '\\Gamma' }, parse: '\u0393' },
      { trigger: { symbol: '\\Delta' }, parse: '\u0394' },
      { trigger: { symbol: '\\Theta' }, parse: '\u0398' },
      { trigger: { symbol: '\\Lambda' }, parse: '\u039b' },
      { trigger: { symbol: '\\Xi' }, parse: '\u039e' },
      { trigger: { symbol: '\\Pi' }, parse: '\u03a0' },
      { trigger: { symbol: '\\Sigma' }, parse: '\u03a3' },
      { trigger: { symbol: '\\Upsilon' }, parse: '\u03a5' },
      { trigger: { symbol: '\\Phi' }, parse: '\u03a6' },
      { trigger: { symbol: '\\Psi' }, parse: '\u03a8' },
      { trigger: { symbol: '\\Omega' }, parse: '\u03a9' },
      { trigger: { symbol: '\\digamma' }, parse: '\u03dd' },
      // Hebrew
      { trigger: { symbol: '\\aleph' }, parse: '\u2135' },
      { trigger: { symbol: '\\beth' }, parse: '\u2136' },
      { trigger: { symbol: '\\daleth' }, parse: '\u2138' },
      { trigger: { symbol: '\\gimel' }, parse: '\u2137' },
      // Letter-like
      { trigger: { symbol: '\\Finv' }, parse: '\u2132' },
      { trigger: { symbol: '\\Game' }, parse: '\u2141' },
      { trigger: { symbol: '\\wp' }, parse: '\u2118' },
      { trigger: { symbol: '\\eth' }, parse: '\u00f0' },
      { trigger: { symbol: '\\mho' }, parse: '\u2127' },
      // Symbols
      { trigger: { symbol: '\\clubsuit' }, parse: '\u2663' },
      { trigger: { symbol: '\\heartsuit' }, parse: '\u2661' },
      { trigger: { symbol: '\\spadesuit' }, parse: '\u2660' },
      { trigger: { symbol: '\\diamondsuit' }, parse: '\u2662' },
      { trigger: { symbol: '\\sharp' }, parse: '\u266f' },
      { trigger: { symbol: '\\flat' }, parse: '\u266d' },
      { trigger: { symbol: '\\natural' }, parse: '\u266e' },
  ];

  function triggerLength(trigger) {
      if (Array.isArray(trigger))
          return trigger.length;
      return 1;
  }
  function triggerString(trigger) {
      return tokensToString(trigger);
  }
  // function hasDef(dic: LatexDictionary, latex: string): boolean {
  //     let result = false;
  //     dic.forEach((x) => {
  //         if (x.trigger) {
  //             if (typeof x.trigger === 'string' && x.trigger === latex) {
  //                 result = true;
  //             } else if (
  //                 typeof x.trigger !== 'string' &&
  //                 (triggerString(x.trigger.infix) === latex ||
  //                     triggerString(x.trigger.postfix) === latex ||
  //                     triggerString(x.trigger.symbol) === latex ||
  //                     triggerString(x.trigger.prefix) === latex ||
  //                     triggerString(x.trigger.matchfix) === latex ||
  //                     triggerString(x.closeFence) === latex)
  //             ) {
  //                 result = true;
  //             }
  //         }
  //     });
  //     return result;
  // }
  function indexLatexDictionary(dic, onError) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
      const result = {
          lookahead: 1,
          name: new Map(),
          prefix: [],
          infix: [],
          postfix: [],
          matchfix: [],
          superfix: [],
          subfix: [],
          symbol: [],
          environment: new Map(),
      };
      for (const record of dic) {
          if (record.parse === undefined) {
              // By default, when a latex string triggers, the generated
              // output is the name of this record, i.e. MULTIPLY
              record.parse = record.name;
          }
          // If the trigger is a string, it's a shortcut for a symbol
          if (typeof record.trigger === 'string') {
              record.trigger = { symbol: record.trigger };
          }
          if (typeof record.serialize === 'string') {
              if (((_a = record.trigger) === null || _a === void 0 ? void 0 : _a.symbol) !== undefined) {
                  if (/#[0-9]/.test(record.serialize)) {
                      onError({ code: 'unexpected-argument', arg: record.name });
                  }
              }
          }
          if (record.serialize === undefined) {
              // By default, when latex is serialized for this record,
              // it is the same as the trigger (note there could be multiple
              // triggers, so we just pick one)
              if (((_b = record.trigger) === null || _b === void 0 ? void 0 : _b.postfix) !== undefined) {
                  record.serialize = '#1' + triggerString(record.trigger.postfix);
              }
              else if (((_c = record.trigger) === null || _c === void 0 ? void 0 : _c.prefix) !== undefined) {
                  record.serialize = triggerString(record.trigger.prefix) + '#1';
              }
              else if (((_d = record.trigger) === null || _d === void 0 ? void 0 : _d.infix) !== undefined) {
                  record.serialize = '#1' + triggerString(record.trigger.infix) + '#2';
              }
              else if (((_e = record.trigger) === null || _e === void 0 ? void 0 : _e.symbol) !== undefined) {
                  record.serialize = triggerString(record.trigger.symbol);
              }
              else if (((_f = record.trigger) === null || _f === void 0 ? void 0 : _f.superfix) !== undefined) {
                  record.serialize =
                      '#1^{' + triggerString((_g = record.trigger) === null || _g === void 0 ? void 0 : _g.superfix) + '}';
              }
              else if (((_h = record.trigger) === null || _h === void 0 ? void 0 : _h.subfix) !== undefined) {
                  record.serialize = '#1_{' + triggerString((_j = record.trigger) === null || _j === void 0 ? void 0 : _j.subfix) + '}';
              }
              else {
                  record.serialize = '';
              }
          }
          if (((_k = record.trigger) === null || _k === void 0 ? void 0 : _k.infix) !== undefined) {
              if (record.precedence === undefined) {
                  onError({
                      code: 'syntax-error',
                      arg: 'Infix operators require a precedence',
                  });
              }
              if (!record.associativity) {
                  record.associativity = 'non';
              }
          }
          if (((_l = record.trigger) === null || _l === void 0 ? void 0 : _l.symbol) !== undefined) {
              record.arguments = (_m = record.arguments) !== null && _m !== void 0 ? _m : '';
              record.optionalLatexArg = (_o = record.optionalLatexArg) !== null && _o !== void 0 ? _o : 0;
              record.requiredLatexArg = (_p = record.requiredLatexArg) !== null && _p !== void 0 ? _p : 0;
          }
          if (((_q = record.trigger) === null || _q === void 0 ? void 0 : _q.matchfix) !== undefined) {
              if (record.parse !== 'function' && !record.closeFence) {
                  onError({
                      code: 'syntax-error',
                      arg: 'Matchfix operators require a close fence or a custom parse function',
                  });
              }
          }
          if (record.trigger !== undefined) {
              [
                  'infix',
                  'prefix',
                  'postfix',
                  'symbol',
                  'matchfix',
                  'superfix',
                  'subfix',
              ].forEach((x) => {
                  if (record.trigger[x]) {
                      const n = triggerLength(record.trigger[x]);
                      result.lookahead = Math.max(result.lookahead, n);
                      if (result[x][n] === undefined) {
                          result[x][n] = new Map();
                      }
                      result[x][n].set(triggerString(record.trigger[x]), record);
                  }
              });
              if (record.trigger.environment !== undefined) {
                  result.environment.set(record.trigger.environment, record);
              }
          }
          if (record.name !== undefined) {
              result.name.set(triggerString(record.name), record);
          }
          else if (typeof record.parse === 'string') {
              result.name.set(record.parse, record);
          }
          if (record.trigger === undefined && !record.name) {
              // A trigger OR a name is required.
              // The trigger maps latex -> json
              // The name maps json -> latex
              onError({
                  code: 'syntax-error',
                  arg: 'Need at least a trigger or a name',
              });
          }
      }
      return result;
  }
  // left-operators, supfix/subfix:
  // subscript
  // sub-plus     super-plus
  // sub-minus    super-minus
  // sub-star     super-star
  //              super-dagger
  // over-bar     under-bar
  // over-vector
  // over-tilde
  // over-hat
  // over-dot
  // overscript   underscript
  // matchfix:
  // angle-brack
  // floor
  // ceiling
  // infix operators:
  //->   rule
  // :>   rule-delayed
  // ==   eq
  // !=   ne
  // https://reference.wolfram.com/language/tutorial/OperatorInputForms.html
  const DEFAULT_LATEX_DICTIONARY = {
      algebra: DEFINITIONS_ALGEBRA,
      arithmetic: DEFINITIONS_ARITHMETIC,
      calculus: DEFINITIONS_CALCULUS,
      core: DEFINITIONS_CORE,
      inequalities: DEFINITIONS_INEQUALITIES,
      other: DEFINITIONS_OTHERS,
      physics: [
          {
              name: 'mu-0',
              trigger: { symbol: ['\\mu', '_', '0'] },
          },
      ],
      sets: DEFINITIONS_SETS,
      symbols: DEFINITIONS_SYMBOLS,
      trigonometry: DEFINITIONS_TRIGONOMETRY,
  };
  // {
  //     const defaultDic = getDefaultLatexDictionary();
  //     let i = 0;
  //     for (const x of Object.keys(FUNCTIONS)) {
  //         if (x.startsWith('\\') && !hasDef(defaultDic, x)) {
  //             i++;
  //             console.log(i + ' No def for function ' + x);
  //         }
  //     }
  //     for (const x of Object.keys(MATH_SYMBOLS)) {
  //         if (x.startsWith('\\') && !hasDef(defaultDic, x)) {
  //             i++;
  //             console.log(i + ' No def for symbol ' + x);
  //         }
  //     }
  // }
  // {
  //     const defaultLatexDic = indexLatexDictionary(
  //         getDefaultLatexDictionary('all'),
  //         () => {
  //             return;
  //         }
  //     );
  //     const defaultDic = getDefaultDictionary('all');
  //     let i = 0;
  //     Array.from(defaultLatexDic.name.keys()).forEach((x) => {
  //         if (!findInDictionary(defaultDic, x)) {
  //             console.log(Number(i++).toString() + ' No entry for ' + x);
  //         }
  //     });
  // }

  const DEFAULT_LATEX_NUMBER_OPTIONS = {
      precision: 15,
      positiveInfinity: '\\infty',
      negativeInfinity: '-\\infty',
      notANumber: '\\operatorname{NaN}',
      decimalMarker: '.',
      groupSeparator: ',',
      exponentProduct: '\\cdot',
      beginExponentMarker: '10^{',
      endExponentMarker: '}',
      notation: 'auto',
      truncationMarker: '\\ldots',
      beginRepeatingDigits: '\\overline{',
      endRepeatingDigits: '}',
      imaginaryNumber: '\\imaginaryI',
  };
  const DEFAULT_PARSE_LATEX_OPTIONS = {
      invisibleOperator: MULTIPLY,
      skipSpace: true,
      parseArgumentsOfUnknownLatexCommands: true,
      parseNumbers: true,
      promoteUnknownSymbols: /^[a-zA-Z]$/,
      promoteUnknownFunctions: /^[fg]$/,
      ignoreCommands: [
          '\\displaystyle',
          '\\!',
          '\\:',
          '\\enskip',
          '\\quad',
          '\\,',
          '\\;',
          '\\enspace',
          '\\qquad',
          '\\selectfont',
          '\\tiny',
          '\\scriptsize',
          '\\footnotesize',
          '\\small',
          '\\normalsize',
          '\\large',
          '\\Large',
          '\\LARGE',
          '\\huge',
          '\\Huge',
      ],
      idempotentCommands: [
          '\\left',
          '\\right',
          '\\mleft',
          '\\mright',
          '\\middle',
          '\\bigl',
          '\\bigm',
          '\\bigr',
          '\\Bigl',
          '\\Bigm',
          '\\Bigr',
          '\\biggl',
          '\\biggm',
          '\\biggr',
          '\\Biggl',
          '\\Biggm',
          '\\Biggr',
      ],
      invisiblePlusOperator: ADD,
      preserveLatex: false,
  };
  const DEFAULT_SERIALIZE_LATEX_OPTIONS = {
      invisibleMultiply: '',
      invisiblePlus: '',
      // invisibleApply: '',
      multiply: '\\times',
      // openGroup: '(',
      // closeGroup: ')',
      // divide: '\\frac{#1}{#2}',
      // subtract: '#1-#2',
      // add: '#1+#2',
      // negate: '-#1',
      // squareRoot: '\\sqrt{#1}',
      // nthRoot: '\\sqrt[#2]{#1}',
  };
  /**
   * Replace '#1', '#2' in the latex template stings with the corresponding
   * values from `replacement`, in a Latex syntax safe manner (i.e. inserting spaces when needed)
   */
  function replaceLatex(template, replacement) {
      var _a;
      console.assert(typeof template === 'string');
      console.assert(template.length > 0);
      let result = template;
      for (let i = 0; i < replacement.length; i++) {
          let s = (_a = replacement[i]) !== null && _a !== void 0 ? _a : '';
          if (/[a-zA-Z*]/.test(s[0])) {
              const m = result.match(new RegExp('(.*)#' + Number(i + 1).toString()));
              if (m && /\\[a-zA-Z*]+/.test(m[1])) {
                  s = ' ' + s;
              }
          }
          result = result.replace('#' + Number(i + 1).toString(), s);
      }
      return result;
  }

  class Scanner {
      constructor(tokens, options, dictionary, onError) {
          this.index = 0;
          this.options = {
              ...DEFAULT_LATEX_NUMBER_OPTIONS,
              ...DEFAULT_PARSE_LATEX_OPTIONS,
              ...options,
          };
          this.tokens = tokens;
          this.onError = (err) => {
              return onError({
                  ...err,
                  before: this.latexBefore(),
                  after: this.latexAfter(),
              });
          };
          this.dictionary = dictionary;
          let def;
          this.invisibleOperatorPrecedence = 0;
          if (this.options.invisibleOperator) {
              def = this.dictionary.name.get(this.options.invisibleOperator);
              if (def === undefined) {
                  onError({
                      code: 'unknown-operator',
                      arg: 'invisible operator ' + this.options.invisibleOperator,
                  });
              }
              else if (def.precedence === undefined) {
                  onError({
                      code: 'expected-operator',
                      arg: 'invisible operator ' + this.options.invisibleOperator,
                  });
              }
              else {
                  this.invisibleOperatorPrecedence = def.precedence;
              }
          }
      }
      clone(start, end) {
          return new Scanner(this.tokens.slice(start, end), this.options, this.dictionary, this.onError);
      }
      balancedClone(open, close, silentError = true) {
          if (!this.matchAll(open)) {
              if (!silentError) {
                  this.onError({
                      code: 'syntax-error',
                      arg: 'Expected ' + tokensToString(open),
                  });
              }
              return null;
          }
          const start = this.index;
          let end = start;
          let level = 1;
          while (!this.atEnd && level !== 0) {
              this.skipSpace();
              // In case of ambiguity, we prioritize close fence over open,
              // e.g. `|a|+b+|c|` -> `(|a|)+b+(|c|)`
              // So we check *first* if it's a closefence, before trying to
              // match an expression which would interpret an open fence
              end = this.index;
              if (this.matchAll(close)) {
                  level -= 1;
              }
              else if (this.matchAll(open)) {
                  level += 1;
              }
              else {
                  this.next();
              }
          }
          if (level !== 0) {
              if (!silentError) {
                  this.onError({
                      code: 'unbalanced-symbols',
                      arg: tokensToString(open) + tokensToString(close),
                  });
              }
              this.index = start;
              return null;
          }
          return this.clone(start, end);
      }
      get atEnd() {
          return this.index >= this.tokens.length;
      }
      get peek() {
          return this.tokens[this.index];
      }
      latex(start, end) {
          return tokensToString(this.tokens.slice(start, end));
      }
      latexAhead(n) {
          return tokensToString(this.tokens.slice(this.index, this.index + n));
      }
      latexBefore() {
          return this.latex(0, this.index);
      }
      latexAfter() {
          return this.latex(this.index);
      }
      /**
       * Return at most `maxLookahead` strings made from the tokens
       * ahead.
       *
       * The index in the returned array correspond to the number of tokens.
       * Note that since a token can be longer than one char ('\\pi', but also
       * some astral plane unicode characters), the length of the string
       * does not match that index. However, knowing the index is important
       * to know by how many tokens to advance.
       *
       */
      lookAhead() {
          let n = Math.min(this.dictionary.lookahead, this.tokens.length - this.index);
          const result = [];
          while (n > 0) {
              result[n] = this.latexAhead(n--);
          }
          return result;
      }
      peekDefinition(kind) {
          let defs;
          if (kind === 'operator') {
              defs = this.lookAhead().map((x, n) => {
                  var _a, _b, _c, _d, _e;
                  return (_d = (_b = (_a = this.dictionary.infix[n]) === null || _a === void 0 ? void 0 : _a.get(x)) !== null && _b !== void 0 ? _b : (_c = this.dictionary.postfix[n]) === null || _c === void 0 ? void 0 : _c.get(x)) !== null && _d !== void 0 ? _d : (_e = this.dictionary.prefix[n]) === null || _e === void 0 ? void 0 : _e.get(x);
              });
          }
          else {
              defs = this.lookAhead().map((x, n) => { var _a; return (_a = this.dictionary[kind][n]) === null || _a === void 0 ? void 0 : _a.get(x); });
          }
          for (let i = defs.length; i > 0; i--) {
              if (defs[i] !== undefined)
                  return [defs[i], i];
          }
          return [null, 0];
      }
      next() {
          return this.tokens[this.index++];
      }
      skipSpace() {
          // Check if the have a `{}` token sequence.
          // Those are used in Latex to force an invisible separation between commands
          if (!this.atEnd &&
              this.peek === '<{>' &&
              this.tokens[this.index + 1] === '<}>') {
              this.index += 2;
              this.skipSpace();
              return true;
          }
          let result = false;
          // Check if we have an ignorable command (e.g. \displaystyle and other
          // purely presentational commands)
          while (!this.atEnd &&
              (this.options.ignoreCommands.includes(this.peek) ||
                  this.options.idempotentCommands.includes(this.peek))) {
              this.index += 1;
              this.skipSpace();
              result = true;
          }
          if (!this.options.skipSpace)
              return false;
          while (this.match('<space>'))
              result = true;
          if (result)
              this.skipSpace();
          return result;
      }
      match(target) {
          if (this.tokens[this.index] === target) {
              this.index++;
              return true;
          }
          return false;
      }
      matchAll(target) {
          let matched = true;
          if (typeof target === 'string') {
              target = [target];
          }
          let i = 0;
          do {
              matched = this.tokens[this.index + i] === target[i++];
          } while (matched && i < target.length);
          if (matched) {
              this.index += i;
          }
          return matched;
      }
      matchAny(targets) {
          if (targets.includes(this.tokens[this.index])) {
              return this.tokens[this.index++];
          }
          return '';
      }
      matchWhile(targets) {
          const result = [];
          while (targets.includes(this.tokens[this.index])) {
              result.push(this.tokens[this.index++]);
          }
          return result;
      }
      matchSign() {
          let isNegative = false;
          let done = false;
          while (!done) {
              if (this.skipSpace()) {
                  done = false;
              }
              else if (this.match('-')) {
                  isNegative = !isNegative;
                  done = false;
              }
              else if (this.match('+')) {
                  done = false;
              }
              else {
                  done = true;
              }
          }
          return isNegative ? '-' : '+';
      }
      matchDecimalDigits() {
          let result = '';
          let done = false;
          while (!done) {
              result += this.matchWhile([
                  '0',
                  '1',
                  '2',
                  '3',
                  '4',
                  '5',
                  '6',
                  '7',
                  '8',
                  '9',
              ]).join('');
              done = true;
              if (this.options.groupSeparator) {
                  const savedIndex = this.index;
                  if (this.match(this.options.groupSeparator)) {
                      if (/[0-9]/.test(this.peek)) {
                          done = false;
                      }
                      else {
                          this.index = savedIndex;
                      }
                  }
              }
          }
          return result;
      }
      matchSignedInteger() {
          const savedIndex = this.index;
          const sign = this.matchSign();
          const result = this.matchDecimalDigits();
          if (result)
              return (sign === '-' ? '-' : '') + result;
          this.index = savedIndex;
          return '';
      }
      matchExponent() {
          const savedIndex = this.index;
          let result = '';
          if (this.matchAny(['e', 'E', 'd', 'D'])) {
              const exponent = this.matchSignedInteger();
              if (exponent) {
                  result = 'e' + exponent;
              }
          }
          if (result)
              return result;
          if (this.match('\\times')) {
              this.skipSpace();
              if (this.match('1') && this.match('0') && this.match('^')) {
                  if (/[0-9]/.test(this.peek)) {
                      return 'e' + this.next();
                  }
                  if (this.match('<{>')) {
                      this.skipSpace();
                      const exponent = this.matchSignedInteger();
                      this.skipSpace();
                      if (this.match('<}>') && exponent) {
                          return 'e' + exponent;
                      }
                  }
              }
          }
          this.index = savedIndex;
          return '';
      }
      matchNumber() {
          var _a, _b;
          if (!this.options.parseNumbers)
              return '';
          const savedIndex = this.index;
          const sign = this.matchSign();
          let result = this.matchDecimalDigits();
          if (!result) {
              this.index = savedIndex;
              return '';
          }
          result = (sign === '-' ? '-' : '') + result;
          let hasDecimalMarker = false;
          let hasExponent = false;
          if (this.match((_a = this.options.decimalMarker) !== null && _a !== void 0 ? _a : '')) {
              hasDecimalMarker = true;
              result += '.' + ((_b = this.matchDecimalDigits()) !== null && _b !== void 0 ? _b : '0');
          }
          const exponent = this.matchExponent();
          if (exponent)
              hasExponent = true;
          if (result) {
              // If the number has more than about 10 significant digits, use a Decimal or BigInt
              if (result.length + exponent.length > 12) {
                  if (hasDecimalMarker || hasExponent) {
                      return result + exponent + 'd'; // Decimal number
                  }
                  else {
                      return result + 'n'; // BigInt
                  }
              }
              return result + exponent;
          }
          this.index = savedIndex;
          return '';
      }
      matchOperator(kind, lhs = null, minPrec = 0) {
          const [def, n] = this.peekDefinition(kind);
          if (def === null)
              return null;
          if (typeof def.parse === 'function') {
              // Custom parser found
              let rhs = null;
              [lhs, rhs] = def.parse(lhs, this, minPrec);
              if (rhs === null)
                  return null;
              return this.applyInvisibleOperator(lhs, rhs);
          }
          let prec = def.precedence;
          if (prec === undefined || prec < minPrec)
              return null;
          prec += def.associativity === 'left' ? 1 : 0;
          this.index += n;
          const rhs = this.matchExpression(prec);
          return this.applyInvisibleOperator(...this.applyOperator(def.parse, lhs, rhs));
      }
      matchArguments(kind) {
          if (!kind)
              return null;
          const savedIndex = this.index;
          let result = null;
          const group = this.matchMatchfixOperator();
          if (kind === 'group' && getFunctionName(group) === PARENTHESES) {
              // We got a group i.e. `f(a, b, c)`
              result = getTail(group);
          }
          else if (kind === 'implicit') {
              // Does this function allow arguments with optional parentheses?
              // (i.e. trig functions, as in `\cos x`.
              if (getFunctionName(group) === PARENTHESES) {
                  result = getTail(group);
              }
              else if (group !== null) {
                  // There was a matchfix, the "group" is the argument, i.e.
                  // `\sin [a, b, c]`
                  result = [group];
              }
              else {
                  // No group, but arguments without parentheses are allowed
                  // Read a primary
                  // (i.e. we interpret `\cos x + 1` as `\cos(x) + 1`)
                  const primary = this.matchPrimary();
                  if (primary !== null)
                      result = [primary];
              }
          }
          else {
              // The element following the function does not match
              // a possible argument list
              // That's OK, but need to undo the parsing of the matchfix
              // This is the case: `f[a]` or `f|a|`
              this.index = savedIndex;
          }
          return result;
      }
      matchMatchfixOperator() {
          const [def] = this.peekDefinition('matchfix');
          if (def === null)
              return null;
          if (typeof def.parse === 'function') {
              // Custom parser: invoke it.
              return this.applyInvisibleOperator(...def.parse(null, this, 0));
          }
          const trigger = typeof def.trigger === 'object' ? def.trigger.matchfix : def.trigger;
          if (!trigger || !def.closeFence || !def.parse)
              return null;
          const arg = this.matchBalancedExpression(trigger, def.closeFence, this.onError);
          if (!arg)
              return [def.parse];
          return [def.parse, arg];
      }
      matchDefinition(kind) {
          // Find the longest string of tokens with a definition of the
          // specified kind
          const [def, tokenCount] = this.peekDefinition(kind);
          // If there is a custom parsing function associated with this
          // definition, invoke it.
          if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
              const [, result] = def.parse(null, this, 0);
              return [def, result];
          }
          this.index += tokenCount;
          return [def, null];
      }
      /**
       * A symbol can be:
       * - a constant: `\pi`
       * - a variable: `x`
       * - a function with explicit arguments `f(x)`
       * - a function with implicit arguments: `\cos x`
       * - a command: `\frac{2}{3}`
       */
      matchSymbol() {
          var _a, _b, _c, _d;
          const [def, result] = this.matchDefinition('symbol');
          // If a result is ready (because there was a parsing function associated
          // with the definition), we're done
          if (result !== null)
              return result;
          if (def === null) {
              // This is an unknown symbol.
              // Can we promote it?
              if ((_a = this.options.promoteUnknownFunctions) === null || _a === void 0 ? void 0 : _a.test(this.peek)) {
                  const name = this.next();
                  // this.onError({ code: 'unknown-function', arg: name });
                  const group = this.matchMatchfixOperator();
                  // If no arguments, return it as a symbol
                  if (group === null)
                      return name;
                  if (getFunctionName(group) !== PARENTHESES)
                      return null;
                  return [name, ...getTail(group)];
              }
              if ((_b = this.options.promoteUnknownSymbols) === null || _b === void 0 ? void 0 : _b.test(this.peek)) {
                  // this.onError({ code: 'unknown-symbol', arg: this.peek });
                  return this.next();
              }
              // Not a symbol (punctuation or fence, maybe?)...
              return this.matchUnknownLatexCommand();
          }
          //
          // Is it a Latex function, e.g. `\frac{}{}`?
          //
          const requiredArgs = [];
          const optionalArgs = [];
          let arg;
          let i = (_c = def.optionalLatexArg) !== null && _c !== void 0 ? _c : 0;
          while (i > 0) {
              arg = this.matchOptionalLatexArgument();
              if (arg !== null)
                  optionalArgs.push(arg);
              i--;
          }
          i = (_d = def.requiredLatexArg) !== null && _d !== void 0 ? _d : 0;
          while (i > 0) {
              arg = this.matchRequiredLatexArgument();
              // `null` indicate that no required argument was found
              if (arg === null)
                  this.onError({ code: 'expected-argument' });
              // `""` indicate an empty argument, i.e. `{}` was found
              if (arg !== null)
                  requiredArgs.push(arg);
              i--;
          }
          const args = this.matchArguments(def.arguments);
          if (args === null) {
              // Didn't get arguments
              if (requiredArgs.length === 0 && optionalArgs.length === 0) {
                  return def.parse;
              }
              return [def.parse, ...requiredArgs, ...optionalArgs];
          }
          return [def.parse, ...requiredArgs, ...args, ...optionalArgs];
      }
      matchOptionalLatexArgument() {
          this.skipSpace();
          return this.matchBalancedExpression('[', ']');
      }
      /**
       * Match a required latex argument:
       * - either enclosed in `{}`
       * - or a single token.
       *
       * Return null if an argument was not found
       * Return '' if an empty argument `{}` was found
       */
      matchRequiredLatexArgument() {
          this.skipSpace();
          const expr = this.matchBalancedExpression('<{>', '<}>');
          if (expr)
              return expr;
          // Is it a single digit?
          if (/^[0-9]$/.test(this.peek)) {
              // ... only match the digit, i.e. `x^23` is `x^{2}3`, not x^{23}
              return parseFloat(this.next());
          }
          // Is it a single letter (but not a special letter)?
          if (/^[^\\#]$/.test(this.peek)) {
              return this.next();
          }
          // Otherwise, this can only be a symbol.
          // `frac{1}2+1` is not valid, neither is `\frac\frac123`
          return this.matchSymbol();
      }
      /**
       *  Match a superfix/subfix operator, e.g. `^{*}`
       */
      matchSupsub(lhs) {
          if (lhs === null)
              return null;
          let result = null;
          this.skipSpace();
          [
              ['^', 'superfix'],
              ['_', 'subfix'],
          ].forEach((x) => {
              var _a, _b, _c;
              if (result !== null)
                  return;
              const [triggerChar, opKind] = x;
              const beforeTrigger = this.index;
              if (!this.match(triggerChar))
                  return;
              const savedIndex = this.index;
              let def;
              let n = 0;
              if (this.match('<{>')) {
                  // Supsub with an argument
                  [def, n] = this.peekDefinition(opKind);
                  if (def) {
                      //
                      // It's a supfix/subfix operator (
                      //  i.e. `^{*}` for `superstar`
                      //
                      if (typeof def.parse === 'function') {
                          result = def.parse(lhs, this, 0)[1];
                      }
                      else {
                          this.index += n;
                          if (this.match('<}>')) {
                              result = [(_a = def.parse) !== null && _a !== void 0 ? _a : def.name, lhs];
                          }
                          else {
                              // Not a supfix/subfix
                              // For example, "^{-1}", start with `"-"` from `superminus`,
                              // but the "1" after it makes it not match
                              this.index = savedIndex;
                          }
                      }
                  }
                  else {
                      this.index = savedIndex;
                  }
              }
              else {
                  //
                  // Single token argument for a sup/subfix
                  //
                  [def, n] = this.peekDefinition(opKind);
                  if (def) {
                      if (typeof def.parse === 'function') {
                          result = def.parse(lhs, this, 0)[1];
                      }
                      else {
                          this.index += n;
                          result = [(_b = def.parse) !== null && _b !== void 0 ? _b : def.name, lhs];
                      }
                  }
                  else {
                      this.index = savedIndex;
                  }
              }
              if (result === null) {
                  def = (_c = this.dictionary.infix[1]) === null || _c === void 0 ? void 0 : _c.get(triggerChar);
                  if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
                      this.index = beforeTrigger;
                      result = def.parse(lhs, this, 0)[1];
                  }
                  else if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'string') {
                      [lhs, result] = this.applyOperator(def.parse, lhs, this.matchRequiredLatexArgument());
                      result = this.applyInvisibleOperator(lhs, result);
                  }
                  else {
                      result = this.applyInvisibleOperator(lhs, triggerChar);
                  }
              }
              if (result !== null) {
                  // There could be some arguments following the supsub, e.g.
                  // `f^{-1}(x)`
                  const args = this.matchArguments(def === null || def === void 0 ? void 0 : def.arguments);
                  if (args !== null)
                      result = [result, ...args];
              }
          });
          return result;
      }
      matchPostfix(lhs) {
          if (lhs === null)
              return null;
          const [def, n] = this.peekDefinition('postfix');
          if (def === null || def === undefined)
              return null;
          if (typeof def.parse === 'function') {
              [, lhs] = def.parse(lhs, this, 0);
              if (lhs === null)
                  return null;
              return lhs;
          }
          this.index += n;
          return [def.parse, lhs];
      }
      matchString() {
          let result = '';
          let done = this.atEnd;
          while (!done) {
              if (this.match('<space>')) {
                  result += ' ';
              }
              else {
                  const token = this.peek;
                  if (token === ']') {
                      done = true;
                  }
                  else if (!/^<({|}|\$|\$\$|space)>$/.test(token)) {
                      result += this.next();
                  }
                  else if (token[0] === '\\') {
                      // TeX will give a 'Missing \endcsname inserted' error
                      // if it encounters any command when expecting a string.
                      // We're a bit more lax.
                      this.onError({ code: 'unexpected-command' });
                      result += this.next();
                  }
                  else {
                      // It's '<{>', '<}>', '<$>' or '<$$>
                      done = true;
                  }
              }
              done = done || this.atEnd;
          }
          return result;
      }
      matchEnvironmentName(command, envName) {
          if (this.match(command)) {
              const savedIndex = this.index;
              if (this.match('<{>')) {
                  const name = this.matchString();
                  if (this.match('<}>') && name === envName) {
                      return true;
                  }
              }
              this.index = savedIndex;
          }
          return false;
      }
      /**
       * Match an expression in a tabular format,
       * where row are separated by `\\` and columns by `&`
       *
       * Return rows of sparse columns as a list: empty rows are indicated with NOTHING,
       * and empty cells are also indicated with NOTHING.
       */
      matchTabular() {
          const result = ['list'];
          let row = ['list'];
          let expr = null;
          let done = false;
          while (!this.atEnd && !done) {
              if (this.match('&')) {
                  // new column
                  // Push even if expr is NULL (it represents a skipped column)
                  row.push(expr !== null && expr !== void 0 ? expr : NOTHING);
                  expr = null;
              }
              else if (this.match('\\\\') || this.match('\\cr')) {
                  // new row
                  this.skipSpace();
                  // Parse but drop optional argument (used to indicate spacing between lines)
                  this.matchOptionalLatexArgument();
                  if (expr !== null)
                      row.push(expr);
                  result.push(row);
                  row = ['list'];
                  expr = null;
              }
              else {
                  const rhs = this.matchExpression();
                  if (rhs === null)
                      done = true;
                  if (expr !== null) {
                      expr = this.applyInvisibleOperator(expr, rhs);
                  }
                  else {
                      expr = rhs;
                  }
              }
          }
          // Capture any leftover row
          if (row.length > 1) {
              result.push(row);
          }
          return result;
      }
      matchEnvironment() {
          var _a;
          if (this.match('\\begin')) {
              if (this.match('<{>')) {
                  const name = this.matchString();
                  if (this.match('<}>')) {
                      const start = this.index;
                      let end = this.index;
                      // Find the end of the environment
                      let level = 1;
                      while (!this.atEnd && level !== 0) {
                          end = this.index;
                          if (this.matchEnvironmentName('\\begin', name)) {
                              level += 1;
                          }
                          else if (this.matchEnvironmentName('\\end', name)) {
                              level -= 1;
                          }
                          else {
                              this.next();
                          }
                      }
                      const def = this.dictionary.environment.get(name);
                      if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
                          return def.parse(null, this.clone(start, end), 0)[1];
                      }
                      return (_a = def === null || def === void 0 ? void 0 : def.parse) !== null && _a !== void 0 ? _a : null;
                  }
              }
          }
          return null;
      }
      /**
       * Apply the operator `op` to the left-hand-side and right-hand-side
       * expression. Applies the associativity rule specified by the definition,
       * i.e. 'op(a, op(b, c))` -> `op(a, b, c)`, etc...
       *
       * `op` is the name of the operator which should have a corresponding
       * definition.
       *
       * If `op` is an infix operator, it should have both a lhs and rhs.
       * If `op` is a postfix operator, it should only have a lhs.
       * If `op` is a prefix operator, the lhs is returned as the first element
       * of the return tuple.
       *
       * @return a tuple: [lhs, rhs]
       */
      applyOperator(op, lhs, rhs) {
          var _a, _b, _c, _d;
          const def = this.dictionary.name.get(op);
          if (def === undefined) {
              this.onError({ code: 'unknown-operator' });
              return [lhs, rhs];
          }
          if (((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.prefix) !== undefined && lhs === null && rhs !== null) {
              return [null, [def.name, rhs]];
          }
          if (((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.postfix) !== undefined && lhs !== null) {
              return [null, [def.name, lhs]];
          }
          if (((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.matchfix) !== undefined ||
              ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.infix) !== undefined) {
              // infix
              if (def.associativity === 'non') {
                  return [null, [op, lhs !== null && lhs !== void 0 ? lhs : 'Missing', rhs !== null && rhs !== void 0 ? rhs : 'Missing']];
              }
              if (getFunctionName(lhs) === op) {
                  // Possible associativity
                  if (def.associativity === 'both') {
                      if (getFunctionName(rhs) === op) {
                          // +(+(a, b), +(c, d)) -> +(a, b, c, d)
                          if (Array.isArray(lhs)) {
                              return [null, lhs.concat(getTail(rhs))];
                          }
                          if (isFunctionObject(lhs)) {
                              return [null, lhs.fn.concat(getTail(rhs))];
                          }
                      }
                      else if (rhs) {
                          if (Array.isArray(lhs)) {
                              lhs.push(rhs);
                          }
                          if (isFunctionObject(lhs)) {
                              lhs.fn.push(rhs);
                          }
                      }
                      return [null, lhs];
                  }
                  if (def.associativity === 'left') {
                      return [null, [op, lhs !== null && lhs !== void 0 ? lhs : MISSING, rhs !== null && rhs !== void 0 ? rhs : MISSING]];
                  }
                  // Right-associative
                  if (Array.isArray(lhs)) {
                      return [null, [op, lhs[1], [op, lhs[2], rhs !== null && rhs !== void 0 ? rhs : MISSING]]];
                  }
                  if (isFunctionObject(lhs)) {
                      lhs.fn[2] = [op, lhs.fn[2], rhs !== null && rhs !== void 0 ? rhs : MISSING];
                  }
                  return [null, lhs];
              }
              else if (getFunctionName(rhs) === op) {
                  // Possible associativity
                  if (def.associativity === 'both') {
                      if (Array.isArray(rhs) && lhs) {
                          rhs.splice(1, 0, lhs);
                      }
                      if (isFunctionObject(rhs) && lhs) {
                          rhs.fn.splice(1, 0, lhs);
                      }
                      return [null, rhs];
                  }
                  if (def.associativity === 'right') {
                      return [null, [op, lhs !== null && lhs !== void 0 ? lhs : MISSING, rhs !== null && rhs !== void 0 ? rhs : MISSING]];
                  }
                  // Left-associative
                  if (Array.isArray(rhs)) {
                      return [null, [op, rhs[1], [op, rhs[2], lhs !== null && lhs !== void 0 ? lhs : MISSING]]];
                  }
                  if (isFunctionObject(rhs)) {
                      rhs.fn[2] = [op, rhs.fn[2], lhs !== null && lhs !== void 0 ? lhs : MISSING];
                  }
                  return [null, rhs];
              }
              return [null, [op, lhs !== null && lhs !== void 0 ? lhs : 'Missing', rhs !== null && rhs !== void 0 ? rhs : 'Missing']];
          }
          return [lhs, null];
      }
      /**
       * Apply an invisible operator between two expressions.
       *
       * If no `invisibleOperator` was specified, use the `latex` operator.
       *
       * If the lhs is a number and the rhs is a fraction of integers,
       * assume an 'invisible plus', that is '2 3/4' -> ['add', 2, [divide, 3, 4]]
       * unless `invisiblePlusOperator` is empty
       *
       */
      applyInvisibleOperator(lhs, rhs) {
          if (lhs === null)
              return rhs;
          if (rhs === null)
              return lhs;
          // @todo: handle invisible plus
          if (this.options.invisiblePlusOperator) {
              if ((typeof lhs === 'number' || isNumberObject(lhs)) &&
                  isRationalNumber(rhs)) {
                  [lhs, rhs] = this.applyOperator(this.options.invisiblePlusOperator, lhs, rhs);
                  if (lhs === null)
                      return rhs;
                  return null;
              }
          }
          if (this.options.invisibleOperator) {
              [lhs, rhs] = this.applyOperator(this.options.invisibleOperator, lhs, rhs);
              if (lhs === null)
                  return rhs;
              return null;
          }
          // No invisible operator, use 'Latex'
          let fn = [LATEX_TOKENS];
          if (getFunctionName(lhs) === LATEX_TOKENS) {
              fn = fn.concat(getTail(lhs));
          }
          else {
              fn.push(lhs);
          }
          if (rhs !== null) {
              if (getFunctionName(rhs) === LATEX_TOKENS) {
                  fn = fn.concat(getTail(rhs));
              }
              else {
                  fn.push(rhs);
              }
          }
          if (this.options.invisibleOperator) {
              this.onError({ code: 'unexpected-sequence' });
          }
          return fn;
      }
      matchUnknownLatexCommand() {
          var _a;
          const command = this.peek;
          if (!command || command[0] !== '\\') {
              return null;
          }
          this.next();
          if (command === '\\operatorname') {
              this.skipSpace();
              if (this.peek === '<{>') {
                  let result = '';
                  this.next();
                  while (!this.atEnd && this.tokens[this.index] !== '<}>') {
                      result += this.next();
                  }
                  return result;
              }
              return (_a = this.next()) !== null && _a !== void 0 ? _a : MISSING;
          }
          const optArgs = [];
          const reqArgs = [];
          let done = false;
          do {
              done = true;
              let expr = this.matchOptionalLatexArgument();
              if (expr !== null) {
                  optArgs.push(expr);
                  done = false;
              }
              this.skipSpace();
              if (this.peek === '<{>') {
                  expr = this.matchRequiredLatexArgument();
                  if (expr !== null) {
                      reqArgs.push(expr);
                      done = false;
                  }
              }
          } while (!done);
          if (optArgs.length > 0 || reqArgs.length > 0) {
              return [command, ...reqArgs, ...optArgs];
          }
          return command;
      }
      /**
       * <primary> :=
       * (<number> | <symbol> | <environment> | <matchfix-expr>) <subsup>* <postfix-operator>*
       *
       * <symbol> ::= (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
       *
       * <matchfix-expr> :=
       *  <matchfix-op-open> <expression> [<matchfix-op-separator> <expression>] <matchfix-op-close>
       *
       */
      matchPrimary(_minPrec) {
          let result = null;
          const originalIndex = this.index;
          //
          // 1. Is it a number?
          //
          const num = this.matchNumber();
          if (num)
              result = { num: num };
          //
          // 2. Is it a matchfix expression?
          //    (group fence, absolute value, integral, etc...)
          // (check before other latex commands)
          //
          if (result === null)
              result = this.matchMatchfixOperator();
          //
          // 3. Is it an environment?
          // `\begin{...}...\end{...}`
          // (check before other latex commands)
          //
          if (result === null)
              result = this.matchEnvironment();
          //
          // 4. Is it a symbol, a Latex command or a function call?
          //    `x` or `\pi'
          //    `f(x)` or `\sin(\pi)
          //    `\frac{1}{2}`
          //
          if (result === null)
              result = this.matchSymbol();
          //
          // 5. Are there subsup or postfix operators?
          //
          let supsub = null;
          do {
              supsub = this.matchSupsub(result);
              result = supsub !== null && supsub !== void 0 ? supsub : result;
          } while (supsub !== null);
          let postfix = null;
          do {
              postfix = this.matchPostfix(result);
              result = postfix !== null && postfix !== void 0 ? postfix : result;
          } while (postfix !== null);
          return this.decorate(result, originalIndex);
      }
      matchBalancedExpression(open, close, onError) {
          const scanner = this.balancedClone(open, close);
          if (!scanner) {
              // eslint-disable-next-line no-unused-expressions
              onError === null || onError === void 0 ? void 0 : onError({
                  code: 'unbalanced-symbols',
                  arg: tokensToString(open) + tokensToString(close),
              });
              return null;
          }
          const result = scanner.matchExpression();
          if (!scanner.atEnd) {
              // eslint-disable-next-line no-unused-expressions
              onError === null || onError === void 0 ? void 0 : onError({
                  code: 'unbalanced-symbols',
                  arg: tokensToString(open) + tokensToString(close),
              });
          }
          return result;
      }
      /**
       *  Parse an expression:
       *
       * <expression> ::=
       *  | <primary>
       *  | <prefix-op> <primary>
       *  | <primary> <infix-op> <expression>
       *
       * Stop when an operator of precedence less than `minPrec` is encountered
       */
      matchExpression(minPrec = 0) {
          let lhs = null;
          const originalIndex = this.index;
          this.skipSpace();
          //
          // 1. Do we have a primary?
          // (we check first to capture "-1" as a negative number, and not as a prefix
          // operator applied to a number).
          //
          lhs = this.matchPrimary(minPrec);
          //
          // 2. Do we have a prefix operator?
          //
          if (lhs === null)
              lhs = this.matchOperator('prefix');
          //
          // 3. Are there some infix operators?
          //
          let done = false;
          while (!this.atEnd && !done) {
              this.skipSpace();
              let result = this.matchOperator('infix', lhs, minPrec);
              if (result === null && lhs !== null) {
                  // We've encountered something else than an infix operator
                  // OR an infix operator with a lower priority.
                  // Could be "y" after "x": time to apply the invisible operator
                  // if the next element is:
                  // - a symbol: `2x`, `2f(x)` (after `2`)
                  // - a number: `x2` (after `x`)
                  // - a matchfix open: `x(n+1)` (after `x`)
                  // (i.e. not an operator)
                  const [op] = this.peekDefinition('operator');
                  if (op === null) {
                      const rhs = this.matchExpression(this.invisibleOperatorPrecedence);
                      if (rhs !== null) {
                          result = this.applyInvisibleOperator(lhs, rhs);
                      }
                  }
              }
              if (result !== null) {
                  lhs = result;
              }
              else {
                  // We could not apply the infix operator: the rhs may
                  // have been a postfix operator, or something else
                  done = true;
              }
          }
          return this.decorate(lhs, originalIndex);
      }
      /**
       * Add latex or other requested metadata to the expression
       */
      decorate(expr, start) {
          if (expr === null)
              return null;
          if (this.options.preserveLatex) {
              const latex = this.latex(start, this.index);
              if (Array.isArray(expr)) {
                  expr = { latex, fn: expr };
              }
              else if (typeof expr === 'number') {
                  expr = { latex, num: Number(expr).toString() };
              }
              else if (typeof expr === 'string') {
                  expr = { latex, sym: expr };
              }
              else if (typeof expr === 'object' && expr !== null) {
                  expr.latex = latex;
              }
          }
          return expr;
      }
  }

  // Some vocabulary:
  // 123.456e78
  // - 123.456 = significand
  // - 123 = wholePart
  // - 456 = fractionalPart
  // - 79 = exponent
  //
  // Avoid using mantissa which has several definitions and is ambiguous.
  /**
   * Return a formatted fractional part by detecting repeating patterns.
   * 1234567 -> 123 456 7...
   * 1233333 -> 12(3)
   */
  function formatFractionalPart(m, options) {
      const originalLength = m.length;
      const originalM = m;
      // The last digit may have been rounded off, if it exceeds the precision,
      // which could throw off the repeating pattern detection. Ignore it.
      m = m.slice(0, -1);
      for (let i = 0; i < m.length - 16; i++) {
          // Offset is the part of the fractional part that is not repeating
          const offset = m.substr(0, i);
          // Try to find a repeating pattern of length j
          for (let j = 0; j < 17; j++) {
              const cycle = m.substr(i, j + 1);
              const times = Math.floor((m.length - offset.length) / cycle.length);
              if (times > 1) {
                  if ((offset + cycle.repeat(times + 1)).startsWith(m)) {
                      // We've found a repeating pattern!
                      if (cycle === '0') {
                          // Psych! That pattern is '0'...
                          return offset.replace(/(\d{3})/g, '$1' + options.groupSeparator);
                      }
                      // There is what looks like a true repeating pattern...
                      return (offset.replace(/(\d{3})/g, '$1' + options.groupSeparator) +
                          options.beginRepeatingDigits +
                          cycle +
                          // cycle.replace(/(\d{3})/g, '$1' + options.groupSeparator) +
                          options.endRepeatingDigits);
                  }
              }
          }
      }
      // There was no repeating pattern we could find...
      // Are we displaying fewer digits than were provided?
      // Display a truncation marker.
      const extraDigits = originalLength > options.precision - 1;
      m = originalM;
      if (extraDigits) {
          m = m.substr(0, options.precision - 1);
      }
      // Insert group separators if necessary
      if (options.groupSeparator) {
          m = m.replace(/(\d{3})/g, '$1' + options.groupSeparator);
          if (m.endsWith(options.groupSeparator)) {
              m = m.slice(0, -options.groupSeparator.length);
          }
      }
      if (extraDigits)
          return m + options.truncationMarker;
      return m;
  }
  function formatExponent(exp, options) {
      var _a;
      if (!exp)
          return '';
      if (options.beginExponentMarker) {
          return (options.beginExponentMarker + exp + ((_a = options.endExponentMarker) !== null && _a !== void 0 ? _a : ''));
      }
      return '10^{' + exp + '}';
  }
  /*
   * @param expr - A number, can be represented as a string
   *  particularly useful for arbitrary precision numbers) or a number (-12.45)
   * @return A textural representation of the number, formatted according to the
   * `options`
   */
  function serializeNumber(expr, options) {
      var _a, _b;
      let num;
      if (typeof expr === 'number') {
          num = expr;
      }
      else if (isNumberObject(expr)) {
          num = expr.num;
      }
      else {
          return '';
      }
      if (num === Infinity || num === 'Infinity' || num === '+Infinity') {
          return options.positiveInfinity;
      }
      else if (num === -Infinity || num === '-Infinity') {
          return options.negativeInfinity;
      }
      else if (num === 'NaN' || (typeof num === 'number' && Number.isNaN(num))) {
          return options.notANumber;
      }
      if (typeof num === 'number') {
          if (options.notation === 'engineering') {
              return serializeEngineeringNotationNumber(num, options);
          }
          return serializeAutoNotationNumber(num.toString(), options);
      }
      // If we end with a letter ('n' or 'd' for bigint or decimal)
      // remove it.
      if (/[a-zA-Z]$/.test(num))
          num = num.slice(0, -1);
      let sign = '';
      if (num[0] === '-') {
          sign = '-';
          num = num.substr(1);
      }
      else if (num[0] === '+') {
          num = num.substr(1);
      }
      // Remove any leading zeros
      while (num[0] === '0') {
          num = num.substr(1);
      }
      if (num.length === 0)
          return sign + '0';
      if (num[0] === '.')
          num = '0' + num;
      let exponent = '';
      if (num.indexOf('.') >= 0) {
          const m = num.match(/(\d*)\.(\d*)([e|E]([-+]?[0-9]*))?/);
          if (!m)
              return '';
          const base = m[1];
          const fractionalPart = m[2];
          exponent = (_a = m[4]) !== null && _a !== void 0 ? _a : '';
          if (base === '0') {
              let p = 0; // Index of the first non-zero digit after the decimal
              while (fractionalPart[p] === '0' && p < fractionalPart.length) {
                  p += 1;
              }
              let r = '';
              if (p <= 4) {
                  r = '0' + options.decimalMarker;
                  r += fractionalPart.substr(0, p);
                  r += formatFractionalPart(num.substr(r.length), options);
              }
              else if (p + 1 >= options.precision) {
                  r = '0';
                  sign = '';
              }
              else {
                  r = num[p];
                  const f = formatFractionalPart(num.substr(p + 1), options);
                  if (f) {
                      r += options.decimalMarker + f;
                  }
              }
              if (r !== '0') {
                  if (num.length - 1 > options.precision &&
                      !(options.endRepeatingDigits && r.endsWith(options.endRepeatingDigits)) &&
                      options.truncationMarker &&
                      !r.endsWith(options.truncationMarker)) {
                      r += options.truncationMarker;
                  }
                  if (p > 4) {
                      r +=
                          options.exponentProduct +
                              formatExponent((1 - p).toString(), options);
                  }
              }
              num = r;
          }
          else {
              num = base.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
              const f = formatFractionalPart(fractionalPart, options);
              if (f) {
                  num += options.decimalMarker + f;
                  // if (num.length - 1 > config.precision && !num.endsWith('}') && !num.endsWith('\\ldots')) {
                  //     num += '\\ldots';
                  // }
              }
          }
      }
      else if (num.length > options.precision) {
          const len = num.length;
          let r = num[0];
          const f = formatFractionalPart(num.substr(1), options);
          if (f) {
              r += options.decimalMarker + f;
              if (options.truncationMarker && !r.endsWith(options.truncationMarker)) {
                  if (options.endRepeatingDigits &&
                      !r.endsWith(options.endRepeatingDigits)) {
                      r += options.truncationMarker;
                  }
              }
          }
          if (r !== '1') {
              r += options.exponentProduct;
          }
          else {
              r = '';
          }
          num = r + formatExponent((len - 1).toString(), options);
      }
      else {
          const m = num.match(/([0-9]*)\.?([0-9]*)([e|E]([-+]?[0-9]+))?/);
          if (m) {
              num = m[1];
              if (m[2])
                  num += options.decimalMarker + m[2];
              exponent = (_b = m[4]) !== null && _b !== void 0 ? _b : '';
          }
          num = num.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
      }
      const exponentString = formatExponent(exponent, options);
      return (sign +
          num +
          (exponentString ? options.exponentProduct + exponentString : ''));
  }
  function serializeEngineeringNotationNumber(value, options) {
      if (value === 0)
          return '0';
      // Ensure the exponent is a multiple of 3
      const y = Math.abs(value);
      let exponent = Math.round(Math.log10(y));
      exponent = exponent - (exponent % 3);
      if (y < 1000)
          exponent = 0;
      const significand = y / Math.pow(10, exponent);
      let significandString = '';
      const m = significand.toString().match(/^(.*)\.(.*)$/);
      if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
          significandString = m[1] + options.decimalMarker + m[2];
      }
      if (options.groupSeparator) {
          significandString = formatFractionalPart(significand.toExponential(), options);
      }
      let exponentString = '';
      if (exponent !== 0) {
          exponentString = formatExponent(exponent.toString(), options);
      }
      return (value < 0 ? '-' : '') + significandString + exponentString;
  }
  function serializeAutoNotationNumber(valString, options) {
      let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
      let exponent = undefined;
      // if valString === '-1234567.89e-123'
      // m[1] = '-1234567.89'
      // m[2] = -123
      if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
          // There is an exponent...
          exponent = formatExponent(m[2], options);
          if (exponent) {
              exponent = options.exponentProduct + exponent;
          }
      }
      let wholePart = valString;
      let fractionalPart = '';
      m = (exponent ? m[1] : valString).match(/^(.*)\.(.*)$/);
      if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
          wholePart = m[1];
          fractionalPart = m[2];
      }
      if (options.groupSeparator) {
          wholePart = wholePart.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
          fractionalPart = formatFractionalPart(fractionalPart, options);
      }
      if (fractionalPart)
          fractionalPart = options.decimalMarker + fractionalPart;
      return wholePart + fractionalPart + (exponent !== null && exponent !== void 0 ? exponent : '');
  }
  /**
   * `value` is a base-10 number, possibly a floating point number with an
   * exponent, i.e. "0.31415e1"
   */
  // export function serializeBaseNotation(value: string, base: number): string {
  //   const alphabet = '01234567890abcdef'.substr(0, base);
  //   const m = value.match(/^([+-]?[0-9_]*)(\.([0-9]*))?n?([e|E]([-+]?[0-9]+))$/);
  //   if (!m) return '';
  //   const [, wholePart, , fractionalPart, , exponent] = m;
  //   let w = parseInt(wholePart);
  //   if (w.toString() !== value) return ''; // Out of range
  //   const sign = w < 0 ? '-' : '';
  //   w = Math.abs(w);
  //   let significand = '';
  //   while (w > 0) {
  //     significand = alphabet[w % base] + significand;
  //     w = Math.floor(w / base);
  //   }
  //   if (fractionalPart) {
  //     if (!significand) significand = '0';
  //     significand += '.';
  //     let f = parseInt(fractionalPart);
  //     if (f.toString() !== fractionalPart) return ''; // Out of range
  //     while (f > 0) {
  //       significand =
  //     }
  //   }
  //   return sign + (exponent ? 'p' + exponent : '');
  // }
  /**
   * Return a C99 hex-float formated representation of the floating-point `value`.
   *
   * Does not handle integer and non-finite values.
   */
  function serializeHexFloat(value) {
      console.assert(Number.isFinite(value) && !Number.isInteger(value));
      const digits = '0123456789abcdef';
      const sign = value < 0 ? '-' : '';
      value = Math.abs(value);
      let significand = '';
      let exponent = 0;
      let wholePart = Math.trunc(value);
      let fractionalPart = value - wholePart;
      // Reduce the whole part to an odd number.
      // The C99 standard does not specify a normal exponent/wholepart, so
      // multiple representations are acceptable.
      // We choose to normalize by having the largest positive exponent possible
      // if the whole part is not 0, or the largest negative exponent possible
      // if the whole part is 0
      if (wholePart !== 0) {
          while (wholePart % 2 === 0 && wholePart > 0) {
              wholePart /= 2;
              fractionalPart /= 2;
              exponent += 1;
          }
      }
      else {
          let adjustedFractionalPart = fractionalPart;
          while (adjustedFractionalPart * 2 < 2) {
              adjustedFractionalPart *= 2;
              exponent -= 1;
          }
          wholePart = Math.trunc(adjustedFractionalPart);
          fractionalPart = adjustedFractionalPart - wholePart;
      }
      // Calculate the whole part as hex digits
      while (wholePart !== 0) {
          significand = digits[wholePart % 16] + significand;
          wholePart = Math.trunc(wholePart / 16);
      }
      if (!significand) {
          significand = '0.';
      }
      else {
          significand += '.';
      }
      // Calculate the fractional part as hex digits
      if (fractionalPart === 0) {
          significand += '0';
      }
      else {
          while (fractionalPart > 0) {
              const digit = Math.trunc(fractionalPart * 16);
              significand += digits[digit];
              fractionalPart = 16 * fractionalPart - digit;
          }
      }
      return (sign +
          '0x' +
          significand +
          'p' +
          (exponent < 0 ? '-' : '') +
          Number(Math.abs(exponent)).toString());
  }

  function getSymbolStyle(expr, _level) {
      console.assert(typeof expr === 'string' || isSymbolObject(expr));
      const sym = getSymbolName(expr);
      if (sym === null)
          return 'asis';
      return sym.length > 1 ? 'upright' : 'asis';
  }
  function serializeMatchfix(serializer, expr, def) {
      var _a, _b;
      let segments = [];
      if (typeof ((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.matchfix) === 'string') {
          segments.push((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.matchfix);
      }
      else if (def.trigger && Array.isArray(def.trigger.matchfix)) {
          segments = [...def.trigger.matchfix];
      }
      if (getArgCount(expr) >= 1) {
          let sep = '';
          for (const arg of getTail(expr)) {
              if (arg) {
                  segments.push(sep);
                  segments.push(serializer.serialize(arg));
                  sep = def.separator;
              }
          }
      }
      segments.push(tokensToString(def.closeFence));
      return joinLatex(segments);
  }
  function serializeOperator(serializer, expr, def) {
      var _a, _b, _c, _d, _e;
      let result = '';
      const count = getArgCount(expr);
      const name = getFunctionName(expr);
      if (((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.superfix) || ((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.subfix)) {
          if (count !== 1) {
              serializer.onError({
                  code: 'operator-requires-one-operand',
                  arg: serializer.serializeSymbol(name),
              });
          }
          return replaceLatex(def.serialize, [
              serializer.serialize(getArg(expr, 1)),
          ]);
      }
      if ((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.postfix) {
          if (count !== 1) {
              serializer.onError({
                  code: 'postfix-operator-requires-one-operand',
                  arg: serializer.serializeSymbol(name),
              });
          }
          return replaceLatex(def.serialize, [
              serializer.wrap(getArg(expr, 1), def.precedence),
          ]);
      }
      if ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.prefix) {
          if (count !== 1) {
              serializer.onError({
                  code: 'prefix-operator-requires-one-operand',
                  arg: serializer.serializeSymbol(name),
              });
          }
          return replaceLatex(def.serialize, [
              serializer.wrap(getArg(expr, 1), def.precedence + 1),
          ]);
      }
      if ((_e = def.trigger) === null || _e === void 0 ? void 0 : _e.infix) {
          result = serializer.wrap(getArg(expr, 1), def.precedence);
          for (let i = 2; i < count + 1; i++) {
              const arg = getArg(expr, i);
              if (arg !== null) {
                  result = replaceLatex(def.serialize, [
                      result,
                      serializer.wrap(arg, def.precedence),
                  ]);
              }
          }
      }
      return result;
  }
  class Serializer {
      constructor(options, dictionary, onError) {
          this.level = -1;
          this.options = options;
          if (options.invisibleMultiply) {
              if (!/#1/.test(options.invisibleMultiply) ||
                  !/#2/.test(options.invisibleMultiply)) {
                  onError({
                      code: 'expected-argument',
                      arg: 'invisibleMultiply',
                  });
              }
          }
          this.onError = onError;
          this.dictionary = dictionary;
      }
      /**
       * Serialize the expression, and if the expression is an operator
       * of precedence less than or equal to prec, wrap it in some paren.
       * @todo: don't wrap abs
       */
      wrap(expr, prec) {
          if (expr === null)
              return '';
          if (prec === undefined) {
              return '(' + this.serialize(expr) + ')';
          }
          if (typeof expr === 'number' ||
              isNumberObject(expr) ||
              typeof expr === 'string' ||
              isSymbolObject(expr)) {
              return this.serialize(expr);
          }
          const name = getFunctionName(expr);
          if (name && name !== PARENTHESES) {
              const def = this.dictionary.name.get(name);
              if (def && def.precedence !== undefined && def.precedence < prec) {
                  return this.wrapString(this.serialize(expr), getApplyFunctionStyle(expr, this.level));
              }
          }
          return this.serialize(expr);
      }
      /** If this is a "short" expression (atomic), wrap it.
       *
       */
      wrapShort(expr) {
          if (expr === null)
              return '';
          const exprStr = this.serialize(expr);
          if (getFunctionName(expr) === PARENTHESES)
              return exprStr;
          if (typeof expr !== 'number' &&
              !isNumberObject(expr) &&
              !/(^(.|\\[a-zA-Z*]+))$/.test(exprStr)) {
              // It's a long expression, wrap it
              return this.wrapString(exprStr, getGroupStyle(expr, this.level + 1));
          }
          return exprStr;
      }
      wrapString(s, style) {
          if (style === 'none')
              return s;
          return '(' + s + ')';
      }
      serializeSymbol(expr, def) {
          const head = getFunctionHead(expr);
          if (!head) {
              console.assert(typeof expr === 'string' || isSymbolObject(expr));
              // It's a symbol
              if (typeof (def === null || def === void 0 ? void 0 : def.serialize) === 'string') {
                  return def.serialize;
              }
              const name = getSymbolName(expr);
              if (name === null)
                  return '';
              switch (getSymbolStyle(expr, this.level)) {
                  case 'upright':
                      return '\\operatorname{' + name + '}';
                  //            case 'asis':
                  default:
                      return name;
              }
          }
          //
          // It's a function
          //
          const args = getTail(expr);
          if (!def) {
              // We don't know anything about this function
              if (typeof head === 'string' && head.length > 0 && head[0] === '\\') {
                  //
                  // 1. Is is an unknown latex command?
                  //
                  // This looks like a Latex command. Serialize
                  // the arguments as Latex arguments
                  let result = head;
                  for (const arg of args) {
                      result += '{' + this.serialize(arg) + '}';
                  }
                  return result;
              }
              //
              // 2. Is it an unknown function call?
              //
              // It's a function we don't know.
              // Maybe it came from `promoteUnknownSymbols`
              // Serialize the arguments as function arguments
              return `${this.serialize(head)}(${args
                .map((x) => this.serialize(x))
                .join(', ')})`;
              // return `\\operatorname{Apply}(${this.serialize(head)}, ${this.serialize([
              //   'List',
              //   ...args,
              // ])})`;
          }
          if (def.requiredLatexArg > 0) {
              //
              // 3. Is it a known Latex command?
              //
              // This looks like a Latex command. Serialize the arguments as Latex
              // arguments
              let optionalArg = '';
              let requiredArg = '';
              let i = 0;
              while (i < def.requiredLatexArg) {
                  requiredArg += '{' + this.serialize(args[i++]) + '}';
              }
              while (i < Math.min(args.length, def.optionalLatexArg + def.requiredLatexArg)) {
                  const optValue = this.serialize(args[1 + i++]);
                  if (optValue) {
                      optionalArg += '[' + optValue + ']';
                  }
              }
              return def.serialize + (optionalArg + requiredArg);
          }
          //
          // 4. Is it a known function?
          //
          getApplyFunctionStyle(expr, this.level);
          return def.serialize + this.serialize([PARENTHESES, ...args]);
      }
      serializeDictionary(dict) {
          return `\\left[\\begin{array}{lll}${Object.keys(dict)
            .map((x) => {
            return `\\textbf{${x}} & \\rightarrow & ${this.serialize(dict[x])}`;
        })
            .join('\\\\')}\\end{array}\\right]`;
      }
      serialize(expr) {
          if (expr === null)
              return '';
          this.level += 1;
          const result = (() => {
              var _a, _b, _c, _d;
              //
              // 1. Is it a number
              //
              const numericValue = serializeNumber(expr, this.options);
              if (numericValue)
                  return numericValue;
              //
              // 2. Is it a string?
              //
              const stringValue = getStringValue(expr);
              if (stringValue !== null)
                  return `\\text{${stringValue}}`;
              //
              // 3. Is it a symbol?
              //
              const symbolName = getSymbolName(expr);
              if (symbolName !== null) {
                  return this.serializeSymbol(expr, this.dictionary.name.get(symbolName));
              }
              //
              // 4. Is it a dictionary?
              //
              const dict = getDictionary(expr);
              if (dict !== null)
                  return this.serializeDictionary(dict);
              //
              // 5. Is it a named function?
              //
              const fnName = getFunctionName(expr);
              if (fnName) {
                  if (fnName[0] === '\\') {
                      // 5.1 An unknown Latex command, possibly with arguments.
                      // This can happen if we encountered an unrecognized Latex command
                      // during parsing, e.g. "\foo{x + 1}"
                      const args = getTail(expr);
                      if (args.length === 0)
                          return fnName;
                      return (fnName +
                          '{' +
                          args
                              .map((x) => this.serialize(x))
                              .filter((x) => Boolean(x))
                              .join('}{') +
                          '}');
                  }
                  //
                  // 5.2 A function, operator or matchfix operator
                  //
                  const def = this.dictionary.name.get(fnName);
                  if (def) {
                      let result = '';
                      // If there is a custom serializer function, use it.
                      if (typeof def.serialize === 'function') {
                          result = def.serialize(this, expr);
                      }
                      if (!result &&
                          (def.precedence !== undefined ||
                              ((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.superfix) ||
                              ((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.subfix))) {
                          result = serializeOperator(this, expr, def);
                      }
                      if (!result && ((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.matchfix)) {
                          result = serializeMatchfix(this, expr, def);
                      }
                      if (!result && ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.symbol)) {
                          result = this.serializeSymbol(expr, def);
                      }
                      return result;
                  }
              }
              if (Array.isArray(expr) || isFunctionObject(expr)) {
                  // It's a function, but without definition.
                  // It could be a [['derive', "f"], x]
                  // serializeSymbol() will take care of it.
                  return this.serializeSymbol(expr);
              }
              // This doesn't look like a symbol, or a function,
              // or anything we were expecting.
              // This is an invalid expression, for example an
              // object literal with no known fields, or an invalid number:
              // `{num: 'not a number'}`
              // `{foo: 'not an expression}`
              this.onError({
                  code: 'syntax-error',
                  arg: JSON.stringify(expr),
              });
          })();
          this.level -= 1;
          return result !== null && result !== void 0 ? result : '';
      }
  }

  class LatexSyntax {
      constructor(options) {
          var _a, _b;
          const onError = (err) => {
              if (typeof window !== 'undefined') {
                  if (!err.before || !err.after) {
                      console.warn(err.code + (err.arg ? ': ' + err.arg : ''));
                  }
                  else {
                      console.warn(err.code +
                          (err.arg ? ': ' + err.arg : '') +
                          '\n' +
                          '%c' +
                          '|  ' +
                          err.before +
                          '%c' +
                          err.after +
                          '\n' +
                          '%c' +
                          '|  ' +
                          String(' ').repeat(err.before.length) +
                          'â–²', 'font-weight: bold', 'font-weight: normal; color: rgba(160, 160, 160)', 'font-weight: bold; color: hsl(4deg, 90%, 50%)');
                  }
              }
              return;
          };
          this.onError = (_a = options === null || options === void 0 ? void 0 : options.onError) !== null && _a !== void 0 ? _a : onError;
          const opts = { ...(options !== null && options !== void 0 ? options : {}) };
          delete opts.dictionary;
          delete opts.onError;
          this.options = {
              ...DEFAULT_LATEX_NUMBER_OPTIONS,
              ...DEFAULT_SERIALIZE_LATEX_OPTIONS,
              ...DEFAULT_PARSE_LATEX_OPTIONS,
              ...opts,
          };
          this.dictionary = indexLatexDictionary((_b = options === null || options === void 0 ? void 0 : options.dictionary) !== null && _b !== void 0 ? _b : LatexSyntax.getDictionary(), this.onError);
      }
      static getDictionary(domain = 'all') {
          if (domain === 'all') {
              let result = [];
              for (const domain of Object.keys(DEFAULT_LATEX_DICTIONARY)) {
                  result = [...result, ...DEFAULT_LATEX_DICTIONARY[domain]];
              }
              return result;
          }
          if (!DEFAULT_LATEX_DICTIONARY[domain])
              return [];
          return [...DEFAULT_LATEX_DICTIONARY[domain]];
      }
      parse(latex) {
          var _a;
          const scanner = new Scanner(tokenize(latex, []), this.options, this.dictionary, this.onError);
          const result = scanner.matchExpression();
          if (!scanner.atEnd) {
              // eslint-disable-next-line no-unused-expressions
              (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, { code: 'syntax-error' });
          }
          return result !== null && result !== void 0 ? result : '';
      }
      serialize(expr) {
          const serializer = new Serializer(this.options, this.dictionary, this.onError);
          return serializer.serialize(expr);
      }
  }
  function parse(latex, options) {
      const syntax = new LatexSyntax(options);
      return syntax.parse(latex);
  }
  /**
   * Serialize a MathJSON expression as a Latex string.
   *
   */
  function serialize(expr, options) {
      const syntax = new LatexSyntax(options);
      return syntax.serialize(expr);
  }

  class CortexError {
      constructor(errorSignal) {
          this.signal = { severity: 'error', ...errorSignal };
      }
      toString() {
          let result = '';
          if (this.signal.head) {
              result += this.signal.head + ': ';
          }
          if (typeof this.signal.message === 'string') {
              result += this.signal.message;
          }
          else {
              result += ' ';
              for (const arg of this.signal.message) {
                  result += arg.toString() + ' ';
              }
          }
          return result;
      }
  }
  // This return all the vars (free or not) in the expression.
  // Calculating the free vars is more difficult: to do so you need to know
  // which function create a scope, and when a symbol is added to a scope.
  // The better way to deal with it is to compile an expression and catch
  // the errors when an undefined symbol is encountered.
  function getVarsRecursive(engine, expr, vars) {
      const args = getTail(expr);
      if (args.length > 0) {
          args.forEach((x) => getVarsRecursive(engine, x, vars));
      }
      else {
          // It has a name, but no arguments. It's a symbol
          const name = getSymbolName(expr);
          if (name && !vars.has(name)) {
              const def = engine.getSymbolDefinition(name);
              if (!def || def.constant === false) {
                  // It's not in the dictionary, or it's in the dictionary
                  // but not as a constant -> it's a variable
                  vars.add(name);
              }
          }
      }
  }
  /**
   * Return the set of variables (free or not) in an expression.
   * Doesn't return free varas because doesn't account for variable declaration
   * and scopes.
   */
  function getVariables(ce, expr) {
      const result = new Set();
      getVarsRecursive(ce, expr, result);
      return result;
  }
  function hasWildcards(expr) {
      const symbol = getSymbolName(expr);
      if (symbol === null || symbol === void 0 ? void 0 : symbol.startsWith('_'))
          return true;
      const head = getFunctionHead(expr);
      if (head !== null) {
          return hasWildcards(head) || getTail(expr).some(hasWildcards);
      }
      const dict = getDictionary(expr);
      if (dict !== null) {
          return Object.keys(dict).some((key) => hasWildcards(dict[key]));
      }
      return false;
  }

  function captureWildcard(wildcard, expr, substitution) {
      if (expr === null)
          return null;
      const name = getWildcardName(wildcard);
      // If this is a universal wildcard, it matches and no need to add it
      // to the substitution record.
      if (name === '')
          return substitution;
      if (substitution[name]) {
          // There was already a match, make sure this one is identical
          if (match(expr, substitution[name]) === null)
              return null;
          return substitution;
      }
      else {
          substitution[name] = expr;
      }
      return substitution;
  }
  function matchRecursive(expr, pattern, substitution, options) {
      var _a;
      //
      // Match a number
      //
      const val = getNumberValue(pattern);
      if (val !== null) {
          // Two numbers are considered the same if they are close in value
          // (< 10^(-10) by default).
          if (Math.abs(val - ((_a = getNumberValue(expr)) !== null && _a !== void 0 ? _a : NaN)) <=
              options.numericalTolerance) {
              return substitution;
          }
          return null;
      }
      //
      // Match a string
      //
      const str = getStringValue(pattern);
      if (str !== null) {
          if (getStringValue(expr) === str)
              return substitution;
          return null;
      }
      //
      // Match a dictionary
      //
      const dict = getDictionary(pattern);
      if (dict !== null) {
          const keys = Object.keys(dict);
          const exprDict = getDictionary(expr);
          if (exprDict === null)
              return null;
          if (Object.keys(exprDict).length !== keys.length)
              return null;
          for (const key of keys) {
              const r = matchRecursive(exprDict[key], dict[key], substitution, options);
              if (r === null)
                  return null;
              substitution = r;
          }
          return substitution;
      }
      //
      // Match a symbol or capture symbol
      //
      const symbol = getSymbolName(pattern);
      if (symbol !== null) {
          if (symbol.startsWith('_'))
              return captureWildcard(symbol, expr, substitution);
          if (symbol === getSymbolName(expr)) {
              if (typeof pattern === 'object' &&
                  typeof expr === 'object' &&
                  'wikidata' in pattern &&
                  'wikidata' in expr &&
                  pattern.wikidata !== expr.wikidata) {
                  // The symbols match, but they have a different wikidata: they don't match
                  return null;
              }
              return substitution;
          }
          if (typeof pattern === 'object' &&
              typeof expr === 'object' &&
              'wikidata' in pattern &&
              'wikidata' in expr &&
              pattern.wikidata === expr.wikidata) {
              return substitution;
          }
          return null;
      }
      //
      // Match a function
      //
      const head = getFunctionHead(pattern);
      if (head === null)
          return null;
      // Match the function head
      if (typeof head === 'string' && head.startsWith('_')) {
          return captureWildcard(head, getFunctionHead(expr), substitution);
      }
      else {
          const exprHead = getFunctionHead(expr);
          if (exprHead === null)
              return null;
          if (match(head, exprHead, options) === null)
              return null;
      }
      // Match the arguments
      const args = getTail(pattern);
      const exprArgs = getTail(expr);
      const count = args.length;
      if (count !== exprArgs.length)
          return null;
      let result = { ...substitution };
      let i = 0; // Index in pattern
      while (i < count) {
          const arg = args[i];
          const argName = getSymbolName(arg);
          if (argName !== null) {
              if (argName.startsWith('__')) {
                  // Match 0 or more expressions (__) or 1 or more (___)
                  let j = 0; // Index in subject
                  if (args[i + 1] === undefined) {
                      // No more args after, go till the end
                      j = exprArgs.length + 1;
                  }
                  else {
                      // Capture till the next matching arg
                      let found = false;
                      while (!found && j < exprArgs.length) {
                          found = match(args[i + 1], exprArgs[j], options) !== null;
                          j += 1;
                      }
                      if (!found)
                          return null;
                  }
                  if (!argName.startsWith('___') && j <= 1)
                      return null;
                  result = captureWildcard(argName, ['Sequence', ...exprArgs.splice(0, j - 1)], result);
              }
              else if (argName.startsWith('_')) {
                  result = captureWildcard(argName, exprArgs.shift(), result);
              }
              else {
                  const sub = match(arg, exprArgs.shift(), options);
                  if (sub === null)
                      return null;
                  result = { ...result, ...sub };
              }
          }
          else {
              const sub = match(arg, exprArgs.shift(), options);
              if (sub === null)
                  return null;
              result = { ...result, ...sub };
          }
          if (result === null)
              return null;
          i += 1;
      }
      return result;
  }
  function match(pattern, expr, options) {
      console.assert(!hasWildcards(expr) || hasWildcards(pattern));
      return matchRecursive(expr, pattern, {}, options !== null && options !== void 0 ? options : { numericalTolerance: NUMERICAL_TOLERANCE });
  }
  function count(exprs, pattern, options) {
      let result = 0;
      for (const expr of exprs) {
          if (match(expr, pattern, options) !== null)
              result += 1;
      }
      return result;
  }
  function substitute(expr, substitution) {
      var _a;
      //
      // Symbol
      //
      const symbol = getSymbolName(expr);
      if (symbol !== null) {
          if (symbol.startsWith('_')) {
              return (_a = substitution[getWildcardName(symbol)]) !== null && _a !== void 0 ? _a : expr;
          }
          return expr;
      }
      //
      // Dictionary
      //
      const dict = getDictionary(expr);
      if (dict !== null) {
          const result = {};
          for (const key of Object.keys(dict)) {
              result[key] = substitute(dict[key], substitution);
          }
          return { dict: result };
      }
      //
      // Function
      //
      const head = getFunctionHead(expr);
      if (head !== null) {
          let result = [substitute(head, substitution)];
          for (const arg of getTail(expr)) {
              const symbol = getSymbolName(arg);
              if (symbol !== null && symbol.startsWith('__')) {
                  // Wildcard sequence: `__` or `___`
                  const seq = substitution[getWildcardName(symbol)];
                  if (seq === undefined || getFunctionName(seq) !== 'Sequence') {
                      result.push(symbol);
                  }
                  else {
                      result = result.concat(getTail(seq));
                  }
              }
              else {
                  result.push(substitute(arg, substitution));
              }
          }
          return result;
      }
      return expr;
  }
  function getWildcardName(s) {
      const m = s.match(/^__?_?([a-zA-Z0-9]+)/);
      if (m === null)
          return '';
      return m[1];
  }

  class ExpressionMap {
      constructor(source) {
          this._items = source
              ? new Map(source instanceof ExpressionMap ? source._items : source)
              : new Map();
      }
      has(expr) {
          for (const x of this._items.keys())
              if (match(expr, x))
                  return true;
          return false;
      }
      get(expr) {
          for (const [x, v] of this._items)
              if (match(expr, x))
                  return v;
          return undefined;
      }
      // match(
      //   pattern: Expression<T>
      // ): [expression: { [symbol: string]: Expression<T> }, value: T][] {
      //   const result: [
      //     expression: { [symbol: string]: Expression<T> },
      //     value: T
      //   ][] = [];
      //   for (const [assumption, value] of this._items) {
      //     if (match(pattern, assumption)) {
      //       result.push([assumption, value]);
      //     }
      //   }
      //   return result;
      // }
      set(expr, value) {
          for (const x of this._items.keys()) {
              if (match(expr, x)) {
                  this._items.set(x, value);
                  return;
              }
          }
          this._items.set(expr, value);
      }
      delete(expr) {
          this._items.delete(expr);
      }
      [Symbol.iterator]() {
          return this._items.entries();
      }
      entries() {
          return this._items.entries();
      }
  }

  function internalIs(engine, proposition) {
      let val = true;
      [proposition, val] = normalizeProposition(proposition);
      const result = engine.assumptions.get(proposition);
      if (result === undefined)
          return undefined;
      return result === val;
  }
  function normalizeProposition(proposition) {
      var _a, _b, _c;
      let val = true;
      const head = getFunctionName(proposition);
      if (head === 'Not') {
          [proposition, val] = normalizeProposition((_a = getArg(proposition, 1)) !== null && _a !== void 0 ? _a : MISSING);
          val = !val;
      }
      else if (head === 'NotEqual') {
          val = false;
          proposition = ['Equal', (_b = getArg(proposition, 1)) !== null && _b !== void 0 ? _b : MISSING];
      }
      else if (head === 'NotElement') {
          val = false;
          proposition = ['Element', (_c = getArg(proposition, 1)) !== null && _c !== void 0 ? _c : MISSING];
      }
      return [proposition, val];
  }
  function internalAssume(engine, proposition) {
      proposition = engine.canonical(proposition);
      const head = getFunctionName(proposition);
      if (!head)
          throw new CortexError({ message: 'expected-predicate' });
      let val = true;
      if (head === 'And') {
          for (const prop of getTail(proposition)) {
              const result = internalAssume(engine, prop);
              if (result !== 'ok')
                  return result;
          }
      }
      else {
          [proposition, val] = normalizeProposition(proposition);
      }
      const v = engine.is(proposition);
      // Is the proposition a contradiction or tautology?
      if (v !== undefined) {
          if (v === val)
              return 'tautology';
          if (v !== val)
              return 'contradiction';
      }
      // Add a new assumption
      engine.assumptions.set(proposition, val);
      // @todo: could check any assumptions that have become tautologies
      // (i.e. if `proposition` was more general than an existing assumption)
      // and remove them.
      return 'ok';
  }

  // Other domains to consider:
  const DOMAIN_PARENT = {
      Anything: [],
      Expression: 'Anything',
      Domain: ['Set', 'Symbol'],
      ParametricDomain: ['Domain', 'Function'],
      MaybeBoolean: 'Expression',
      Boolean: 'MaybeBoolean',
      Collection: 'Expression',
      Dictionary: 'Collection',
      List: 'Collection',
      Sequence: 'Collection',
      Tuple: 'Collection',
      Set: 'Collection',
      FiniteSet: 'Set',
      InfiniteSet: 'Set',
      // https://en.wikipedia.org/wiki/Category_of_sets
      EmptySet: 'FiniteSet',
      String: 'Expression',
      Symbol: 'String',
      Function: 'Expression',
      Predicate: 'Function',
      LogicalFunction: 'Predicate',
      // https://en.wikipedia.org/wiki/List_of_mathematical_functions
      TranscendentalFunction: 'Function',
      AlgebraicFunction: 'Function',
      PeriodicFunction: 'Function',
      TrigonometricFunction: ['PeriodicFunction', 'TranscendentalFunction'],
      HyperbolicFunction: 'TranscendentalFunction',
      MonotonicFunction: 'Function',
      StrictMonotonicFunction: 'MonotonicFunction',
      ContinuousFunction: 'Function',
      DifferentiableFunction: 'ContinuousFunction',
      InfinitelyDifferentiableFunction: 'DifferentiableFunction',
      RationalFunction: ['AlgebraicFunction', 'ContinuousFunction'],
      PolynomialFunction: ['AlgebraicFunction', 'InfinitelyDifferentiableFunction'],
      QuadraticFunction: 'PolynomialFunction',
      LinearFunction: ['QuadraticFunction', 'MonotonicFunction'],
      ConstantFunction: 'LinearFunction',
      Number: 'Set',
      ImaginaryNumber: ['ComplexNumber', 'InfiniteSet'],
      ComplexNumber: 'ExtendedComplexNumber',
      ExtendedComplexNumber: 'Number',
      ComplexInfinity: 'ExtendedComplexNumber',
      NumberZero: ['CompositeNumber', 'ImaginaryNumber', 'FiniteSet'],
      NaturalNumber: 'Integer',
      CompositeNumber: 'NaturalNumber',
      PrimeNumber: 'NaturalNumber',
      Integer: ['RationalNumber', 'ExtendedInteger'],
      ExtendedInteger: 'ExtendedRationalNumber',
      RationalNumber: ['AlgebraicNumber', 'ExtendedRationalNumber'],
      IrrationalNumber: 'RealNumber',
      TranscendentalNumber: ['IrrationalNumber', 'ImaginaryNumber'],
      AlgebraicNumber: 'IrrationalNumber',
      RealNumber: ['ComplexNumber', 'ExtendedRealNumber'],
      ExtendedRealNumber: 'ExtendedComplexNumber',
      ExtendedNaturalNumber: 'ExtendedInteger',
      ExtendedRationalNumber: 'ExtendedRealNumber',
      SignedInfinity: 'ExtendedNaturalNumber',
      Tensor: 'Expression',
      Scalar: 'Tensor',
      Vector: 'Matrix',
      Row: 'Vector',
      Column: 'Vector',
      Matrix: 'Tensor',
      // https://en.wikipedia.org/wiki/List_of_named_matrices
      ComplexTensor: 'Tensor',
      RealTensor: 'ComplexTensor',
      IntegerTensor: 'RealTensor',
      LogicalTensor: 'IntegerTensor',
      SquareMatrix: 'Matrix',
      MonomialMatrix: 'SquareMatrix',
      TriangularMatrix: 'SquareMatrix',
      UpperTriangularMatrix: 'TriangularMatrix',
      LowerTriangularMatrix: 'TriangularMatrix',
      PermutationMatrix: ['MonomialMatrix', 'LogicalTensor', 'OrthogonalMatrix'],
      OrthogonalMatrix: ['SquareMatrix', 'RealTensor'],
      DiagonalMatrix: ['UpperTriangularMatrix', 'LowerTriangularMatrix'],
      IdentityMatrix: ['DiagonalMatrix', 'SymmetricMatrix', 'PermutationMatrix'],
      ZeroMatrix: ['DiagonalMatrix', 'SymmetricMatrix', 'PermutationMatrix'],
      SymmetricMatrix: ['HermitianMatrix', 'SquareMatrix', 'RealTensor'],
      HermitianMatrix: 'ComplexTensor',
      Quaternion: ['SquareMatrix', 'ComplexTensor'],
  };
  const DOMAIN_WIKIDATA = {
      // set of numbers: Q3054943, number: Q11563
      Function: 'Q11348',
      ComplexNumber: 'Q26851286',
      Integer: 'Q47007735',
      ImaginaryNumber: 'Q47310259',
      NaturalNumber: 'Q28920052', //  0, 1, 2, 3...
  };
  const DOMAIN_VALUE = {
      MaybeBoolean: ['Union', 'Boolean', ['Set', 'Maybe']],
      NaturalNumber: ['Union', 'CompositeNumber', 'PrimeNumber'],
      Scalar: ['Intersection', 'Row', 'Column'],
      TriangularMatrix: ['Union', 'UpperTriangularMatrix', 'LowerTriangularMatrix'],
      Vector: ['Union', 'Row', 'Column'],
  };
  const DOMAIN_COUNT = {
      Boolean: 2,
      MaybeBoolean: 3,
      EmptySet: 0,
      IdentityMatrix: 1,
      ZeroMatrix: 1,
      NumberZero: 1,
  };
  const PARAMETRIC_DOMAIN = {
      Range: {
          range: 'ParametricDomain',
          evaluate: (_engine, min, max) => {
              min = Math.round(min);
              max = Math.round(max);
              if (Number.isNaN(min) || Number.isNaN(max))
                  return 'EmptySet';
              if (min > max)
                  return 'EmptySet';
              if (min === -Infinity && max === +Infinity)
                  return 'Integer';
              if (min === 0 && max === +Infinity)
                  return 'NaturalNumber';
              if (min === 0 && max === 0)
                  return 'NumberZero';
              return ['Range', min, max];
          },
      },
      Interval: {
          range: 'ParametricDomain',
          evaluate: (_engine, min, max) => {
              if (Number.isNaN(min) || Number.isNaN(max))
                  return 'EmptySet';
              if (min > max)
                  return 'EmptySet';
              if (min === -Infinity && max === +Infinity) {
                  return 'RealNumber';
              }
              if (min === 0 && max === 0)
                  return 'NumberZero';
              return ['Interval', min, max];
          },
      },
      // String: {
      //   signatures: [
      //     {
      //       args: [],
      //       result: 'Domain',
      //       evaluate: () => 'String',
      //     },
      //     {
      //       args: ['NaturalNumber'],
      //       result: 'ParametricDomain',
      //       evaluate: (_engine, min: number) => {
      //         min = Math.round(min);
      //         if (Number.isNaN(min)) return 'EmptySet';
      //         if (min < 0) return 'EmptySet';
      //         if (min === +Infinity) return 'EmptySet';
      //         return ['String', min, min];
      //       },
      //     },
      //     {
      //       args: ['NaturalNumber'],
      //       result: 'ParametricDomain',
      //       evaluate: (_engine, min: number, max: number) => {
      //         min = Math.round(min);
      //         max = Math.round(max);
      //         if (Number.isNaN(min) || Number.isNaN(max)) return 'EmptySet';
      //         if (min < 0) return 'EmptySet';
      //         if (min === +Infinity) return 'EmptySet';
      //         if (min > max) return 'EmptySet';
      //         if (min === 0 && max === +Infinity) return 'EmptySet';
      //         return ['String', min, max];
      //       },
      //     },
      //   ],
      // },
  };
  /* {
      "resource": "/Users/arno/dev/math-json/src/compute-engine/dictionary/domains.ts",
      "owner": "typescript",
      "code": "2322",
      "severity": 8,
      "message": "Type '{ supersets: undefined[]; domain: string; }' is not
     assignable to type 'SetDefinition'.\n  Type '{ supersets: undefined[];
      domain: string; }' is missing the following properties from type
      '{ iterable: boolean; iterator?: { next: () => Expression; done: () => boolean; };
       indexable: boolean; at: (index: number) => Expression;
       countable: boolean; size: () => number;
       isElementOf?: (expr: Expression) => boolean; }': iterable,
       indexable, at, countable, size",
      "source": "ts",
      "startLineNumber": 172,
      "startColumn": 9,
      "endLineNumber": 172,
      "endColumn": 16,
      "relatedInformation": [
          {
              "startLineNumber": 171,
              "startColumn": 5,
              "endLineNumber": 171,
              "endColumn": 35,
              "message": "The expected type comes from this index signature.",
              "resource": "/Users/arno/dev/math-json/src/compute-engine/dictionary/domains.ts"
          }
      ]
  }
  */
  function getDomainsDictionary() {
      var _a;
      const result = { Nothing: { countable: true, supersets: [], domain: 'Domain' } };
      for (const domain of Object.keys(DOMAIN_PARENT)) {
          const parents = Array.isArray(DOMAIN_PARENT[domain])
              ? DOMAIN_PARENT[domain]
              : [DOMAIN_PARENT[domain]];
          result[domain] = (_a = PARAMETRIC_DOMAIN[domain]) !== null && _a !== void 0 ? _a : {};
          result[domain] = {
              domain: PARAMETRIC_DOMAIN[domain] ? 'ParametricDomain' : 'Domain',
              wikidata: DOMAIN_WIKIDATA[domain],
              supersets: parents,
              value: DOMAIN_VALUE,
              countable: DOMAIN_COUNT[domain] !== undefined,
              size: () => DOMAIN_COUNT[domain],
              ...result[domain],
          };
          for (const parent of parents) {
              if (parent !== 'Anything' && !DOMAIN_PARENT[parent]) {
                  throw new Error(`Unknown parent of domain "${domain}": "${parent}"`);
              }
          }
      }
      // Add all the supersets of Nothing: all the sets that are not the parent of anyone
      const sets = new Set();
      for (const domain of Object.keys(result))
          sets.add(domain);
      for (const domain of Object.keys(result)) {
          for (const parent of result[domain].supersets)
              sets.delete(parent);
      }
      sets.delete('Nothing');
      result['Nothing'].supersets = [...sets.values()];
      // for (const domain of Object.keys(result)) {
      //   for (const parent of result[domain].supersets) {
      //     for (const candidate of result[domain].supersets) {
      //       if (candidate !== parent && isSubdomainOf(result, candidate, parent)) {
      //         throw new Error(
      //           `In domain ${domain}, the parent ${candidate} is redundant with ${parent}`
      //         );
      //       }
      //     }
      //   }
      // }
      for (const domain of Object.keys(result)) {
          let found = false;
          let count = 0;
          let parents = [domain];
          while (count < 512 && !found) {
              const parent = parents.pop();
              found = parent === 'Anything';
              if (!found)
                  parents = [...parent, ...result[parent].supersets];
              count++;
          }
          if (!found) {
              throw new Error(`The "${domain}" domain cannot reach "Anything"`);
          }
      }
      return result;
  }
  function canonicalDomain(engine, expr) {
      // @todo
      // Handle ['Interval', -Infinity, Infinity], etc...
      return expr;
  }

  const CORE_DICTIONARY = {
      Apply: {
          domain: 'Function',
          range: 'Anything',
      },
      About: {
          domain: 'Function',
          range: 'Dictionary',
      },
      BaseForm: {
          domain: 'Function',
          range: 'Integer',
      },
      /** Create a local scope. First argument is a dictionary of local variables.
       * They are evaluated in the context of the parent scope. The second argument
       * is an expression to be evaluated in the context of the new scope.
       * ["Block", ["List", ["Equal", "x", 1]], [...]]
       */
      Block: {
          domain: 'Function',
          range: 'Anything',
      },
      /** Return the domain of an expression */
      Domain: {
          domain: 'ParametricDomain',
          range: 'Domain',
      },
      Evaluate: {
          domain: 'Function',
          range: 'Anything',
      },
      Parentheses: {
          domain: 'Function',
          threadable: true,
          pure: false,
          range: 'Anything',
      },
      Head: {
          domain: 'Function',
          range: 'Anything',
      },
      Lambda: {
          domain: 'Function',
          wikidata: 'Q567612',
          hold: 'all',
          range: 'Anything',
      },
      Latex: {
          domain: 'Function',
          range: 'String',
      },
      String: {
          domain: 'Function',
          threadable: true,
          range: 'String',
      },
      Symbol: {
          domain: 'Function',
          threadable: true,
          range: 'Symbol',
      },
      Tail: {
          domain: 'Function',
          range: 'List',
      },
      // Pattern: {},
  };
  // xcas/gias https://www-fourier.ujf-grenoble.fr/~parisse/giac/doc/en/cascmd_en/cascmd_en.html
  // https://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1720009.1
  // length(expr, depth:integer) (for a list, an expression, etc..)
  // shape
  // length
  // depth
  /*
   DICTIONARY
   aka Association in Wolfram, Dictionary in Python and Swift, Record in Maple,
   Map Containers in mathlab, Map in Javascript
   Dictionary("field1", "value1", "field2", "value2"...)
   Need a new atomic 'dict' MathJSON type?
    {dict: {"field1": "value1", "field2": "value2"}}
  */
  // LISTS
  // take(n, list) -> n first elements of the list
  // https://www.mathworks.com/help/referencelist.html?type=function&listtype=cat&category=&blocktype=&capability=&s_tid=CRUX_lftnav        // list
  // repeat(x) -> infinite list with "x" as argument
  // cycle(list) -> infinitely repeating list, i.e. cycle({1, 2, 3}) -> {1, 2, 3, 1, 2, 3, 1...}
  // iterate(f, acc) -> {f(acc), f(f(acc)), f(f(f(acc)))...}
  // == NestList ??
  // Append (python) / Push
  // Insert(i, x)
  // Pop(): remove last, Pop(i): remove item at [i]
  // Range
  // index
  // Evaluate
  // Bind // replace  ( x-> 1)
  // Domain
  // min, max
  // None -- constant for some options
  // rule ->
  // delayed-rule: :> (value of replacement is recalculated each time)
  // set, set delayed
  // join
  // convert(expr, CONVERT_TO, OPTIONS) -- See Maple
  // convert(expr, options), with options such as 'cos', 'sin, 'trig, 'exp', 'ln', 'latex', 'string', etc...)
  // N
  // set, delayed-set
  // spread -> expand the elements of a list. If inside a list, insert the list into its parent
  // compose (compose(f, g) -> a new function such that compose(f, g)(x) -> f(g(x))
  // Symbol(x) -> x as a symbol, e.g. symbol('x' + 'y') -> `xy` (and registers it)
  // Symbols() -> return list of all known symbols
  // variables() -> return list of all free variables

  const LOGIC_DICTIONARY = {
      True: { domain: 'Boolean', constant: true },
      False: { domain: 'Boolean', constant: true },
      Maybe: { domain: 'MaybeBoolean', constant: true },
      And: {
          domain: 'LogicalFunction',
          threadable: true,
          associative: true,
          commutative: true,
          idempotent: true,
          range: 'MaybeBoolean',
      },
      Or: {
          domain: 'LogicalFunction',
          threadable: true,
          associative: true,
          commutative: true,
          idempotent: true,
          range: 'MaybeBoolean',
      },
      Not: {
          domain: 'LogicalFunction',
          involution: true,
          range: 'MaybeBoolean',
      },
      Equivalent: {
          domain: 'LogicalFunction',
          range: 'MaybeBoolean',
      },
      Implies: { domain: 'LogicalFunction', range: 'MaybeBoolean' },
      Exists: { domain: 'LogicalFunction', range: 'MaybeBoolean' },
      Equal: { domain: 'LogicalFunction', range: 'MaybeBoolean' },
      NotEqual: {
          domain: 'Function',
          wikidata: 'Q28113351',
          commutative: true,
          range: 'MaybeBoolean',
      },
  };

  // Set operations:
  // https://query.wikidata.org/#PREFIX%20wd%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2F%3E%0APREFIX%20wdt%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fprop%2Fdirect%2F%3E%0A%0ASELECT%20DISTINCT%20%3Fitem%0AWHERE%20%7B%0A%20%20%20%20%3Fitem%20wdt%3AP31%2a%20wd%3AQ1964995%0A%7D%0A
  const SETS_DICTIONARY = {
      EmptySet: {
          domain: 'EmptySet',
          constant: true,
          wikidata: 'Q226183',
      },
      CartesianProduct: {
          // Aka the product set, the set direct product or cross product
          // Notation: \times
          domain: 'Function',
          wikidata: 'Q173740',
          range: 'Set',
          evaluate: cartesianProduct,
      },
      Intersection: {
          // notation: \Cap
          domain: 'Function',
          wikidata: 'Q185837',
          threadable: true,
          associative: true,
          commutative: true,
          idempotent: true,
          involution: true,
          range: 'Set',
          evaluate: intersection,
      },
      Complement: {
          // Return the elements of the first argument that are not in any of
          // the subsequent lists
          domain: 'Function',
          wikidata: 'Q242767',
          range: 'Set',
      },
      Union: {
          // Works on set, but can also work on lists
          domain: 'Function',
          wikidata: 'Q185359',
          threadable: true,
          associative: true,
          commutative: true,
          idempotent: true,
          involution: true,
          range: 'Set',
          evaluate: union,
      },
      // disjoint union Q842620 âŠ”
      SymmetricDifference: {
          // symmetric difference = disjunctive union  (circled minus)
          /* = Union(Complement(a, b), Complement(b, a) */
          /* Corresponds to XOR in boolean logic */
          domain: 'Function',
          wikidata: 'Q1147242',
          range: 'Set',
      },
      Subset: {
          domain: 'Predicate',
          range: 'MaybeBoolean',
          evaluate: subset,
      },
      SubsetEqual: {
          domain: 'Predicate',
          range: 'MaybeBoolean',
          evaluate: subsetEqual,
      },
      SetMinus: {
          domain: 'Function',
          wikidata: 'Q18192442',
          range: 'MaybeBoolean',
          evaluate: setMinus,
      },
  };
  function subset(_engine, _lhs, _rhs) {
      return 'False';
  }
  function subsetEqual(_engine, _lhs, _rhs) {
      return 'False';
  }
  function union(_engine, ..._args) {
      return 'EmptySet';
  }
  function intersection(_engine, ..._args) {
      return 'EmptySet';
  }
  function setMinus(_engine, _lhs, _rhs) {
      return 'EmptySet';
  }
  function cartesianProduct(_engine, _lhs, _rhs) {
      return 'EmptySet';
  }

  const COLLECTIONS_DICTIONARY = {
  // KeyValue: { domain: 'Function' },
  // Keys: { domain: 'Function' },
  // Entries: { domain: 'Function' },
  // Dictionary: { domain: 'Collection' },
  // Dictionary: {
  //   domain: 'Function',
  //   range: 'Dictionary',
  // },
  // List: { domain: 'Collection' },
  // Tuple: { domain: 'Collection' },
  // Sequence: { domain: 'Collection' },
  // Reverse
  // ForEach / Apply
  // Map
  // ReduceRight
  // ReduceLeft
  // first    or head
  // rest     or tail
  // cons -> cons(first (element), rest (list)) = list
  // append -> append(list, list) -> list
  // reverse
  // rotate
  // in
  // map   â¡ map(2x, x, list) ( 2 â¢ x | x âˆˆ [ 0 , 10 ] )
  // such-that {x âˆˆ Z | x â‰¥ 0 âˆ§ x < 100 âˆ§ x 2 âˆˆ Z}
  // select : picks out all elements ei of list for which crit[ei] is True.
  // sort
  // contains / find
  };

  // Names after ISO 80000 Section 13
  const S2 = ['Sqrt', 2];
  const S3 = ['Sqrt', 3];
  const S5 = ['Sqrt', 5];
  const S6 = ['Sqrt', 6];
  // @todo: add more values from https://en.wikipedia.org/wiki/Trigonometric_functions
  const SPECIAL_VALUES = new ExpressionMap([
      [
          ['Divide', 'Pi', 12],
          {
              Sin: ['Divide', ['Subtract', S6, S2], 4],
              Cos: ['Divide', ['Add', S6, S2], 4],
              Tan: ['Subtract', [2, S3]],
              Cot: ['Add', [2, S3]],
              Sec: ['Subtract', [S6, S2]],
              Csc: ['Add', [S6, S2]],
          },
      ],
      [
          ['Divide', 'Pi', 10],
          {
              Sin: ['Divide', ['Subtract', S5, 1], 4],
              Cos: ['Divide', ['Sqrt', ['Add', 10, ['Multiply', 2, S5]]], 4],
              Tan: ['Divide', ['Sqrt', ['Subtract', 25, ['Multiply', 10, S5]]], 4],
              Cot: ['Sqrt', ['Add', 5, ['Multiply', 2, S5]]],
              Sec: ['Divide', ['Sqrt', ['Subtract', 50, ['Multiply', 10, S5]]], 5],
              Csc: ['Add', 1, S5],
          },
      ],
      [
          ['Divide', 'Pi', 4],
          {
              Sin: ['Divide', S2, 2],
              Cos: ['Divide', S2, 2],
              Tan: 1,
              Cot: 1,
              Sec: S2,
              Csc: S2,
          },
      ],
      [
          ['Divide', 'Pi', 3],
          {
              Sin: ['Divide', S3, 2],
              Cos: 'Half',
              Tan: S3,
              Cot: ['Divide', S3, 3],
              Sec: 2,
              Csc: ['Divide', ['Multiply', 2, S3], 3],
          },
      ],
      [
          ['Divide', 'Pi', 2],
          {
              Sin: 1,
              Cos: 0,
              Tan: +Infinity,
              Cot: 0,
              Sec: +Infinity,
              Csc: 1,
          },
      ],
  ]);
  const TRIGONOMETRY_DICTIONARY = {
      //
      // Constants
      //
      Degrees: {
          /* = Pi / 180 */
          domain: 'Real',
          constant: true,
          value: 0.017453292519943295769236907,
      },
      MinusDoublePi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [MULTIPLY, -2, 'Pi'],
      },
      MinusPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [NEGATE, 'Pi'],
      },
      MinusHalfPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, [NEGATE, 'Pi'], 2],
      },
      QuarterPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, 'Pi', 4],
      },
      ThirdPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, 'Pi', 3],
      },
      // Used in definitions of the range of some trigonometric functions
      HalfPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [DIVIDE, 'Pi', 2],
      },
      TwoThirdPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [MULTIPLY, 2, [DIVIDE, 'Pi', 3]],
      },
      ThreeQuarterPi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [MULTIPLY, 3, [DIVIDE, 'Pi', 4]],
      },
      Pi: {
          domain: 'TranscendentalNumber',
          constant: true,
          wikidata: 'Q167',
          value: (engine) => {
              if (engine.numericFormat === 'decimal')
                  return decimal.exports.Decimal.acos(-1);
              if (engine.numericFormat === 'complex')
                  return complex.exports.Complex.PI;
              return Math.PI;
          },
      },
      DoublePi: {
          domain: 'TranscendentalNumber',
          constant: true,
          hold: false,
          value: [MULTIPLY, 2, 'Pi'],
      },
      //
      // Functions
      //
      Arccos: {
          domain: 'TrigonometricFunction',
          range: ['Interval', 0, 'Pi'],
          numeric: true,
          value: ['Subtract', 'HalfPi', ['Arcsin', '_']],
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Arccos']) !== null && _b !== void 0 ? _b : [
                  'Subtract',
                  'HalfPi',
                  ['Arcsin', x],
              ];
          },
          evalNumber: (_ce, x) => Math.acos(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.acos(x),
          evalComplex: (_ce, x) => complex.exports.Complex.acos(x),
      },
      Arcosh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', 0, Infinity],
          numeric: true,
          value: ['Ln', ['Add', '_', ['Sqrt', ['Subtract', ['Square', '_'], 1]]]],
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Arccosh']) !== null && _b !== void 0 ? _b : [
                  'Ln',
                  ['Add', x, ['Sqrt', ['Subtract', ['Square', x], 1]]],
              ];
          },
          evalNumber: (_ce, x) => Math.acosh(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.acosh(x),
          evalComplex: (_ce, x) => complex.exports.Complex.acosh(x),
      },
      // Arccot: {
      //   domain: 'TrigonometricFunction',
      //   numeric: true,
      // },
      // Note Arcoth, not Arccoth
      // Arcoth: {
      //   domain: 'HyperbolicFunction',
      //   numeric: true,
      // },
      // Arcsec: {
      //   domain: 'TrigonometricFunction',
      //   numeric: true,
      // },
      // Arsech: {
      //   domain: 'HyperbolicFunction',
      //   numeric: true,
      // },
      // Arccsc: {
      //   domain: 'TrigonometricFunction',
      //   numeric: true,
      // },
      // Arcsch: {
      //   domain: 'HyperbolicFunction',
      //   numeric: true,
      // },
      Arcsin: {
          domain: 'TrigonometricFunction',
          range: ['Interval', 'MinusHalfPi', 'HalfPi'],
          numeric: true,
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Arcsin']) !== null && _b !== void 0 ? _b : [
                  'Multiply',
                  2,
                  ['Arctan2', x, ['Add', 1, ['Sqrt', ['Subtract', 1, ['Square', x]]]]],
              ];
          },
          value: [
              'Multiply',
              2,
              ['Arctan2', '_', ['Add', 1, ['Sqrt', ['Subtract', 1, ['Square', '_']]]]],
          ],
          evalNumber: (_ce, x) => Math.asin(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.asin(x),
          evalComplex: (_ce, x) => complex.exports.Complex.asin(x),
      },
      //Note: Arsinh, not Arcsinh
      Arsinh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -Infinity, Infinity],
          numeric: true,
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Arsinh']) !== null && _b !== void 0 ? _b : [
                  'Ln',
                  ['Add', x, ['Sqrt', ['Add', ['Square', x], 1]]],
              ];
          },
          value: ['Ln', ['Add', '_', ['Sqrt', ['Add', ['Square', '_'], 1]]]],
          evalNumber: (_ce, x) => Math.asinh(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.asinh(x),
          evalComplex: (_ce, x) => complex.exports.Complex.asinh(x),
      },
      Arctan: {
          wikidata: 'Q2257242',
          domain: 'TrigonometricFunction',
          range: ['Interval', 'MinusHalfPi', 'HalfPi'],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Arctan']) !== null && _b !== void 0 ? _b : x; },
          evalNumber: (_ce, x) => Math.atan(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.atan(x),
          evalComplex: (_ce, x) => complex.exports.Complex.atan(x),
      },
      Arctan2: {
          wikidata: 'Q776598',
          range: ['Interval', 'MinusPi', 'Pi'],
          domain: 'TrigonometricFunction',
          numeric: true,
          evalNumber: (_ce, x, y) => Math.atan2(x, y),
          evalDecimal: (_ce, x, y) => decimal.exports.Decimal.atan2(x, y),
          evalComplex: (_ce, x, y) => complex.exports.Complex.atan2(x, y),
      },
      Artanh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -Infinity, Infinity],
          numeric: true,
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Artanh']) !== null && _b !== void 0 ? _b : [
                  'Multiply',
                  'Half',
                  ['Ln', ['Divide', ['Add', 1, x], ['Subtract', 1, x]]],
              ];
          },
          value: [
              'Multiply',
              'Half',
              ['Ln', ['Divide', ['Add', 1, '_'], ['Subtract', 1, '_']]],
          ],
          evalNumber: (_ce, x) => Math.atanh(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.atanh(x),
          evalComplex: (_ce, x) => complex.exports.Complex.atanh(x),
      },
      Cosh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', 1, Infinity],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Cosh']) !== null && _b !== void 0 ? _b : x; },
          value: [
              'Multiply',
              'Half',
              ['Add', ['Exp', '_'], ['Exp', ['Negate', '_']]],
          ],
          evalNumber: (_ce, x) => Math.cosh(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.cosh(x),
          evalComplex: (_ce, x) => complex.exports.Complex.cosh(x),
      },
      Cos: {
          domain: 'TrigonometricFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Cos']) !== null && _b !== void 0 ? _b : ['Sin', ['Add', x, 'HalfPi']]; },
          value: ['Sin', ['Add', '_', 'HalfPi']],
          evalNumber: (_ce, x) => Math.cos(x),
          evalDecimal: (_ce, x) => decimal.exports.Decimal.cos(x),
          evalComplex: (_ce, x) => complex.exports.Complex.cos(x),
      },
      Cot: {
          domain: 'TrigonometricFunction',
          range: 'ComplexNumber',
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Cot']) !== null && _b !== void 0 ? _b : ['Divide', ['Cos', x], ['Sin', x]]; },
          value: ['Divide', ['Cos', '_'], ['Sin', '_']],
          evalNumber: (_ce, x) => 1 / Math.tan(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.tan(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.tan(x)),
      },
      Coth: {
          domain: 'HyperbolicFunction',
          range: 'ComplexNumber',
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Coth']) !== null && _b !== void 0 ? _b : ['Divide', 1, ['Tanh', x]]; },
          value: ['Divide', 1, ['Tanh', '_']],
          evalNumber: (_ce, x) => 1 / Math.tanh(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.tanh(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.tanh(x)),
      },
      Csc: {
          domain: 'TrigonometricFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Csc']) !== null && _b !== void 0 ? _b : ['Divide', 1, ['Sin', x]]; },
          value: ['Divide', 1, ['Sin', '_']],
          evalNumber: (_ce, x) => 1 / Math.tanh(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.tanh(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.tanh(x)),
      },
      Csch: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Csch']) !== null && _b !== void 0 ? _b : ['Divide', 1, ['Sinh', x]]; },
          value: ['Divide', 1, ['Sinh', '_']],
          evalNumber: (_ce, x) => 1 / Math.sinh(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.sinh(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.sinh(x)),
      },
      /* converts (radius, angle) -> (x, y) */
      FromPolarCoordinates: {
          domain: 'Function',
          range: ['TupleOf', 'RealNumber', 'RealNumber'],
      },
      /** = sin(z/2)^2 = (1 - cos z) / 2*/
      Haversine: {
          wikidata: 'Q2528380',
          domain: 'TrigonometricFunction',
          range: ['Interval', 0, 1],
          value: ['Divide', ['Subtract', 1, ['Cos', '_']], 2],
          numeric: true,
      },
      // sqrt(x*x + y*y)
      Hypot: {
          domain: 'Function',
          range: ['Interval', 0, Infinity],
          value: ['Sqrt', ['Square', '_'], ['Square', '_2']],
          evalNumber: (_ce, x, y) => Math.sqrt(x * x * +y * y),
          evalDecimal: (_ce, x, y) => decimal.exports.Decimal.sqrt(x.mul(x).add(y.mul(y))),
          evalComplex: (_ce, x, y) => complex.exports.Complex.sqrt(x.mul(x).add(y.mul(y))),
      },
      InverseFunction: {
          domain: 'Function',
          range: 'Function',
          simplify: (_ce, x) => {
              var _a, _b;
              const fn = (_a = getArg(x, 1)) !== null && _a !== void 0 ? _a : MISSING;
              if (typeof fn !== 'string')
                  return x;
              return ((_b = {
                  Sin: 'Arcsin',
                  Cos: 'Arccos',
                  Tan: 'Arctan',
                  Sec: 'Arcsec',
                  Csc: ' Arccsc',
                  Sinh: 'Arsinh',
                  Cosh: 'Arcosh',
                  Tanh: 'Artanh',
                  Sech: 'Arcsech',
                  Csch: 'Arcsch',
                  Arcosh: 'Cosh',
                  Arcos: 'Cos',
                  Arccsc: 'Csc',
                  Arcsch: 'Csch',
                  // '??': 'Cot',
                  // '??': 'Coth',
                  Arcsec: 'Sec',
                  Arcsin: 'Sin',
                  Arsinh: 'Sinh',
                  Arctan: 'Tan',
                  Artanh: 'Tanh',
              }[fn]) !== null && _b !== void 0 ? _b : x);
          },
      },
      /** = 2 * Arcsin(Sqrt(z)) */
      InverseHaversine: {
          domain: 'TrigonometricFunction',
          range: ['Interval', ['MinusPi'], 'Pi'],
          numeric: true,
          value: ['Multiply', 2, ['Arcsin', ['Sqrt', '_']]],
      },
      Sec: {
          domain: 'TrigonometricFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Sec']) !== null && _b !== void 0 ? _b : ['Divide', 1, ['Cos', x]]; },
          value: ['Divide', 1, ['Cos', '_']],
          evalNumber: (_ce, x) => 1 / Math.cos(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.cos(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.cos(x)),
      },
      Sech: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Sech']) !== null && _b !== void 0 ? _b : ['Divide', 1, ['Cosh', x]]; },
          value: ['Divide', 1, ['Cosh', '_']],
          evalNumber: (_ce, x) => 1 / Math.cosh(x),
          evalDecimal: (_ce, x) => DECIMAL_ONE.div(decimal.exports.Decimal.cosh(x)),
          evalComplex: (_ce, x) => complex.exports.Complex.ONE.div(complex.exports.Complex.cosh(x)),
      },
      Sinh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -Infinity, Infinity],
          numeric: true,
          simplify: (_ce, x) => {
              var _a, _b;
              return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Sinh']) !== null && _b !== void 0 ? _b : [
                  'Multiply',
                  'Half',
                  ['Subtract', ['Exp', x], ['Exp', ['Negate', x]]],
              ];
          },
          value: [
              'Multiply',
              'Half',
              ['Subtract', ['Exp', '_'], ['Exp', ['Negate', '_']]],
          ],
      },
      Sin: {
          domain: 'TrigonometricFunction',
          range: ['Interval', -1, 1],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Sin']) !== null && _b !== void 0 ? _b : x; },
          value: [
              'Divide',
              [
                  'Subtract',
                  ['Exp', ['Multiply', 'ImaginaryUnit', '_']],
                  ['Exp', ['Multiply', 'ImaginaryUnit', ['Negate', '_']]],
              ],
              ['Multiply', 2, 'ImaginaryUnit'],
          ],
          evalNumber: (_ce, x) => Math.sin(x),
          evalDecimal: (_ce, x) => x.sin(),
          evalComplex: (_ce, x) => x.sin(),
      },
      Tanh: {
          domain: 'HyperbolicFunction',
          range: ['Interval', -Infinity, Infinity],
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Tanh']) !== null && _b !== void 0 ? _b : ['Divide', ['Sinh', x], ['Cosh', x]]; },
          value: ['Divide', ['Sinh', '_'], ['Cosh', '_']],
          evalNumber: (_ce, x) => Math.tanh(x),
          evalDecimal: (_ce, x) => x.tanh(),
          evalComplex: (_ce, x) => x.tanh(),
      },
      Tan: {
          domain: 'TrigonometricFunction',
          range: 'RealNumber',
          numeric: true,
          simplify: (_ce, x) => { var _a, _b; return (_b = (_a = SPECIAL_VALUES.get(x)) === null || _a === void 0 ? void 0 : _a['Tan']) !== null && _b !== void 0 ? _b : ['Divide', ['Sin', x], ['Cos', x]]; },
          value: ['Divide', ['Sin', '_'], ['Cos', '_']],
          evalNumber: (_ce, x) => Math.tan(x),
          evalDecimal: (_ce, x) => x.tan(),
          evalComplex: (_ce, x) => x.tan(),
      },
      /* converts (x, y) -> (radius, angle) */
      ToPolarCoordinates: {
          domain: 'Function',
          range: ['TupleOf', 'RealNumber', 'RealNumber'],
      },
  };

  function isSetDefinition(def) {
      return def !== null && typeof def === 'object' && 'supersets' in def;
  }
  function isSymbolDefinition(def) {
      return def !== null && typeof def === 'object' && 'constant' in def;
  }
  function isFunctionDefinition(def) {
      return def !== null && typeof def === 'object' && 'range' in def;
  }
  function isCollectionDefinition(def) {
      return def !== null && typeof def === 'object' && 'countable' in def;
  }

  function internalDomain(engine, expr) {
      var _a;
      //
      // 1. Is it a numeric domain (number, Decimal, Complex)?
      //
      const result = inferNumericDomain(expr);
      if (result !== null)
          return result;
      //
      // 2. Is it a symbol?
      // (Note, we've already handled well-known symbols in `inferNumericDomain()`
      //
      const symName = getSymbolName(expr);
      if (symName !== null) {
          // 2.1 Do we have an Element assumption about this symbol
          const domains = engine.ask(['Element', expr, '_domain']);
          if (domains.length > 0) {
              // @todo: we could handle more complex assumptions, i.e. conjunctions, etc...
              if (domains.length === 1) {
                  return domains[0]['domain'];
              }
              // @todo Could query the negative and return:
              //      return ['SetMinus', domain.getArg(domain, 2)];
              return 'Anything';
          }
          // 2.2 Do we have an equality assumption about this symbol?
          // @todo: we could do more:
          // - search for ['Equal', x, '_expr'] and get the domain of expr
          // 2.3 Do we have an inequality assumption about this model?
          // - search for ['Less', x '_expr'], etc... => implies RealNumber
          // 2.4 Does the symbol definition have a domain?
          // (we look for 'Definition' in general, because Domains do not have a
          // SymbolDefinition (they don't necessarily have a value).
          const def = engine.getDefinition(symName);
          if (def && typeof def.domain === 'function') {
              return (_a = def.domain(expr)) !== null && _a !== void 0 ? _a : 'Anything';
          }
          else if (def && def.domain) {
              return def.domain;
          }
          else if (def && 'value' in def && def.value) {
              if (typeof def.value === 'function') {
                  return internalDomain(engine, def.value(engine));
              }
              return internalDomain(engine, def.value);
          }
          return 'Anything';
      }
      //
      // 3. Is it a function?
      //
      const head = getFunctionHead(expr);
      if (typeof head === 'string') {
          const def = engine.getFunctionDefinition(head);
          if (def) {
              if (typeof def.range === 'function') {
                  return def.range(engine, ...getTail(expr));
              }
              else if (def.range !== undefined) {
                  return def.range;
              }
              else if (def.value !== undefined) {
                  return internalDomain(engine, def.value);
              }
          }
      }
      //
      // 4. It's something else: a String or a Dictionary
      //
      if (isStringObject(expr))
          return 'String';
      if (isDictionaryObject(expr))
          return 'Dictionary';
      return null;
  }
  // export function isSubdomainOf(
  //   dict: Dictionary,
  //   lhs: Domain,
  //   rhs: Domain
  // ): boolean {
  //   if (lhs === rhs) return true;
  //   if (typeof lhs !== 'string') return false;
  //   const def = dict[lhs];
  //   if (!isSetDefinition(def)) return false;
  //   for (const parent of def.supersets) {
  //     if (isSubdomainOf(dict, parent, rhs)) return true;
  //   }
  //   return false;
  // }
  function inferNumericDomain(value) {
      var _a, _b;
      if (value === undefined)
          return null;
      //
      // 1. Is it a number?
      //
      const numVal = getNumberValue(value);
      if (numVal !== null && !isNaN(numVal)) {
          if (numVal === 0)
              return 'NumberZero';
          if (!isFinite(numVal))
              return 'SignedInfinity';
          if (Number.isInteger(numVal)) {
              if (SMALL_PRIMES.has(numVal))
                  return 'PrimeNumber';
              if (numVal >= 1 && numVal < LARGEST_SMALL_PRIME)
                  return 'CompositeNumber';
              if (numVal > 0)
                  return 'NaturalNumber';
              return 'Integer';
          }
          if (numVal > 0)
              return ['Interval', ['Open', 0], +Infinity];
          return 'RealNumber';
      }
      //
      // 2 Is it a decimal?
      //
      if (value instanceof decimal.exports.Decimal) {
          if (value.isNaN())
              return 'Number';
          if (value.isZero())
              return 'NumberZero';
          if (!value.isFinite())
              return 'SignedInfinity';
          if (value.isInteger()) {
              if (value.abs().lessThan(Number.MAX_SAFE_INTEGER)) {
                  return inferNumericDomain(value.toNumber());
              }
              if (value.isPositive())
                  return 'NaturalNumber';
              return 'Integer';
          }
          if (value.isPositive())
              return ['Interval', ['Open', 0], +Infinity];
          return 'RealNumber';
      }
      //
      // 3 Is it a complex number?
      //
      if (value instanceof complex.exports.Complex) {
          const c = value;
          if (c.im === 0)
              return inferNumericDomain(c.re);
          if (c.re === 0 && c.im !== 0)
              return 'ImaginaryNumber';
          return 'ComplexNumber';
      }
      if (getFunctionName(value) === 'Complex') {
          const re = (_a = getNumberValue(getArg(value, 1))) !== null && _a !== void 0 ? _a : NaN;
          const im = (_b = getNumberValue(getArg(value, 2))) !== null && _b !== void 0 ? _b : NaN;
          if (im === 0)
              return inferNumericDomain(re);
          if (re === 0 && im !== 0)
              return 'ImaginaryNumber';
          return 'ComplexNumber';
      }
      //
      // 4. Is it a rational?
      //
      let [numer, denom] = getRationalValue(value);
      if (numer !== null && denom !== null) {
          const g = gcd(numer, denom);
          numer = numer / g;
          denom = denom / g;
          if (!Number.isNaN(numer) && !Number.isNaN(denom)) {
              if (numer === 0)
                  return 'NumberZero';
              // The value is a rational number
              if (denom !== 1 && denom !== -1)
                  return 'RationalNumber';
              return inferNumericDomain(numer);
          }
      }
      //
      // 5. Symbol
      //
      const symbol = getSymbolName(value);
      if (symbol !== null) {
          if (symbol === 'NaN')
              return 'Number';
          if (symbol === '+Infinity' || symbol === '-Infinity') {
              return 'SignedInfinity';
          }
          if (symbol === COMPLEX_INFINITY)
              return 'ComplexInfinity';
          if (symbol === IMAGINARY_UNIT)
              return 'ImaginaryNumber';
          if (['Quarter', 'Third', 'Half', 'TwoThird', 'ThreeQuarter'].includes(symbol)) {
              return 'RationalNumber';
          }
          if ([
              'MinusDoublePi',
              'MinusPi',
              'QuarterPi',
              'ThirdPi',
              'HalfPi',
              'TwoThirdPi',
              'ThreeQuarterPi',
              'Pi',
              'DoublePi',
              'ExponentialE',
          ].includes(symbol)) {
              return 'TranscendentalNumber';
          }
          if ([
              'MachineEpsilon',
              'CatalanConstant',
              'GoldenRatio',
              'EulerGamma',
          ].includes(symbol)) {
              return 'RealNumber';
          }
      }
      //
      // 6. Function
      // Note: most of the checking should be done in the function definitions.
      //
      const head = getFunctionName(value);
      if (head === POWER) {
          if (getFunctionName(getArg(value, 2)) === DIVIDE) {
              if (getArg(getArg(value, 2), 1) === 1 &&
                  getArg(getArg(value, 2), 2) === 2) {
                  // It's a square root...
                  const num = getNumberValue(getArg(value, 1));
                  if (num !== null && SMALL_PRIMES.has(num)) {
                      // Square root of a prime is irrational
                      // https://proofwiki.org/wiki/Square_Root_of_Prime_is_Irrational
                      return 'IrrationalNumber';
                  }
              }
          }
      }
      // @todo: the log in a prime base of a prime number is irrational
      return 'RealNumber';
  }

  function getDefaultDictionaries(categories = 'all') {
      if (categories === 'all') {
          return getDefaultDictionaries([
              'domains',
              'core',
              'collections',
              'algebra',
              'arithmetic',
              'calculus',
              'complex',
              'combinatorics',
              'dimensions',
              'inequalities',
              'intervals',
              'linear-algebra',
              'logic',
              'numeric',
              'other',
              'physics',
              'polynomials',
              'relations',
              'statistics',
              'transcendentals',
              'trigonometry',
              'rounding',
              'units',
          ]);
      }
      const result = [];
      for (const category of categories) {
          if (DICTIONARY[category])
              result.push(DICTIONARY[category]);
      }
      return result;
  }
  // export const ADD = 'Q32043';
  // export const SUBTRACT = 'Q40754';
  // export const NEGATE = 'Q715358'; // -x
  // export const RECIPROCAL = 'Q216906'; // 1/x
  // export const MULTIPLY = 'Q40276';
  // export const DIVIDE = 'Q40276';
  // export const POWER = 'Q33456';
  // export const STRING = 'Q184754';
  // export const TEXT = '';
  // export const COMPLEX = 'Q11567'; // â„‚ Set of complex numbers Q26851286
  // export const REAL = 'Q12916'; // â„ Set of real numbers: Q26851380
  // export const RATIONAL = 'Q1244890'; // â„š
  // export const NATURAL_NUMBER = 'Q21199'; // â„•0 (includes 0) or â„•* (wihtout 0) Set of Q28777634
  // // set of positive integers (incl 0): Q47339953
  // // set of natural numbers (w/o 0): Q47007719
  // export const INTEGER = 'Q12503'; // â„¤
  // export const PRIME = 'Q47370614'; // set of prime numbers
  // export const MATRIX = 'Q44337';
  // export const FUNCTION = 'Q11348';
  // export const LIST = 'Q12139612';
  // Unary functions:
  // https://query.wikidata.org/#PREFIX%20wd%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2F%3E%0APREFIX%20wdt%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fprop%2Fdirect%2F%3E%0A%0ASELECT%20DISTINCT%20%3Fitem%0AWHERE%20%7B%0A%20%20%20%20%3Fitem%20wdt%3AP31%2a%20wd%3AQ657596%0A%7D%0A
  // https://query.wikidata.org/#PREFIX%20wd%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2F%3E%0APREFIX%20wdt%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fprop%2Fdirect%2F%3E%0A%0ASELECT%20DISTINCT%20%3Fitem%0AWHERE%20%7B%0A%20%20%20%20%3Fitem%20wdt%3AP279%2a%20wd%3AQ657596%0A%7D%0A
  // Binary functions:
  // https://query.wikidata.org/#PREFIX%20wd%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fentity%2F%3E%0APREFIX%20wdt%3A%20%3Chttp%3A%2F%2Fwww.wikidata.org%2Fprop%2Fdirect%2F%3E%0A%0ASELECT%20DISTINCT%20%3Fitem%0AWHERE%20%7B%0A%20%20%20%20%3Fitem%20wdt%3AP31%2a%20wd%3AQ164307%0A%7D%0A
  // Bindings to:
  // - stdlib: https://github.com/stdlib-js/stdlib
  // - mathjs
  // - others...?
  const DICTIONARY = {
      'arithmetic': ARITHMETIC_DICTIONARY,
      'algebra': {
      // polynomial([0, 2, 0, 4]:list, x:symbol) -> 2x + 4x^3
      // polynomial(2x + 4x^3, x) -> {0, 2, 0, 4}
      // rational(2x + 4x^3, {3, 1}, x) -> (2x + 4x^3)/(3+x)
      // https://reference.wolfram.com/language/tutorial/AlgebraicCalculations.html
      // simplify-trig (macsyma)
      //  - trigReduce, trigExpand, trigFactor, trigToExp (mathematica)
      // Mathematica:
      // - distribute -> (a+b)(c+d) -> ac+ ad+ bc+ bd (doesn't have to be multiply,
      // f(a+b, c+d) -> f(a, c) + f(a, d) + f(b, c) + f(b, d)
      // -- distribute(expr, over=add, with=multiply)
      // https://reference.wolfram.com/language/ref/Distribute.html
      // - expand, expand-all
      // - factor
      // - simplify
      },
      'calculus': {
      // D
      // Derivative (mathematica)
      // diff (macsyma)
      // nth-diff
      // int
      // - integrate(expression, symbol)  -- indefinite integral
      // - integrate(expression, range) <range> = {symbol, min, max} -- definite integral
      // - integrate(expression, range1, range2) -- multiple integral
      // def-int
      },
      'combinatorics': {},
      'complex': {
      // real
      // imaginary
      // complex-cartesian (constructor)
      // complex-polar
      // argument
      // conjugate
      },
      'core': CORE_DICTIONARY,
      'collections': { ...SETS_DICTIONARY, ...COLLECTIONS_DICTIONARY },
      'domains': getDomainsDictionary(),
      'dimensions': {
      // volume, speed, area
      },
      'logic': LOGIC_DICTIONARY,
      'inequalities': {},
      'intervals': {
      // interval of integers vs interval of other sets (integer interval don't need to be open/closed)
      // interval vs. ranges
      // interval, open-interval, etc..
      // upper     or min?
      // lower    or max?
      },
      'linear-algebra': {
      // matrix
      // transpose
      // cross-product
      // outer-product
      // determinant
      // vector
      // matrix
      // rank
      // scalar-matrix
      // constant-matrix
      // identitity-matrix
      },
      'numeric': {
      // Gamma function
      // Zeta function
      // erf function
      // numerator(fraction)
      // denominator(fraction)
      // exactFloatToRational
      // N -> eval as a number
      // random
      // hash
      },
      'other': {},
      'polynomials': {
      // degree
      // expand
      // factors
      // roots
      },
      'physics': {
          'Mu-0': {
              constant: true,
              wikidata: 'Q1515261',
              domain: 'RealNumber',
              value: 1.25663706212e-6,
              unit: [MULTIPLY, 'H', [POWER, 'm', -1]],
          },
      },
      'relations': {
      // eq, lt, leq, gt, geq, neq, approx
      //     shortLogicalImplies: 52, // âž”
      // shortImplies => 51
      // implies ==> 49
      //    impliedBy: 45, // <==
      // := assign 80
      // less-than-or-equal-to: Q55935272 241
      // greater-than-or-equal: Q55935291 242
      // greater-than: Q47035128  243
      // less-than: Q52834024 245
      },
      'rounding': {
      // ceiling, floor, trunc, round,
      },
      'statistics': {
      // average
      // mean
      // variance = size(l) * stddev(l)^2 / (size(l) - 1)
      // stddev
      // median
      // quantile
      },
      'transcendentals': {
      // log, ln, exp,
      },
      'trigonometry': TRIGONOMETRY_DICTIONARY,
      'units': {},
  };
  /**
   * Return a compiled and validated version of the dictionary.
   *
   * Specifically:
   * - Expressions (for values, evaluate, domain, isElementOf, etc..) are compiled
   * when possible, put in canonical form otherwise
   * - The domain of entries is inferred and validated:
   *  - check that domains are in canonical form
   *  - check that domains are consistent with declarations (for example that
   * the signature of predicate have a "MaybeBoolean" codomain)
   *
   */
  function compileDictionary(dict, engine) {
      const result = new Map();
      for (const entryName of Object.keys(dict)) {
          const [def, error] = normalizeDefinition(dict[entryName], engine);
          if (error) {
              engine.signal({
                  severity: def ? 'warning' : 'error',
                  message: ['invalid-dictionary-entry', error],
                  head: entryName,
              });
          }
          if (def)
              result.set(entryName, def);
      }
      // Temporarily put this dictionary in scope
      // (this is required so that compilation and validation can succeed
      // when symbols in this dictionary refer to *other* symbols from this dictionary)
      engine.context = {
          parentScope: engine.context,
          dictionary: result,
          assumptions: new ExpressionMap(),
      };
      // @todo: compile
      validateDictionary(engine, result);
      // Restore the original scope
      engine.context = engine.context.parentScope;
      return result;
  }
  function normalizeDefinition(def, engine) {
      if (typeof def === 'number') {
          //  If the dictionary entry is provided as a number, assume it's a
          // variable, and infer its domain based on its value.
          return [
              {
                  domain: inferNumericDomain(def),
                  constant: false,
                  value: def,
              },
          ];
      }
      let domain = def.domain;
      if (isSymbolDefinition(def)) {
          let warning;
          if (!domain) {
              warning = 'no domain provided.';
              domain = 'Anything';
          }
          def = {
              domain,
              constant: false,
              ...def,
          };
          if (def.hold === false && !def.value) {
              def.hold = true;
          }
          return [def, warning];
      }
      if (isCollectionDefinition(def) ||
          (typeof domain !== 'function' && engine.isSubsetOf(domain, 'Collection'))) {
          return [
              {
                  domain: 'Collection',
                  iterable: def.iterator !== undefined,
                  indexable: def.at !== undefined,
                  countable: def.size !== undefined,
                  ...def,
              },
              undefined,
          ];
      }
      if (isFunctionDefinition(def) ||
          (typeof domain !== 'function' && engine.isSubsetOf(domain, 'Function'))) {
          let functionDef = { ...def };
          functionDef = {
              wikidata: '',
              scope: null,
              threadable: false,
              associative: false,
              commutative: false,
              additive: false,
              multiplicative: false,
              outtative: false,
              idempotent: false,
              involution: false,
              numeric: false,
              pure: true,
              hold: 'none',
              sequenceHold: false,
              signatures: [],
              ...def,
          };
          let warning;
          if (!functionDef.range) {
              warning = `no function range provided.`;
          }
          else if (domain === 'LogicalFunction' || domain === 'Predicate') {
              if (functionDef.range !== 'Boolean' &&
                  functionDef.range !== 'MaybeBoolean') {
                  warning = `A "LogicalFunction" or a "Predicate" should have a range of "Boolean" or "MaybeBoolean"`;
              }
          }
          else {
              if (functionDef.range === 'Boolean' ||
                  functionDef.range === 'MaybeBoolean') {
                  warning = `looks like a "LogicalFunction" or a "Predicate"?`;
              }
          }
          return [functionDef, warning];
      }
      if (isSetDefinition(def) ||
          (typeof domain !== 'function' && engine.isSubsetOf(domain, 'Function'))) {
          // @todo
          return [def];
      }
      if (def) {
          const symDef = def;
          // This might be a partial definition (missing `constant` for a symbol)
          if (domain &&
              typeof domain !== 'function' &&
              engine.isSubsetOf(domain, 'Number')) {
              if (typeof symDef.value === 'undefined') {
                  return [null, 'expected "value" property in definition'];
              }
              // That's a numeric variable definition
              const inferredDomain = inferNumericDomain(typeof symDef.value === 'function' ? symDef.value(engine) : symDef.value);
              return [
                  {
                      domain: inferredDomain,
                      constant: false,
                      ...def,
                  },
                  inferredDomain !== domain ? 'inferred domain "${inferredDomain}"' : '',
              ];
          }
          // This might be a partial definition (missing `signatures` for a Function)
          if (domain &&
              typeof domain !== 'function' &&
              engine.isSubsetOf(domain, 'Function')) {
              return [
                  {
                      range: 'Anything',
                      ...def,
                  },
                  'a "Function" should have a "range" property in its definition',
              ];
          }
          // This might be a partial definition (missing `supersets` for a Set)
          if (domain &&
              typeof domain !== 'function' &&
              engine.isSubsetOf(domain, 'Set')) {
              return [
                  def,
                  'a "Set" should have a "supersets" property in its definition',
              ];
          }
      }
      return [def, 'could not be validate'];
  }
  /**
   * Validate the contents of the dictionary.
   *
   * Unlike `normalizeDefinition` which only considers the properties of the
   * definition entry, `validateDictionary` will consider the entries
   * in relation to each other, for example validating that the referenced
   * domains are valid.
   */
  function validateDictionary(engine, dictionary) {
      const wikidata = new Set();
      for (const [name, def] of dictionary) {
          if (!/[A-Za-z][A-Za-z0-9-]*/.test(name) && name.length !== 1) {
              engine.signal({ severity: 'error', message: 'invalid-name', head: name });
          }
          if (def.wikidata) {
              if (wikidata.has(def.wikidata)) {
                  engine.signal({
                      severity: 'warning',
                      message: ['duplicate-wikidata', def.wikidata],
                      head: name,
                  });
              }
              wikidata.add(def.wikidata);
          }
          if (isSymbolDefinition(def)) {
              // Validate domain (make sure domain exists)
              if (typeof def.domain !== 'function' &&
                  !engine.isSubsetOf(def.domain, 'Anything')) {
                  engine.signal({
                      severity: 'warning',
                      message: ['unknown-domain', def.domain],
                      head: name,
                  });
              }
              if (def.hold === false && !def.value) {
                  engine.signal({
                      severity: 'warning',
                      message: [
                          'invalid-dictionary-entry',
                          'symbol has hold = false, but no value',
                      ],
                      head: name,
                  });
              }
              // @todo: for numeric domain, validate them: i.e. real are at least RealNumber, etc...
              // using inferDomain
          }
          if (isFunctionDefinition(def)) {
              // Validate range
              const sig = def.range;
              if (typeof sig !== 'function' && !engine.isSubsetOf(sig, 'Anything')) {
                  engine.signal({
                      severity: 'warning',
                      message: ['unknown-domain', sig],
                      head: name,
                  });
              }
              // @todo could do some additional checks
              // - if it's numeric, it can't have a 'hold' argument
              // - if it's commutative it must have at least one signature with multiple arguments
              // - if an involution, it's *not* idempotent
              // - if it's threadable it must have at least one signature with a rest argument
          }
          if (isSetDefinition(def)) {
              // Check there is at least one superset defined
              if (def.supersets.length === 0 && name !== 'Anything') {
                  engine.signal({
                      severity: 'warning',
                      message: 'expected-supersets',
                      head: name,
                  });
              }
              // Check that all the parents are valid
              for (const parent of def.supersets) {
                  if (!engine.isSubsetOf(parent, 'Anything')) {
                      engine.signal({
                          severity: 'warning',
                          message: ['expected-supersets', parent],
                          head: name,
                      });
                  }
                  // Check for loops in set definition
                  if (engine.isSubsetOf(parent, name)) {
                      engine.signal({
                          severity: 'warning',
                          message: ['cyclic-definition', setParentsToString(engine, name)],
                          head: name,
                      });
                      // Remove entry from dictionary
                      dictionary.delete(name);
                  }
              }
              // @todo: could check that the domain of `isElementOf` and `isSubsetOf` is
              // MaybeBoolean
          }
      }
  }
  /**
   * For debugging purposes,  a textual representation of the inheritance
   * chain of sets.
   */
  function setParentsToString(engine, expr, cycle) {
      var _a;
      const result = [`${expr}`];
      const name = typeof expr === 'string' ? expr : getFunctionName(expr);
      if (cycle) {
          if (cycle.includes(name))
              return `${name} â†©ï¸Ž `;
          cycle.push(name);
      }
      else {
          cycle = [name];
      }
      const def = engine.getSetDefinition(name);
      if (!def)
          return `${name}?!`;
      if (!def.supersets.length || def.supersets.length === 0)
          return '';
      for (const parent of def === null || def === void 0 ? void 0 : def.supersets) {
          if (typeof parent === 'string') {
              result.push(setParentsToString(engine, parent, [...cycle]));
          }
      }
      if (result.length <= 1) {
          return (_a = result[0]) !== null && _a !== void 0 ? _a : '';
      }
      return '[' + result.join(' âž” ') + ']';
  }

  // A list of simplification rules.
  // The rules are expressed as
  //    [lhs, rhs, condition]
  // where `lhs` is rewritten as `rhs` if `condition` is true
  // `lhs` and `rhs` can be either an Expression or a Latex string.
  // If using an Expression, the expression is *not* canonicalized before being
  // used. Therefore in some cases using Expression, while more verbose,
  // may be necessary as the expression could be simplified by the canonicalization.
  const SIMPLIFY_RULES = {
      'simplify-arithmetic': [
          // `Subtract`
          ['x - x', 0],
          [['Subtract', '_x', 0], 'x'],
          [['Subtract', 0, '_x'], '-x'],
          // `Add`
          [['Add', '_x', ['Negate', '_x']], 0],
          // `Multiply`
          [
              'x \\times x ',
              'x^2',
              // ['Multiply', '_x', '_x'],
              // ['Square', '_x'],
          ],
          // `Divide`
          [['Divide', '_x', 1], { sym: '_x' }],
          [
              ['Divide', '_x', '_x'],
              1,
              (ce, sub) => { var _a; return (_a = isNotZero(ce, sub.x)) !== null && _a !== void 0 ? _a : false; },
          ],
          [
              ['Divide', '_x', 0],
              +Infinity,
              (ce, sub) => { var _a; return (_a = isPositive(ce, sub.x)) !== null && _a !== void 0 ? _a : false; },
          ],
          [
              ['Divide', '_x', 0],
              -Infinity,
              (ce, sub) => { var _a; return (_a = isNegative(ce, sub.x)) !== null && _a !== void 0 ? _a : false; },
          ],
          [['Divide', 0, 0], NaN],
          // `Power`
          [['Power', '_x', 'Half'], ['\\sqrt{x}']],
          [['Power', '_x', ['Divide', 1, 2]], ['\\sqrt{x}']],
          [
              ['Power', '_x', 2],
              ['Square', '_x'],
          ],
          // Complex
          [
              ['Divide', ['Complex', '_re', '_im'], '_x'],
              ['Add', ['Divide', ['Complex', 0, '_im'], '_x'], ['Divide', '_re', '_x']],
              (ce, sub) => {
                  var _a, _b, _c;
                  return ((_a = ce.isNotZero(sub.re)) !== null && _a !== void 0 ? _a : false) &&
                      ((_b = ce.isInteger(sub.re)) !== null && _b !== void 0 ? _b : false) &&
                      ((_c = ce.isInteger(sub.im)) !== null && _c !== void 0 ? _c : false);
              },
          ],
          // `Abs`
          [
              ['Abs', '_x'],
              { sym: '_x' },
              (ce, sub) => { var _a, _b; return ((_a = isZero(ce, sub.x)) !== null && _a !== void 0 ? _a : false) || ((_b = isPositive(ce, sub.x)) !== null && _b !== void 0 ? _b : false); },
          ],
          [
              ['Abs', '_x'],
              ['Negate', '_x'],
              (ce, sub) => { var _a; return (_a = isNegative(ce, sub.x)) !== null && _a !== void 0 ? _a : false; },
          ],
      ],
  };
  function internalSimplify(engine, expr, simplifications) {
      var _a, _b, _c, _d, _e;
      if (expr === null)
          return null;
      //
      // 1/ Apply simplification rules
      //
      simplifications = simplifications !== null && simplifications !== void 0 ? simplifications : ['simplify-all'];
      if (simplifications.length === 1 && simplifications[0] === 'simplify-all') {
          simplifications = [
              'simplify-arithmetic',
              // 'simplify-logarithmic',
              // 'simplify-trigonometric',
          ];
      }
      expr = engine.replace(engine.getRules(simplifications), expr);
      //
      // 2/ Numeric simplifications
      //
      expr = (_a = simplifyNumber(engine, expr)) !== null && _a !== void 0 ? _a : expr;
      //
      // 3/ Simplify assumptions
      //
      // If the expression is a predicate which is an assumption, return `True`
      //
      if (engine.is(expr) === true)
          return 'True';
      if (isAtomic(expr))
          return expr;
      //
      // 4/ Simplify Dictionary
      //
      if (getDictionary(expr) !== null) {
          return applyRecursively(expr, (x) => { var _a; return (_a = engine.simplify(x, { simplifications })) !== null && _a !== void 0 ? _a : x; });
      }
      //
      // 5/ It's a function (not a dictionary and not atomic)
      //
      const head = internalSimplify(engine, (_b = getFunctionHead(expr)) !== null && _b !== void 0 ? _b : MISSING, simplifications);
      if (typeof head === 'string') {
          const def = engine.getFunctionDefinition(head);
          if (def) {
              // Simplify the arguments, except those affected by `hold`
              const args = [];
              const tail = getTail(expr);
              for (let i = 0; i < tail.length; i++) {
                  const name = getFunctionName(tail[i]);
                  if (name === 'Evaluate') {
                      args.push((_c = engine.simplify(tail[i], { simplifications })) !== null && _c !== void 0 ? _c : tail[i]);
                  }
                  else if (name === 'Hold') {
                      args.push((_d = getArg(tail[i], 1)) !== null && _d !== void 0 ? _d : MISSING);
                  }
                  else if ((i === 0 && def.hold === 'first') ||
                      (i > 0 && def.hold === 'rest') ||
                      def.hold === 'all') {
                      args.push(tail[i]);
                  }
                  else {
                      args.push((_e = engine.simplify(tail[i], { simplifications })) !== null && _e !== void 0 ? _e : tail[i]);
                  }
              }
              if (typeof def.simplify === 'function') {
                  return def.simplify(engine, ...args);
              }
              return [head, ...args];
          }
      }
      if (head !== null) {
          // If we can't identify the function, we don't know how to process
          // the arguments (they may be Hold...), so don't attempt to process them.
          return [head, ...getTail(expr)];
      }
      return expr;
  }
  function simplifyNumber(engine, expr) {
      var _a;
      //
      // Replace constants by their value
      //
      const symDef = engine.getSymbolDefinition((_a = getSymbolName(expr)) !== null && _a !== void 0 ? _a : '');
      if (symDef && symDef.hold === false && symDef.value) {
          // If hold is false, we can substitute the symbol for its value
          if (typeof symDef.value === 'function') {
              return internalSimplify(engine, symDef.value(engine));
          }
          return internalSimplify(engine, symDef.value);
      }
      //
      // Simplify rationals
      //
      const [numer, denom] = simplifyRational(getRationalValue(expr));
      if (numer !== null && denom !== null) {
          console.assert(denom >= 0);
          if (denom === 1)
              return numer;
          if (numer === 0 && isFinite(denom))
              return 0;
          if (Object.is(denom, -0) && isFinite(numer))
              return -Infinity;
          if (denom === 0 && isFinite(numer))
              return +Infinity;
          return ['Divide', numer, denom];
      }
      // @todo could simplify Decimal rationals as well
      //
      // Simplify complex numbers
      //
      const c = getComplexValue(expr);
      if (c !== null) {
          if (c.im === 0)
              return c.re;
          return ['Complex', c.re, c.im];
      }
      if (getFunctionName(expr) === 'Complex') {
          const arg1 = getArg(expr, 1);
          const arg2 = getArg(expr, 2);
          const im = getNumberValue(arg2);
          if (im === 0)
              return arg1;
          const re = getNumberValue(arg1);
          if (re === 0)
              return ['Multiply', arg2, 'ImaginaryUnit'];
          // This may be a non-numerical Complex,
          // i.e. ['Complex', ['Divide', 2, 3], 2]
          return ['Add', re !== null && re !== void 0 ? re : arg1, ['Multiply', im !== null && im !== void 0 ? im : arg2, 'ImaginaryUnit']];
      }
      return expr;
  }

  function order(a, b) {
      var _a, _b;
      const lexA = getLex(a);
      const lexB = getLex(b);
      if (lexA < lexB)
          return -1;
      if (lexA > lexB)
          return 1;
      let valA = getExprValue(a);
      if (isNaN(valA))
          valA = Number(Infinity);
      let valB = getExprValue(b);
      if (isNaN(valB))
          valB = Number(Infinity);
      if (valA < valB)
          return -1;
      if (valA > valB)
          return 1;
      const lenA = getExprLength(a);
      const lenB = getExprLength(b);
      if (lenA === lenB && lenA > 0) {
          // Order arg by arg
          for (let i = 1; i <= lenA; i++) {
              const comp = order((_a = getArg(a, i)) !== null && _a !== void 0 ? _a : MISSING, (_b = getArg(b, i)) !== null && _b !== void 0 ? _b : MISSING);
              if (comp !== 0)
                  return comp;
          }
      }
      return lenB - lenA;
  }
  /**
   * Return the (total) degree of the term
   */
  function degree(expr, sortedVars) {
      var _a, _b;
      if (expr === 0)
          return -Infinity;
      const name = getFunctionName(expr);
      if (name === POWER) {
          const exponent = (_a = getNumberValue(getArg(expr, 2))) !== null && _a !== void 0 ? _a : NaN;
          return isFinite(exponent) ? exponent : 0;
      }
      if (name === MULTIPLY) {
          let result = 0;
          getTail(expr).forEach((x) => {
              result += degree(x, sortedVars);
          });
          return result;
      }
      if (sortedVars.includes((_b = getSymbolName(expr)) !== null && _b !== void 0 ? _b : MISSING))
          return 1;
      return 0;
  }
  /**
   *  Return the degree of variable v
   *  i.e. if "v" -> degree 1
   *  if "v^2" -> degree 2
   *  if "v^2v^3" -> degree 5
   *  if "v^n" -> degree 0
   */
  function getDegree(expr, v) {
      var _a, _b;
      const name = getFunctionName(expr);
      if (name === POWER) {
          if (getSymbolName((_a = getArg(expr, 1)) !== null && _a !== void 0 ? _a : MISSING) === v) {
              const exponent = (_b = getNumberValue(getArg(expr, 2))) !== null && _b !== void 0 ? _b : NaN;
              if (isFinite(exponent))
                  return exponent;
          }
          return 0;
      }
      if (name === MULTIPLY) {
          let result = 0;
          for (const arg of getTail(expr)) {
              result += getDegree(arg, v);
          }
          return result;
      }
      if (getSymbolName(expr) === v)
          return 1;
      return 0;
  }
  /**
   * Get a string representing, in order, all the symbols of the expression.
   * This assumes that each of the argument of the expression, if any,
   * have already been sorted.
   */
  function getLex(expr) {
      if (typeof expr === 'string')
          return expr;
      if (isSymbolObject(expr))
          return expr.sym;
      if (getFunctionHead(expr))
          return getTail(expr).map(getLex).join(' ');
      return '';
  }
  /**
   * Get  the "length" of the expression, i.e. the number of arguments, recursively
   *
   */
  function getExprLength(expr) {
      if (getFunctionHead(expr)) {
          const tail = getTail(expr);
          return tail
              .map(getExprLength)
              .reduce((acc, x) => acc + x, tail.length);
      }
      return 0;
  }
  function getExprValue(expr) {
      var _a;
      if (getFunctionHead(expr))
          return NaN;
      if (typeof expr === 'number')
          return expr;
      if (isNumberObject(expr))
          return (_a = getNumberValue(expr)) !== null && _a !== void 0 ? _a : NaN;
      return 0;
  }
  /**
   * The deglex order is used for sum of factors:
   * - first by total degree of each factor
   * - then lexicographically for each variable
   * - then lexicographically for other symbols
   * - then by length
   * - then by value
   *
   */
  function deglex(a, b, sortedVars) {
      const aDeg = degree(a, sortedVars);
      const bDeg = degree(b, sortedVars);
      if (aDeg < bDeg)
          return 1;
      if (aDeg > bDeg)
          return -1;
      // Lexicographic order:
      // Compare order of lexicographically sorted vars
      // i.e. "x" first, then "y", then "z", etc...
      // - a = 5 x^5 y^7
      // - b =   x^2 y^3
      for (const x of sortedVars) {
          const aDegX = getDegree(a, x);
          const bDegX = getDegree(b, x);
          if (aDegX !== bDegX)
              return bDegX - aDegX;
      }
      const aLex = getLex(a);
      const bLex = getLex(b);
      if (aLex > bLex)
          return -1;
      if (aLex < bLex)
          return 1;
      // Inverse than the regular order: smaller first
      // let valA = getExprValue(a);
      // if (isNaN(valA)) valA = +Infinity;
      // let valB = getExprValue(b);
      // if (isNaN(valB)) valB = +Infinity;
      // if (valA < valB) return -1;
      // if (valA > valB) return 1;
      return order(a, b);
  }
  function canonicalOrder(engine, sortedVars, expr) {
      var _a, _b;
      let args = getTail(expr);
      if (args.length === 0)
          return expr;
      // Sort each of the arguments
      args = args.map((x) => canonicalOrder(engine, sortedVars, x));
      const name = getFunctionName(expr);
      if (name === ADD) {
          // Use the deglex sort order for sums
          args.sort((a, b) => deglex(a, b, sortedVars));
      }
      else {
          // Is the function commutative?
          const def = engine.getFunctionDefinition(name);
          if ((_a = def === null || def === void 0 ? void 0 : def.commutative) !== null && _a !== void 0 ? _a : false) {
              // Sort the argument list
              args.sort(order);
          }
      }
      return [(_b = getFunctionHead(expr)) !== null && _b !== void 0 ? _b : MISSING, ...args];
  }

  /**
   * Return an expression that's the inverse (1/x) of the input
   *
   */
  function applyInvert(expr) {
      expr = ungroup(expr);
      if (isAtomic(expr))
          return [DIVIDE, 1, expr];
      const head = getFunctionHead(expr);
      if (head === POWER && getArgCount(expr) === 2) {
          return [POWER, getArg(expr, 1), applyNegate(getArg(expr, 2))];
      }
      if (head === DIVIDE && getArgCount(expr) === 2) {
          return [DIVIDE, getArg(expr, 2), getArg(expr, 1)];
      }
      return [DIVIDE, 1, expr];
  }
  /** Recursively flatten an expression with the head `head`, i.e.
   * `f(x, f(y)) -> f(x, y)`
   */
  function flatten(expr, head) {
      if (isAtomic(expr))
          return expr;
      if (getFunctionName(expr) !== head) {
          return applyRecursively(expr, (x) => flatten(x, head));
      }
      const args = getTail(expr);
      let result = [head];
      for (let i = 0; i < args.length; i++) {
          if (getFunctionName(args[i]) === head) {
              // [f, a, [f, b, c]] -> [f, a, b, c]
              // or [f, f[a]] -> f[a]
              result = result.concat(getTail(flatten(args[i], head)));
          }
          else {
              result.push(flatten(args[i], head));
          }
      }
      return result;
  }
  function flattenInvolution(expr, engine) {
      if (isAtomic(expr))
          return expr;
      const name = getFunctionName(expr);
      const def = engine.getFunctionDefinition(name);
      if (def === null || def === void 0 ? void 0 : def.involution) {
          const args = getTail(expr);
          if (args.length === 1 && getFunctionName(args[0]) === name) {
              return flatten(args[0], name);
          }
      }
      return applyRecursively(expr, (x) => flattenInvolution(x, engine));
  }
  function flattenIdempotent(expr, engine) {
      if (isAtomic(expr))
          return expr;
      const name = getFunctionName(expr);
      const def = engine.getFunctionDefinition(name);
      if (def === null || def === void 0 ? void 0 : def.idempotent)
          return flatten(expr, name);
      return applyRecursively(expr, (x) => flattenIdempotent(x, engine));
  }
  function flattenAssociative(expr, engine) {
      if (isAtomic(expr))
          return expr;
      const name = getFunctionName(expr);
      const def = engine.getFunctionDefinition(name);
      if (def === null || def === void 0 ? void 0 : def.associative)
          return flatten(expr, name);
      return applyRecursively(expr, (x) => flattenAssociative(x, engine));
  }
  function canonicalAddForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) !== ADD) {
          return applyRecursively(expr, (x) => canonicalAddForm(x));
      }
      expr = flatten(ungroup(expr), ADD);
      let args = getTail(expr);
      args = args
          .map((x) => canonicalAddForm(x))
          .filter((x) => getNumberValue(x) !== 0);
      const argCount = args.length;
      if (argCount === 0)
          return 0;
      if (argCount === 1)
          return args[0];
      return [ADD, ...args];
  }
  function canonicalDivideForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) !== DIVIDE) {
          return applyRecursively(expr, (x) => canonicalDivideForm(x));
      }
      if (getArgCount(expr) !== 2)
          return expr;
      const arg1 = canonicalDivideForm(getArg(expr, 1));
      const arg2 = canonicalDivideForm(getArg(expr, 2));
      if (getNumberValue(arg2) === 1)
          return arg1;
      if (getNumberValue(arg1) === 1)
          return applyInvert(arg2);
      if (getNumberValue(arg1) === -1)
          return [NEGATE, applyInvert(arg2)];
      return [DIVIDE, arg1, arg2];
  }
  function canonicalExpForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      if (getFunctionName(expr) === POWER) {
          if (getSymbolName(getArg(expr, 1)) === EXPONENTIAL_E) {
              return [EXP, canonicalExpForm(getArg(expr, 2))];
          }
      }
      return applyRecursively(expr, (x) => canonicalExpForm(x));
  }
  function canonicalListForm(expr, engine) {
      var _a;
      if (isAtomic(expr))
          return expr;
      const head = getFunctionName(expr);
      if (head !== LIST && head !== SEQUENCE && head !== SEQUENCE2) {
          return applyRecursively(expr, (x) => canonicalListForm(x, engine));
      }
      const args = getTail(expr);
      let result = [getFunctionHead(expr)];
      if (head === LIST) {
          for (let arg of args) {
              arg = canonicalListForm(arg, engine);
              const name = getFunctionName(arg);
              if (name === IDENTITY) {
                  const arg1 = getArg(arg, 1);
                  if (arg1 !== null)
                      result.push(arg1);
              }
              else {
                  result.push(arg);
              }
          }
          return result;
      }
      const def = engine.getFunctionDefinition(head);
      const sequenceHold = (_a = def === null || def === void 0 ? void 0 : def.sequenceHold) !== null && _a !== void 0 ? _a : false;
      for (let arg of args) {
          arg = canonicalListForm(arg, engine);
          const name = getFunctionName(arg);
          if (name === IDENTITY) {
              const arg1 = getArg(arg, 1);
              if (arg1 !== null)
                  result.push(arg1);
          }
          else if (name === head && !sequenceHold) {
              for (let arg2 of getTail(arg)) {
                  arg2 = canonicalListForm(arg2, engine);
                  if (getFunctionName(arg2) === head) {
                      result = result.concat(getTail(arg2));
                  }
                  else {
                      result.push(arg2);
                  }
              }
          }
          else {
              result.push(arg);
          }
      }
      return result;
  }
  function getRootDegree(expr) {
      var _a, _b;
      const name = getFunctionName(expr);
      if (name === SQRT)
          return 2;
      if (name === ROOT)
          return (_a = getNumberValue(getArg(expr, 2))) !== null && _a !== void 0 ? _a : 2;
      if (name !== POWER)
          return 1;
      const exponent = getArg(expr, 2);
      if (exponent === null)
          return 1;
      if (getFunctionName(exponent) === POWER &&
          getNumberValue(getArg(exponent, 2)) === -1) {
          // x^{n^{-1}}
          const val = (_b = getNumberValue(getArg(exponent, 1))) !== null && _b !== void 0 ? _b : NaN;
          if (isFinite(val))
              return val;
      }
      return 1;
  }
  /**
   * Assuming that `expr` is a `"Multiply"`, return in the first member
   * of the tuples all the arguments that are square roots,
   * and in the second member of the tuples all those that aren't
   */
  function getSquareRoots(expr) {
      var _a;
      console.assert(getFunctionName(expr) === MULTIPLY);
      const args = getTail(expr);
      const roots = [];
      const nonRoots = [];
      for (const arg of args) {
          if (getRootDegree(arg) === 2) {
              roots.push((_a = getArg(arg, 1)) !== null && _a !== void 0 ? _a : MISSING);
          }
          else {
              nonRoots.push(arg);
          }
      }
      return [roots, nonRoots];
  }
  function canonicalMultiplyForm(expr, engine) {
      var _a;
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) !== MULTIPLY) {
          return applyRecursively(expr, (x) => canonicalMultiplyForm(x));
      }
      expr = flatten(ungroup(expr), MULTIPLY);
      // Group all square roots together
      // \sqrt{2}\sqrt{x}y -> \sqrt{2x}y
      const [squareRoots, nonSquareRoots] = getSquareRoots(expr);
      let args;
      if (squareRoots.length === 0) {
          args = nonSquareRoots;
      }
      else if (squareRoots.length === 1) {
          args = [...nonSquareRoots, [SQRT, squareRoots[0]]];
      }
      else {
          args = [...nonSquareRoots, [SQRT, [MULTIPLY, ...squareRoots]]];
      }
      // Hoist any negative (numbers or `"Negate"` function)
      let isNegative = false;
      let hasNegative = false;
      args = args.map((x) => {
          var _a, _b;
          if (getFunctionName(x) === NEGATE) {
              hasNegative = true;
              isNegative = !isNegative;
              return (_a = getArg(x, 1)) !== null && _a !== void 0 ? _a : MISSING;
          }
          const val = (_b = getNumberValue(x)) !== null && _b !== void 0 ? _b : NaN;
          if (val < 0) {
              hasNegative = true;
              isNegative = !isNegative;
              return -val;
          }
          return x;
      });
      if (isNegative) {
          const val = (_a = getNumberValue(args[0])) !== null && _a !== void 0 ? _a : NaN;
          if (isFinite(val)) {
              // If the first argument is a finite number, negate it
              args = getTail(flatten([MULTIPLY, -val, ...args.slice(1)], MULTIPLY));
          }
          else {
              args = getTail(flatten([MULTIPLY, -1, ...args], MULTIPLY));
          }
      }
      else if (hasNegative) {
          // At least one term was hoisted, it could require flatening
          // e.g. `[MULTIPLY, [NEGATE, [MULTIPLY, 2, 3]], 4]`
          args = getTail(flatten([MULTIPLY, ...args], MULTIPLY));
      }
      else {
          args = getTail(flatten([MULTIPLY, ...args], MULTIPLY));
      }
      // Any arg is 0? Return 0.
      // WARNING: we can't do this. If any of the argument, or the result
      // of the evaluation of any of the argument was non-finite, the
      // result is undefined (NaN), not 0.
      // if (args.some((x) => getNumberValue(x) === 0)) return 0;
      // Any 1? Eliminate them.
      args = args.filter((x) => getNumberValue(x) !== 1);
      // If no arguments left, return 1
      if (args.length === 0)
          return 1;
      // Only one argument, return it (`"Multiply"` is idempotent)
      if (args.length === 1)
          return args[0];
      return [MULTIPLY, ...args];
  }
  function canonicalPowerForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      expr = applyRecursively(expr, (x) => canonicalPowerForm(x, engine));
      if (getFunctionName(expr) === POWER)
          return applyPower(engine, expr);
      return expr;
  }
  function canonicalNegateForm(expr, engine) {
      var _a;
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) !== NEGATE) {
          return applyRecursively(expr, (x) => canonicalNegateForm(x));
      }
      return applyNegate((_a = getArg(ungroup(expr), 1)) !== null && _a !== void 0 ? _a : MISSING);
  }
  function canonicalBooleanForm(expr, _engine) {
      // @todo
      return expr;
  }
  function canonicalConstantsForm(expr, _engine) {
      return applyConstants(expr);
  }
  function canonicalRationalForm(expr, engine) {
      if (!isAtomic(expr)) {
          return applyRecursively(expr, (x) => canonicalConstantsForm(x));
      }
      const [numer, denom] = getRationalValue(expr);
      if (numer === null || denom === null)
          return expr;
      if (denom === 1)
          return numer;
      if (denom === -1)
          return -numer;
      // Make the denominator > 0
      if (denom < 0)
          return ['Divide', applyNegate(numer), applyNegate(denom)];
      return ['Divide', numer, denom];
  }
  function canonicalNumberForm(expr, engine) {
      if (typeof expr === 'number') {
          if (isNaN(expr)) {
              return { num: 'NaN' };
          }
          else if (!isFinite(expr) && expr > 0) {
              return { num: '+Infinity' };
          }
          else if (!isFinite(expr) && expr < 0) {
              return { num: '-Infinity' };
          }
      }
      else if (expr instanceof decimal.exports.Decimal) {
          const d = expr;
          return { num: d.toString() + 'd' };
      }
      else if (isNumberObject(expr)) {
          // Validate that the payload is a legit number
          if (/([+-]Infinity|NaN)/.test(expr.num) ||
              /[+-]?\d*\.?\d*([eE][+-]?\d+)?[dn]?/.test(expr.num))
              return expr;
          return { num: 'NaN' };
      }
      // Note: we don't use ['Complex'] in canonical form:
      // its precedence is sometimes the precedence of Add (when re and im != 0)
      // sometimes the precedence of Multiply (when im or re === 0).
      // Using Add/Multiply produces the correct serialization.
      if (expr === 'ImaginaryUnit')
          return expr;
      const c = getComplexValue(expr);
      if (c !== null) {
          if (engine.chop(c.im) === 0 && engine.chop(c.re) === 0)
              return 0;
          if (engine.chop(c.im) === 0)
              return c.re;
          let imaginaryPart = null;
          if (engine.chop(c.im + 1) === 0) {
              imaginaryPart = ['Negate', 'ImaginaryUnit'];
          }
          else if (engine.chop(c.im - 1) === 0) {
              imaginaryPart = 'ImaginaryUnit';
          }
          else {
              imaginaryPart = ['Multiply', c.im, 'ImaginaryUnit'];
          }
          if (engine.chop(c.re) === 0)
              return imaginaryPart;
          return ['Add', c.re, imaginaryPart];
      }
      if (!isAtomic(expr)) {
          return applyRecursively(expr, (x) => canonicalNumberForm(x, engine));
      }
      return expr;
  }
  function canonicalSubtractForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      if (getFunctionHead(expr) !== SUBTRACT) {
          return applyRecursively(expr, (x) => canonicalSubtractForm(x));
      }
      if (getArgCount(expr) !== 2)
          return expr;
      const arg1 = canonicalSubtractForm(getArg(expr, 1));
      const val1 = getNumberValue(arg1);
      const arg2 = canonicalSubtractForm(getArg(expr, 2));
      const val2 = getNumberValue(arg2);
      if (val1 === 0) {
          if (val2 === 0)
              return 0;
          return applyNegate(arg2);
      }
      return [ADD, arg1, applyNegate(arg2)];
  }
  function canonicalRootForm(expr, engine) {
      if (isAtomic(expr))
          return expr;
      const head = getFunctionHead(expr);
      if (getArgCount(expr) < 2 && head !== ROOT && head !== POWER) {
          return applyRecursively(expr, (x) => canonicalRootForm(x));
      }
      const arg2 = canonicalRootForm(getArg(expr, 2));
      const arg1 = canonicalRootForm(getArg(expr, 1));
      if (head === ROOT) {
          if (getNumberValue(arg2) === 2)
              return [SQRT, arg1];
          return [ROOT, arg1, arg2];
      }
      if (head === POWER) {
          const [numer, denom] = getRationalValue(arg2);
          if (numer === -1) {
              if (denom === 2)
                  return [SQRT, arg1];
              return [ROOT, arg1, denom];
          }
          if (denom === 1)
              return [POWER, arg1, numer];
          if (numer !== null && denom !== null) {
              return [POWER, arg1, [DIVIDE, numer, denom]];
          }
      }
      return expr;
  }
  /**
   * Return num as a number if it's a valid JSON number (that is
   * a valid JavaScript number but not NaN or +/-Infinity) or
   * as a string otherwise
   */
  function asValidJSONNumber(num) {
      if (typeof num === 'string') {
          const val = Number(num);
          if (num[0] === '+')
              num = num.slice(1);
          if (val.toString() === num) {
              // If the number roundtrips, it can be represented by a
              // JavaScript number
              // However, NaN and Infinity cannot be represented by JSON
              if (isNaN(val) || !isFinite(val)) {
                  return val.toString();
              }
              return val;
          }
      }
      return num;
  }
  /**
   * Transform the expression so that object literals for numbers, symbols and
   * functions are used only when necessary, i.e. when they have associated
   * metadata attributes. Otherwise, use a plain number, string or array
   *
   * For example:
   *
   * ```
   * {num: 2} -> 2
   * {sym: "x"} -> "x"
   * {fn:['add', {num: 1}, {sym: "x"}]} -> ['add', 1, "x"]
   * ```
   *
   */
  function jsonForm(expr, engine) {
      if (expr === null)
          return null;
      if (Array.isArray(expr)) {
          return expr.map((x, i) => {
              var _a;
              if (i === 0) {
                  return x;
              }
              return (_a = jsonForm(x)) !== null && _a !== void 0 ? _a : NOTHING;
          });
      }
      if (typeof expr === 'object') {
          const keys = Object.keys(expr);
          if (keys.length === 1) {
              if (isNumberObject(expr)) {
                  // Exclude NaN and Infinity, which are not valid numbers in JSON
                  const val = asValidJSONNumber(expr.num);
                  if (typeof val === 'number')
                      return val;
                  return { num: val };
              }
              if (isFunctionObject(expr)) {
                  return expr.fn.map((x) => { var _a; return (_a = jsonForm(x)) !== null && _a !== void 0 ? _a : NOTHING; });
              }
              if (isSymbolObject(expr)) {
                  return expr.sym;
              }
          }
          else {
              if (isFunctionObject(expr)) {
                  expr.fn = expr.fn.map((x) => { var _a; return (_a = jsonForm(x)) !== null && _a !== void 0 ? _a : NOTHING; });
              }
          }
      }
      return expr;
  }
  function strippedMetadataForm(expr, engine) {
      if (expr === null)
          return null;
      if (typeof expr === 'number' || typeof expr === 'string') {
          return expr;
      }
      if (Array.isArray(expr)) {
          return expr.map((x) => { var _a; return (_a = strippedMetadataForm(x)) !== null && _a !== void 0 ? _a : NOTHING; });
      }
      if (typeof expr === 'object') {
          if ('num' in expr) {
              const val = asValidJSONNumber(expr.num);
              if (typeof val === 'number')
                  return val;
              return { num: val };
          }
          else if ('fn' in expr) {
              return expr.fn.map((x) => { var _a; return (_a = strippedMetadataForm(x)) !== null && _a !== void 0 ? _a : NOTHING; });
          }
          else if ('dict' in expr) {
              return {
                  dict: Object.fromEntries(Object.entries(expr.dict).map((keyValue) => {
                      var _a;
                      return [
                          keyValue[0],
                          (_a = strippedMetadataForm(keyValue[1])) !== null && _a !== void 0 ? _a : NOTHING,
                      ];
                  })),
              };
          }
      }
      return null;
  }
  function objectLiteralForm(expr, engine) {
      if (typeof expr === 'number') {
          return { num: expr.toString() };
      }
      if (typeof expr === 'string') {
          return { sym: expr };
      }
      if (Array.isArray(expr) && expr.length > 0) {
          return { fn: expr.map((x) => objectLiteralForm(x)) };
      }
      if (typeof expr === 'object' && 'fn' in expr) {
          return { ...expr, fn: expr.fn.map((x) => objectLiteralForm(x)) };
      }
      return expr;
  }
  /**
   * Transform the expression so that the arguments of functions that have the
   * `isCommutative` attributes are ordered as follow:
   *
   * - Real numbers
   * - Complex numbers
   * - Symbols
   * - Functions
   *
   * Within Real Numbers:
   * - by their value
   *
   * Within Complex numbers:
   * - by the value of their imaginary component,
   * - then by the value of their real component
   *
   * Within Symbols:
   * - constants (`isConstant === true`) before non-constants
   * - then alphabetically
   *
   * Within Functions:
   * - if a `[MULTIPLY]` or a `[POWER]`... @todo
   *
   */
  function sortedForm(expr, engine) {
      // Get the unique variables (not constants) in the expression
      const v = engine.getVars(expr);
      return canonicalOrder(engine, Array.from(v).sort(), expr);
  }
  /**
   *  Return the expression in canonical form:
   *
   * - `"divide"`, `"exp"`,` `"subtract"`, `"root"`, `"exp"` replaced with
   *      `"add"`, `"multiply"`, "`power"`
   * - some trivial simplifications (multiply by 1, addition of 0, division by 1)
   * - terms sorted
   *
   */
  function canonicalForm(expr, engine) {
      return engine.format(expr, [
          // @todo: canonical-boolean: transforms, Equivalent, Implies, Xor...
          'canonical-boolean',
          // in CNF (Conjunctive Normal Form: https://en.wikipedia.org/wiki/Conjunctive_normal_form)
          'canonical-number',
          'canonical-exp',
          'canonical-root',
          'canonical-subtract',
          'canonical-divide',
          'canonical-power',
          'canonical-multiply',
          // some POWER functions, but they are 'safe' (don't need simplification)
          'canonical-negate',
          'canonical-add',
          'flatten',
          'canonical-list',
          'canonical-domain',
          'canonical-rational',
          'canonical-constants',
          'sorted',
          'json',
      ]);
  }
  function flattenForm(expr, engine) {
      return flattenAssociative(flattenIdempotent(flattenInvolution(expr, engine), engine), engine);
  }
  /**
   * Transform an expression by applying one or more rewriting rules to it,
   * recursively.
   *
   * There are many ways to symbolically manipulate an expression, but
   * transformations with `form` have the following characteristics:
   *
   * - they don't require calculations or assumptions about the domain of free
   * variables or the value of constants
   * - the output expression is expressed with more primitive functions,
   * for example subtraction is replaced with addition
   *
   */
  function format$1(engine, expr, forms) {
      let result = expr;
      for (const form of forms) {
          const fn = {
              'canonical': canonicalForm,
              'canonical-add': canonicalAddForm,
              'canonical-boolean': canonicalBooleanForm,
              'canonical-constants': canonicalConstantsForm,
              'canonical-divide': canonicalDivideForm,
              'canonical-domain': canonicalDomainForm,
              'canonical-exp': canonicalExpForm,
              'canonical-list': canonicalListForm,
              'canonical-multiply': canonicalMultiplyForm,
              'canonical-power': canonicalPowerForm,
              'canonical-negate': canonicalNegateForm,
              'canonical-number': canonicalNumberForm,
              'canonical-rational': canonicalRationalForm,
              'canonical-root': canonicalRootForm,
              'canonical-subtract': canonicalSubtractForm,
              'json': jsonForm,
              'flatten': flattenForm,
              'sorted': sortedForm,
              'stripped-metadata': strippedMetadataForm,
              'object-literal': objectLiteralForm,
              // 'sum-product': sumProductForm,
          }[form];
          if (!fn) {
              console.error('Unknown form ' + form);
              return null;
          }
          result = fn(result, engine);
      }
      return result;
  }
  function canonicalDomainForm(expr, engine) {
      return canonicalDomain(engine, expr);
  }

  /**
   */
  function internalN(engine, expr) {
      var _a, _b;
      //
      // 2/ Is it a number?
      //
      const val = (_b = (_a = getComplexValue(expr)) !== null && _a !== void 0 ? _a : getDecimalValue(expr)) !== null && _b !== void 0 ? _b : getNumberValue(expr);
      if (val !== null)
          return val;
      //
      // 3/ Is is a symbol?
      //
      const symbol = getSymbolName(expr);
      if (symbol !== null) {
          const def = engine.getSymbolDefinition(symbol);
          if (def && def.value) {
              if (typeof def.value === 'function') {
                  return internalN(engine, def.value(engine));
              }
              return internalN(engine, def.value);
          }
          return expr;
      }
      //
      // 4/ Is it a dictionary?
      //
      if (getDictionary(expr) !== null) {
          return applyRecursively(expr, (x) => { var _a; return (_a = internalN(engine, x)) !== null && _a !== void 0 ? _a : x; });
      }
      //
      // 5/ Is it a function?
      //
      if (getFunctionHead(expr) !== null)
          return applyN(engine, expr);
      // Probably a string...
      return expr;
  }
  /**
   * Assuming that expr is a function expression, apply the
   * function to its arguments:
   *
   * - either by using a function definition
   * - or if the head is an expression, interpreting it as a lambda
   */
  function applyN(engine, expr) {
      var _a, _b, _c, _d, _e;
      const head = getFunctionHead(expr);
      console.assert(head !== null);
      if (typeof head === 'string') {
          const def = engine.getFunctionDefinition(head);
          // @todo:handle idempotent, threadable functions
          //
          // 1/ Numeric function
          //    (takes all numeric arguments, return a numeric)
          //
          if (def && def.numeric) {
              // The function is `numeric`: it expects all its arguments to be
              // `numbers` or `Decimal` or `Complex` and it should not have Hold arguments.
              const args = [];
              let numberCount = 0;
              let decimalCount = 0;
              let complexCount = 0;
              for (let arg of getTail(expr)) {
                  if (getFunctionName(arg) === 'Evaluate') {
                      // This is a forced evaluation (that's a no-op)
                      arg = (_a = getArg(arg, 1)) !== null && _a !== void 0 ? _a : MISSING;
                  }
                  if (getFunctionName(arg) === 'Hold') {
                      // This is a forced Hold. We'll keep the arg, but won't be able to
                      // call the evalNumber, evalDecimal or evalComplex functions.
                      args.push(arg);
                  }
                  else {
                      const val = internalN(engine, arg);
                      if (val instanceof decimal.exports.Decimal) {
                          decimalCount += 1;
                          args.push(val);
                      }
                      else if (val instanceof complex.exports.Complex) {
                          complexCount += 1;
                          args.push(val);
                      }
                      else if (typeof val === 'number') {
                          numberCount += 1;
                          args.push(val);
                      }
                      else {
                          args.push(val !== null && val !== void 0 ? val : arg);
                      }
                  }
              }
              // Try to use the preferred format, but if we don't have a `evalDecimal`
              // or `evalComplex` function, we'll fallback to getting machine numbers.
              let format = engine.numericFormat;
              if (format === 'auto') {
                  if (complexCount > 0) {
                      format = 'complex';
                  }
                  else if (decimalCount > 0) {
                      format = 'decimal';
                  }
                  else {
                      format = 'machine';
                  }
              }
              if ((format === 'decimal' && typeof def.evalDecimal !== 'function') ||
                  (format === 'complex' && typeof def.evalComplex !== 'function')) {
                  format = 'machine';
              }
              const numericCount = numberCount + decimalCount + complexCount;
              if (numericCount === args.length) {
                  // All the arguments were numeric...
                  if (format == 'decimal' && complexCount === 0) {
                      // All the arguments were `number` or `Decimal`
                      console.assert(typeof def.evalDecimal === 'function');
                      return def.evalDecimal(engine, ...args);
                  }
                  if (format == 'complex' && decimalCount === 0) {
                      // All the arguments were `number` or `Complex`
                      console.assert(typeof def.evalComplex === 'function');
                      return def.evalComplex(engine, ...args);
                  }
                  if (typeof def.evalNumber === 'function' &&
                      numberCount === numericCount) {
                      // All the arguments were number
                      return def.evalNumber(engine, ...args);
                  }
              }
              // The arguments were not all numeric. Call `evaluate` on the
              // function if there is one
              return typeof def.evaluate === 'function'
                  ? def.evaluate(engine, ...args)
                  : [head, ...args];
          }
          //
          // 2. Non-numeric function with an `evaluate()`
          //
          if (def) {
              // Pass the arguments marked 'Hold' unchanged, evaluate the rest.
              const args = [];
              const tail = getTail(expr);
              for (let i = 0; i < tail.length; i++) {
                  const name = getFunctionName(tail[i]);
                  if (name === 'Hold') {
                      args.push((_b = getArg(tail[i], 1)) !== null && _b !== void 0 ? _b : MISSING);
                  }
                  else if (name === 'Evaluate') {
                      const arg1 = (_c = getArg(tail[i], 1)) !== null && _c !== void 0 ? _c : MISSING;
                      args.push((_d = internalN(engine, arg1)) !== null && _d !== void 0 ? _d : arg1);
                  }
                  else if ((i === 0 && def.hold === 'first') ||
                      (i > 0 && def.hold === 'rest') ||
                      def.hold === 'all') {
                      args.push(tail[i]);
                  }
                  else {
                      args.push((_e = internalN(engine, tail[i])) !== null && _e !== void 0 ? _e : tail[i]);
                  }
              }
              // @todo: async evaluate
              if (typeof def.evaluate === 'function') {
                  return def.evaluate(engine, ...args);
              }
              return [head, ...args];
          }
      }
      //
      // 3. The function is a lambda
      //    (the head is an expression)
      //
      const args = {
          __: ['Sequence', getTail(expr)],
      };
      let n = 1;
      for (const arg of getTail(expr)) {
          if (n === 1)
              args['_'] = arg;
          args[`_${n}`] = arg;
          n += 1;
      }
      return internalN(engine, substitute(head, args));
  }

  function evaluateOnce(engine, expr) {
      var _a, _b, _c, _d, _e, _f;
      if (expr === null)
          return null;
      //
      // 1/ Is it a number?
      //
      const val = (_b = (_a = getDecimalValue(expr)) !== null && _a !== void 0 ? _a : getNumberValue(expr)) !== null && _b !== void 0 ? _b : getComplexValue(expr);
      if (val !== null)
          return val;
      //
      // 2/ Is is a symbol?
      //
      const symbol = getSymbolName(expr);
      if (symbol !== null) {
          const def = engine.getSymbolDefinition(symbol);
          if (def && def.value) {
              if (typeof def.value === 'function')
                  return def.value(engine);
              return def.value;
          }
          return expr;
      }
      //
      // 3/ Is it a dictionary?
      //
      if (getDictionary(expr) !== null) {
          return applyRecursively(expr, (x) => { var _a; return (_a = evaluateOnce(engine, x)) !== null && _a !== void 0 ? _a : x; });
      }
      //
      // 4/ Is it a function?
      //
      const head = getFunctionHead(expr);
      if (head !== null) {
          if (typeof head === 'string') {
              const def = engine.getFunctionDefinition(head);
              // If it's an unknown functin, we don't know how to handle the arguments
              if (def === null)
                  return expr;
              //
              // 4.1/ It's a function with a definition:
              //      process the arguments
              //
              const args = [];
              const tail = getTail(expr);
              for (let i = 0; i < tail.length; i++) {
                  const name = getFunctionName(tail[i]);
                  if (name === 'Hold') {
                      args.push((_c = getArg(tail[i], 1)) !== null && _c !== void 0 ? _c : MISSING);
                  }
                  else if (name === 'Evaluate') {
                      const arg1 = (_d = getArg(tail[i], 1)) !== null && _d !== void 0 ? _d : MISSING;
                      args.push((_e = internalN(engine, arg1)) !== null && _e !== void 0 ? _e : arg1);
                  }
                  else if ((i === 0 && def.hold === 'first') ||
                      (i > 0 && def.hold === 'rest') ||
                      def.hold === 'all') {
                      args.push(tail[i]);
                  }
                  else {
                      args.push((_f = evaluateOnce(engine, tail[i])) !== null && _f !== void 0 ? _f : tail[i]);
                  }
              }
              // @todo: async evaluate
              if (typeof def.evaluate === 'function') {
                  return def.evaluate(engine, ...args);
              }
              return [head, ...args];
          }
          //
          // 4.2/ It's a lambda function
          //
          const args = {
              __: ['Sequence', getTail(expr)],
          };
          let n = 1;
          for (const arg of getTail(expr)) {
              if (n === 1)
                  args['_'] = arg;
              args[`_${n}`] = arg;
              n += 1;
          }
          return evaluateOnce(engine, substitute(head, args));
      }
      return expr;
  }
  /**
   * Evaluate until:
   * - the timeLimit is reached
   * - the iterationLimit is reached
   * - the expression stops changing
   */
  async function internalEvaluate(engine, expr, options) {
      var _a, _b, _c, _d;
      const timeLimit = (_b = (_a = options === null || options === void 0 ? void 0 : options.timeLimit) !== null && _a !== void 0 ? _a : engine.timeLimit) !== null && _b !== void 0 ? _b : 2.0;
      if (timeLimit && isFinite(timeLimit)) {
          engine.deadline = Date.now() + timeLimit * 1000;
      }
      const iterationLimit = (_d = (_c = options === null || options === void 0 ? void 0 : options.iterationLimit) !== null && _c !== void 0 ? _c : engine.iterationLimit) !== null && _d !== void 0 ? _d : 1024;
      let iterationCount = 0;
      let result = expr;
      let prevResult = JSON.stringify(result);
      while (iterationCount < iterationLimit && engine.shouldContinueExecution()) {
          result = evaluateOnce(engine, result);
          if (result === null)
              return null;
          const curResult = JSON.stringify(result);
          if (prevResult === curResult)
              return result;
          prevResult = curResult;
          iterationCount += 1;
      }
      // Convert the result to canonical form
      return engine.canonical(result);
  }

  // Generator functions
  // export function fixPoint(rule: Rule);
  // export function chain(rules: RuleSet);
  const SUBS = {
      x: '_x',
      y: '_y',
      z: '_z',
      a: '_a',
      b: '_b',
      c: '_c',
      m: '_m',
      n: '_n',
      i: '_i',
      j: '_j',
  };
  function rules(ce, rs) {
      const result = new Set();
      for (const [lhs, rhs, condition] of rs) {
          // The `lhs` when given as an expression (and not a Latex string)
          // may not be in canonical form: this is used to rewrite some non-canonical
          // expression to canonical form.
          const xlhs = typeof lhs === 'string'
              ? ce.canonical(substituteSymbols(ce.parse(lhs), SUBS))
              : substituteSymbols(lhs, SUBS);
          const xrhs = typeof rhs === 'string'
              ? ce.canonical(substituteSymbols(ce.parse(rhs), SUBS))
              : substituteSymbols(rhs, SUBS);
          if (typeof condition === 'function' || typeof condition === 'undefined') {
              result.add([xlhs, xrhs, condition]);
          }
          else if (typeof condition === 'string') {
              const xcond = ce.parse(condition);
              result.add([
                  xlhs,
                  xrhs,
                  (ce, sub) => { var _a; return (_a = ce.is(substitute(xcond, sub))) !== null && _a !== void 0 ? _a : false; },
              ]);
          }
      }
      return result;
  }
  function substituteSymbols(expr, sub) {
      for (const [symbol, replacement] of Object.entries(sub)) {
          console.assert(typeof replacement === 'string');
          expr = substituteSymbol(expr, symbol, replacement);
      }
      return expr;
  }
  function substituteSymbol(expr, symbol, replacement) {
      const sym = getSymbolName(expr);
      if (sym === symbol)
          return replacement;
      const name = getFunctionName(expr);
      if (name === symbol) {
          return [replacement, getTail(expr)];
      }
      if (isAtomic(expr))
          return expr;
      return applyRecursively(expr, (x) => substituteSymbol(x, symbol, replacement));
  }
  function applyRule(ce, [lhs, rhs, condition], expr) {
      const sub = match(lhs, expr);
      if (sub === null)
          return null;
      if (typeof condition === 'function' && !condition(ce, sub))
          return null;
      console.log('Applying rule ', ce.serialize(lhs), '->', ce.serialize(rhs));
      return substitute(rhs, sub);
  }
  /**
   * Repeatedely apply rules in the ruleset until no rules apply
   */
  function replace(ce, rules, expr) {
      let done = false;
      while (!done) {
          done = true;
          for (const rule of rules) {
              const result = applyRule(ce, rule, expr);
              if (result !== null) {
                  done = false;
                  expr = result;
              }
          }
      }
      return expr;
  }
  // @todo ['Alternatives', ...]:
  // @todo: ['Condition',...] : Conditional match
  // @todo: ['Repeated',...] : repeating match
  // @todo _x:Head or _x:RealNumber
  // replace() -> replace matching patterns with another expression
  // replaceAll(), replaceRepeated()

  /**
   * The internal  compute engine implements the ComputeEngine interface
   * but does not:
   * - account for time limits
   * - account for iteration limits
   * - apply a canonical form
   *
   * It is used for recursive calls, and by the "top-level" `ComputeEngine`.
   */
  class InternalComputeEngine {
      constructor(options) {
          var _a;
          const dicts = (_a = options === null || options === void 0 ? void 0 : options.dictionaries) !== null && _a !== void 0 ? _a : InternalComputeEngine.getDictionaries();
          this.numericFormat = 'auto';
          this.tolerance = NUMERICAL_TOLERANCE;
          for (const dict of dicts) {
              if (!this.context) {
                  //
                  // The first, topmost, scope contains additional info
                  //
                  this.pushScope(dict, {
                      warn: (sigs) => {
                          for (const sig of sigs) {
                              if (typeof sig.message === 'string') {
                                  console.warn(sig.message);
                              }
                              else {
                                  console.warn(...sig.message);
                              }
                          }
                      },
                      timeLimit: 2.0,
                      memoryLimit: 1.0,
                      recursionLimit: 1024,
                      // iterationLimit:    no iteration limit
                  });
              }
              else {
                  this.pushScope(dict);
              }
          }
          // Push a fresh scope to protect global definitions.
          this.pushScope({});
      }
      static getDictionaries(categories = 'all') {
          return getDefaultDictionaries(categories);
      }
      get precision() {
          return this._precision;
      }
      set precision(p) {
          if (p === 'machine')
              p = Math.min(MACHINE_PRECISION, Math.floor(MACHINE_PRECISION));
          if (p <= MACHINE_PRECISION) {
              this._numericFormat = 'machine';
          }
          decimal.exports.Decimal.set({ precision: p });
          this._precision = p;
      }
      get numericFormat() {
          return this._numericFormat;
      }
      set numericFormat(f) {
          if (f === 'machine' || f === 'complex' || f === 'auto') {
              this._precision = Math.floor(MACHINE_PRECISION);
          }
          else if (f === 'decimal') {
              this._precision = decimal.exports.Decimal.precision;
          }
          this._numericFormat = f;
      }
      get tolerance() {
          return this._tolerance;
      }
      set tolerance(val) {
          this._tolerance = Math.max(val, 0);
      }
      /** Generator function (indicated by the leading '*') that returns all the
       *  rules in all the topics requested.
       */
      *getRules(topics) {
          if (!this._rules) {
              this._rules = {};
              for (const topic of Object.keys(SIMPLIFY_RULES)) {
                  this._rules[topic] = rules(this, SIMPLIFY_RULES[topic]);
              }
          }
          if (typeof topics === 'string')
              topics = [topics];
          for (const topic of topics) {
              if (this._rules[topic]) {
                  for (const rule of this._rules[topic])
                      yield rule;
              }
              else {
                  console.error('Unknown rules topic ', topic);
              }
          }
      }
      get latexSyntax() {
          if (!this._latexSyntax)
              this._latexSyntax = new LatexSyntax();
          return this._latexSyntax;
      }
      pushScope(dictionary, scope) {
          this.context = {
              ...scope,
              parentScope: this.context,
              dictionary: compileDictionary(dictionary, this),
              assumptions: this.context
                  ? new ExpressionMap(this.context.assumptions)
                  : new ExpressionMap(),
          };
      }
      popScope() {
          var _a;
          const parentScope = (_a = this.context) === null || _a === void 0 ? void 0 : _a.parentScope;
          // If there are some warnings, handle them
          if (this.context.warnings) {
              const warnings = [...this.context.warnings];
              this.context.warnings = [];
              if (this.context.warn) {
                  this.context.warn(warnings);
              }
          }
          // If there are some unhandled warnings, or warnings signaled during the
          // warning handler, propagate them.
          if (parentScope &&
              this.context.warnings &&
              this.context.warnings.length > 0) {
              if (!parentScope.warnings) {
                  parentScope.warnings = [...this.context.warnings];
              }
              else {
                  parentScope.warnings = [
                      ...parentScope.warnings,
                      ...this.context.warnings,
                  ];
              }
          }
          this.context = parentScope;
      }
      get assumptions() {
          if (this.context.assumptions)
              return this.context.assumptions;
          this.context.assumptions = new ExpressionMap();
          return this.context.assumptions;
      }
      signal(_sig) {
          // @todo
          return;
      }
      get timeLimit() {
          let scope = this.context;
          while (scope) {
              if (scope.timeLimit !== undefined)
                  return scope.timeLimit;
              scope = scope.parentScope;
          }
          return undefined;
      }
      get recursionLimit() {
          let scope = this.context;
          while (scope) {
              if (scope.recursionLimit !== undefined)
                  return scope.recursionLimit;
              scope = scope.parentScope;
          }
          return undefined;
      }
      get iterationLimit() {
          let scope = this.context;
          while (scope) {
              if (scope.iterationLimit !== undefined)
                  return scope.iterationLimit;
              scope = scope.parentScope;
          }
          return undefined;
      }
      shouldContinueExecution() {
          return this.deadline === undefined || this.deadline >= Date.now();
      }
      checkContinueExecution() {
          if (!this.shouldContinueExecution()) {
              throw new CortexError({
                  message: 'timeout', // @todo: should capture stack
              });
          }
      }
      getFunctionDefinition(name) {
          var _a, _b;
          let scope = this.context;
          let def = undefined;
          while (scope && !def) {
              def = (_a = scope.dictionary) === null || _a === void 0 ? void 0 : _a.get(name);
              if (def !== undefined && !isFunctionDefinition(def))
                  def = undefined;
              if (def === undefined)
                  scope = scope.parentScope;
          }
          if (def)
              def.scope = scope;
          return (_b = def) !== null && _b !== void 0 ? _b : null;
      }
      getSymbolDefinition(name) {
          var _a;
          let scope = this.context;
          let def = undefined;
          while (scope && !def) {
              def = (_a = scope.dictionary) === null || _a === void 0 ? void 0 : _a.get(name);
              if (def !== undefined && !isSymbolDefinition(def))
                  def = undefined;
              if (def === undefined)
                  scope = scope.parentScope;
          }
          if (!def)
              return null;
          def.scope = scope;
          return def;
      }
      getSetDefinition(name) {
          var _a;
          let scope = this.context;
          let def = undefined;
          while (scope && !def) {
              def = (_a = scope.dictionary) === null || _a === void 0 ? void 0 : _a.get(name);
              if (def !== undefined && !isSetDefinition(def))
                  def = undefined;
              if (def === undefined)
                  scope = scope.parentScope;
          }
          if (!def)
              return null;
          def.scope = scope;
          return def;
      }
      getCollectionDefinition(name) {
          var _a;
          let scope = this.context;
          let def = undefined;
          while (scope && !def) {
              def = (_a = scope.dictionary) === null || _a === void 0 ? void 0 : _a.get(name);
              if (def !== undefined && !isCollectionDefinition(def))
                  def = undefined;
              if (def === undefined)
                  scope = scope.parentScope;
          }
          if (!def)
              return null;
          def.scope = scope;
          return def;
      }
      getDefinition(name) {
          var _a;
          let scope = this.context;
          let def = undefined;
          while (scope && !def) {
              def = (_a = scope.dictionary) === null || _a === void 0 ? void 0 : _a.get(name);
              if (def === undefined)
                  scope = scope.parentScope;
          }
          if (!def)
              return null;
          def.scope = scope;
          return def;
      }
      canonical(expr) {
          return this.format(expr);
      }
      format(expr, forms) {
          return format$1(this, expr, Array.isArray(forms) ? forms : [forms !== null && forms !== void 0 ? forms : 'canonical']);
      }
      evaluate(expr, options) {
          return internalEvaluate(this, expr, options);
      }
      simplify(expr, options) {
          return internalSimplify(this, expr, options === null || options === void 0 ? void 0 : options.simplifications);
      }
      N(expr, options) {
          const savedPrecision = this.precision;
          const savedNumericFormat = this.numericFormat;
          if (options === null || options === void 0 ? void 0 : options.precision)
              this.precision = options.precision;
          //
          // 1/ Prepare the expression by simplifying it
          // (this will simplify things like `Parentheses` and other things\
          // that could throw us off)
          //
          let result = this.canonical(internalSimplify(this, expr));
          if (result !== null)
              result = internalN(this, result);
          if (result !== null)
              result = this.canonical(result);
          this.precision = savedPrecision;
          this.numericFormat = savedNumericFormat;
          return result !== null && result !== void 0 ? result : expr;
      }
      // is(symbol: Expression, domain: Domain): boolean | undefined;
      // is(proposition: Expression): boolean | undefined;
      is(arg1, arg2) {
          let proposition = arg1;
          if (arg2) {
              proposition = ['Element', arg1, arg2];
          }
          return internalIs(this, proposition);
      }
      ask(pattern) {
          const result = [];
          for (const assumption in this.assumptions) {
              const m = match(pattern, assumption, {
                  numericalTolerance: this._tolerance,
              });
              if (m !== null)
                  result.push(m);
          }
          return result;
      }
      // assume(
      //   symbol: Expression,
      //   domain: Domain
      // ): 'contradiction' | 'tautology' | 'ok';
      // assume(predicate: Expression): 'contradiction' | 'tautology' | 'ok';
      assume(arg1, arg2) {
          let predicate = arg1;
          if (arg2) {
              predicate = ['Element', arg1, arg2];
          }
          return internalAssume(this, predicate);
      }
      replace(rules, expr) {
          return replace(this, rules, expr);
      }
      domain(expr) {
          return internalDomain(this, expr);
      }
      getVars(expr) {
          return getVariables(this, expr);
      }
      chop(n) {
          if (typeof n === 'number') {
              return Math.abs(n) <= this._tolerance ? 0 : n;
          }
          else if (n instanceof complex.exports.Complex) {
              if (Math.abs(n.re) <= this._tolerance &&
                  Math.abs(n.im) <= this._tolerance) {
                  return 0;
              }
              else {
                  return n;
              }
          }
          else if (n instanceof decimal.exports.Decimal) {
              return n.abs().lte(this._tolerance) ? DECIMAL_ZERO : n;
          }
          return n;
      }
      parse(s) {
          return this.latexSyntax.parse(s);
      }
      serialize(x) {
          return this.latexSyntax.serialize(x);
      }
      isZero(x) {
          return isZero(this, x);
      }
      isNotZero(x) {
          return isNotZero(this, x);
      }
      isNumeric(x) {
          return isNumeric();
      }
      isInfinity(x) {
          return isInfinity(this, x);
      }
      // Not +- Infinity, not NaN
      isFinite(x) {
          return isFinite$1();
      }
      // x >= 0
      isNonNegative(x) {
          return isNonNegative(this, x);
      }
      // x > 0
      isPositive(x) {
          return isPositive(this, x);
      }
      // x < 0
      isNegative(x) {
          return isNegative(this, x);
      }
      // x <= 0
      isNonPositive(x) {
          return isNonPositive(this, x);
      }
      isInteger(x) {
          return isInteger(this, x);
      }
      isRational(x) {
          return isRational();
      }
      isAlgebraic(x) {
          return isAlgebraic();
      }
      isReal(x) {
          return isReal(this, x);
      }
      // Real or +-Infinity
      isExtendedReal(x) {
          return isExtendedReal();
      }
      isComplex(x) {
          return isComplex();
      }
      isOne(x) {
          return isOne();
      }
      isNegativeOne(x) {
          return isNegativeOne();
      }
      isElement(x, set) {
          return isElement();
      }
      isSubsetOf(lhs, rhs) {
          return isSubsetOf(this, lhs, rhs);
      }
      isEqual(lhs, rhs) {
          return isEqual();
      }
      isLess(lhs, rhs) {
          return isLess();
      }
      isLessEqual(lhs, rhs) {
          return isLessEqual();
      }
      isGreater(lhs, rhs) {
          return isGreater();
      }
      isGreaterEqual(lhs, rhs) {
          return isGreaterEqual();
      }
  }

  class ComputeEngine {
      constructor(options) {
          this.internal = new InternalComputeEngine(options);
      }
      static getDictionaries(categories = 'all') {
          return InternalComputeEngine.getDictionaries(categories);
      }
      get precision() {
          return this.internal.precision;
      }
      set precision(p) {
          this.internal.precision = p;
      }
      get numericFormat() {
          return this.internal.numericFormat;
      }
      set numericFormat(f) {
          this.internal.numericFormat = f;
      }
      get tolerance() {
          return this.internal.tolerance;
      }
      set tolerance(val) {
          this.internal.tolerance = val;
      }
      get context() {
          return this.internal.context;
      }
      pushScope(dictionary, scope) {
          this.internal.pushScope(dictionary, scope);
      }
      popScope() {
          this.internal.popScope();
      }
      get assumptions() {
          return this.internal.assumptions;
      }
      shouldContinueExecution() {
          return this.internal.shouldContinueExecution();
      }
      checkContinueExecution() {
          this.internal.checkContinueExecution();
      }
      signal(sig) {
          this.internal.signal(sig);
      }
      getFunctionDefinition(name) {
          return this.internal.getFunctionDefinition(name);
      }
      getSymbolDefinition(name) {
          return this.internal.getSymbolDefinition(name);
      }
      getSetDefinition(name) {
          return this.internal.getSetDefinition(name);
      }
      getCollectionDefinition(name) {
          return this.internal.getCollectionDefinition(name);
      }
      getDefinition(name) {
          return this.internal.getDefinition(name);
      }
      getRules(topic) {
          return this.internal.getRules(topic);
      }
      format(expr, forms) {
          return this.internal.format(expr, forms);
      }
      /**
       * Return the canonical form of an expression.
       */
      canonical(expr) {
          return this.internal.format(expr, ['canonical']);
      }
      /**
       * Return a numerical approximation of an expression.
       */
      N(expr) {
          return this.internal.N(expr);
      }
      /**
       * Attempt to simplify an expression, that is rewrite it in a simpler form,
       * making use of the available assumptions.
       *
       * The simplification steps will proceed multiple times until either:
       * 1/ the expression stop changing
       * 2/ the number of iteration exceeds `iterationLimit`
       * 3/ the time to compute exceeds `timeLimit`, expressed in seconds
       *
       * If no `timeLimit` or `iterationLimit` are provided, the values
       * from the current ComputeEngine context are used. By default those
       * values are an infinite amount of iterations and a 2s time limit.
       *
       */
      simplify(expr, options) {
          var _a, _b, _c, _d;
          const timeLimit = (_b = (_a = options === null || options === void 0 ? void 0 : options.timeLimit) !== null && _a !== void 0 ? _a : this.internal.timeLimit) !== null && _b !== void 0 ? _b : 2.0;
          if (timeLimit && isFinite(timeLimit)) {
              this.internal.deadline = Date.now() + timeLimit * 1000;
          }
          const iterationLimit = (_d = (_c = options === null || options === void 0 ? void 0 : options.iterationLimit) !== null && _c !== void 0 ? _c : this.internal.iterationLimit) !== null && _d !== void 0 ? _d : 1024;
          let iterationCount = 0;
          let result = this.canonical(expr);
          let prevResult = result;
          while (iterationCount < iterationLimit && this.shouldContinueExecution()) {
              result = this.internal.simplify(result, {
                  simplifications: options === null || options === void 0 ? void 0 : options.simplifications,
              });
              if (result === null)
                  return prevResult;
              if (equalExpr(prevResult, result))
                  return this.canonical(result);
              prevResult = result;
              iterationCount += 1;
          }
          if (result === null)
              return null;
          return this.canonical(result);
      }
      /**
       * Return a simplified and numerically approximation of an expression
       * in canonical form.
       *
       * The simplification steps will proceed multiple times until either:
       * 1/ the expression stop changing
       * 2/ the number of iteration exceeds `iterationLimit`
       * 3/ the time to compute exceeds `timeLimit`, expressed in seconds
       *
       * If no `timeLimit` or `iterationLimit` are provided, the values
       * from the current ComputeEngine context are used. By default those
       * values are an infinite amount of iterations and a 2s time limit.
       */
      async evaluate(expr, options) {
          const val = this.internal.evaluate(expr, options);
          if (val === null)
              return null;
          return this.canonical(await val);
      }
      parse(s) {
          return this.internal.parse(s);
      }
      serialize(x) {
          return this.serialize(x);
      }
      domain(expr) {
          return this.internal.domain(expr);
      }
      is(arg1, arg2) {
          return this.internal.is(arg1, arg2);
      }
      ask(pattern) {
          return this.internal.ask(pattern);
      }
      assume(arg1, arg2) {
          return this.internal.assume(arg1, arg2);
      }
      replace(rules, expr) {
          return this.internal.replace(rules, expr);
      }
      getVars(expr) {
          return this.internal.getVars(expr);
      }
      chop(n) {
          return this.internal.chop(n);
      }
      isZero(x) {
          return this.internal.isZero(x);
      }
      isNotZero(x) {
          return this.internal.isNotZero(x);
      }
      isNumeric(x) {
          return this.internal.isNumeric(x);
      }
      isInfinity(x) {
          return this.internal.isInfinity(x);
      }
      // Not +- Infinity, not NaN
      isFinite(x) {
          return this.internal.isFinite(x);
      }
      // x >= 0
      isNonNegative(x) {
          return this.internal.isNonNegative(x);
      }
      // x > 0
      isPositive(x) {
          return this.internal.isPositive(x);
      }
      // x < 0
      isNegative(x) {
          return this.internal.isNegative(x);
      }
      // x <= 0
      isNonPositive(x) {
          return this.internal.isNonPositive(x);
      }
      isInteger(x) {
          return this.internal.isInteger(x);
      }
      isRational(x) {
          return this.internal.isRational(x);
      }
      isAlgebraic(x) {
          return this.internal.isAlgebraic(x);
      }
      isReal(x) {
          return this.internal.isReal(x);
      }
      // Real or +-Infinity
      isExtendedReal(x) {
          return this.internal.isExtendedReal(x);
      }
      isComplex(x) {
          return this.internal.isComplex(x);
      }
      isOne(x) {
          return this.internal.isOne(x);
      }
      isNegativeOne(x) {
          return this.internal.isNegativeOne(x);
      }
      isElement(x, set) {
          return this.internal.isElement(x, set);
      }
      isSubsetOf(lhs, rhs) {
          return this.internal.isSubsetOf(lhs, rhs);
      }
      isEqual(lhs, rhs) {
          return this.internal.isEqual(lhs, rhs);
      }
      isLess(lhs, rhs) {
          return this.internal.isLess(lhs, rhs);
      }
      isLessEqual(lhs, rhs) {
          return this.internal.isLessEqual(lhs, rhs);
      }
      isGreater(lhs, rhs) {
          return this.internal.isGreater(lhs, rhs);
      }
      isGreaterEqual(lhs, rhs) {
          return this.internal.isGreaterEqual(lhs, rhs);
      }
  }
  let gComputeEngine = null;
  function format(expr, forms) {
      if (gComputeEngine === null)
          gComputeEngine = new ComputeEngine();
      return gComputeEngine.format(expr, forms);
  }
  function evaluate(expr) {
      if (gComputeEngine === null)
          gComputeEngine = new ComputeEngine();
      return gComputeEngine.evaluate(expr);
  }

  const LINEBREAK = /\r\n|[\n\r\u2028\u2029]/;
  const htmlTerminal = {
      joinLines(lines) {
          return `<div>${lines.join('</div><div>')}</div>`;
      },
      grey(s) {
          return `<span style="opacity:.5">${s}</span>`;
      },
      red(s) {
          return `<span style="color:#F33">${s}</span>`;
      },
      highlightBackground(s) {
          return `<span style="background:rgba(255, 100, 100, .1);display:block;border-radius: 4px">${s}</span>`;
      },
  };
  const terminal = htmlTerminal;
  class Origin {
      constructor(source, url) {
          this.source = source;
          this.url = url !== null && url !== void 0 ? url : '';
      }
      get lines() {
          if (!this._lines)
              this._lines = this.source.split(LINEBREAK);
          return this._lines;
      }
      get lineOffsets() {
          if (this._lineOffsets == null) {
              const offsets = [];
              const text = this.source;
              let isLineStart = true;
              let i = 0;
              while (i < text.length) {
                  if (isLineStart) {
                      offsets.push(i);
                      isLineStart = false;
                  }
                  const ch = text.charCodeAt(i);
                  isLineStart = ch === 13 || ch === 10 || ch === 0x2028 || ch === 0x2029;
                  if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
                      i++;
                  }
                  i++;
              }
              if (isLineStart && text.length > 0)
                  offsets.push(text.length);
              this._lineOffsets = offsets;
          }
          return this._lineOffsets;
      }
      getLinecol(offset) {
          offset = Math.max(Math.min(offset, this.source.length), 0);
          const lineOffsets = this.lineOffsets;
          let low = 0;
          let high = lineOffsets.length;
          if (high === 0)
              return [1, offset + 1];
          while (low < high) {
              const mid = Math.floor((low + high) / 2);
              if (lineOffsets[mid] > offset)
                  high = mid;
              else
                  low = mid + 1;
          }
          return [low, offset - lineOffsets[low - 1] + 1];
      }
      signalOrigin(offset) {
          const [line, column] = this.getLinecol(offset);
          return {
              url: this.url,
              source: this.source,
              offset: offset,
              line,
              column,
              around: this.sourceAround(line, column),
          };
      }
      chalkGutter(s) {
          return terminal.grey(s);
      }
      chalkMarker(s) {
          return terminal.red(s);
      }
      chalkMessage(s) {
          return terminal.red(s);
      }
      /** line: 1..., column: 1... */
      sourceAround(line, column, message) {
          const linesAbove = 2;
          const linesBelow = 3;
          const start = Math.max(line - 1 - (linesAbove + 1), 0);
          const end = Math.min(this.lines.length, line + linesBelow) - 1;
          const hasColumn = typeof column === 'number';
          const numberMaxWidth = String(end).length;
          const result = [];
          // index = 0..., start = 0... end = 0...
          for (let index = start; index <= end; index++) {
              const paddedNumber = ` ${index + 1}`.slice(-numberMaxWidth);
              const gutter = ` ${paddedNumber} \u2506 `;
              let markerLine = '';
              if (index === line - 1) {
                  if (hasColumn) {
                      const markerSpacing = this.lines[index]
                          .slice(0, Math.max(column - 1, 0))
                          .replace(/[^\t]/g, ' ');
                      markerLine = terminal.joinLines([
                          '',
                          [
                              ' ',
                              this.chalkGutter(gutter.replace(/\d/g, ' ')),
                              markerSpacing,
                              this.chalkMarker('^'),
                          ].join(''),
                      ]);
                      if (message) {
                          markerLine += ' ' + this.chalkMessage(message);
                      }
                  }
                  else if (message) {
                      markerLine = terminal.joinLines([
                          '',
                          this.chalkGutter(gutter.replace(/\d/g, ' ')) + message,
                      ]);
                  }
                  result.push(terminal.highlightBackground([
                      this.chalkMarker('>'),
                      this.chalkGutter(gutter),
                      this.lines[index],
                      markerLine,
                  ].join('')));
              }
              else {
                  result.push(` ${this.chalkGutter(gutter)}${this.lines[index]}`);
              }
          }
          return terminal.joinLines(result);
          /**
        1111 |     expect(
          12 |       rawExpression('\\sqrt{(1+x_0)}=\\frac{\\pi^2}{2}')
        > 13 |     ).toMatchInlineSnapshot(
             |       ^
          14 |       `'["Latex","\\\\sqrt","<{>","(",1,"+","x","_",0,")","<}>","=","\\\\frac","<{>","\\\\pi","^",2,"<}>","<{>",2,"<}>"]'`
          15 |     );
          16 |   });
          */
      }
  }

  const LINEBREAK_CHARACTER = [
      0x000a,
      0x000d,
      0x2028,
      0x2029, // PARAGRAPH SEPARATOR
  ];
  // UNICODE IDENTIFIER AND PATTERN SYNTAX:
  // https://unicode.org/reports/tr31/#R3
  // Pattern_White_Space is an immutable set of characters defined by Unicode.
  // See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt and
  // http://unicode.org/L2/L2005/05012r-pattern.html
  const PATTERN_WHITE_SPACE = [
      0x0009,
      0x000a,
      0x000b,
      0x000c,
      0x000d,
      0x0020,
      0x0085,
      0x200e,
      0x200f,
      0x2028,
      0x2029, // PARAGRAPH SEPARATOR
  ];
  // Pattern_Syntax is an immutable set of characters defined by Unicode
  // See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt and
  // http://unicode.org/L2/L2005/05012r-pattern.html
  //
  // See https://dev.kwayisi.org/apps/unicode/properties/pattern-syntax/true.html
  // Unicode characters with the Pattern_Syntax property are the operators,
  // fences and other punctuations.
  // Identifiers are characters that are not Pattern_White_Space or Pattern_Syntax
  const PATTERN_SYNTAX = expand([
      [0x0021, 0x002f],
      [0x003a, 0x0040],
      [0x005b, 0x005e],
      0x0060,
      [0x007b, 0x007e],
      [0x00a1, 0x00a7],
      0x00a9,
      [0x00ab, 0x00ac],
      0x00ae,
      [0x00b0, 0x00b1],
      0x00b6,
      0x00bb,
      0x00bf,
      0x00d7,
      0x00f7,
      [0x2010, 0x203e],
      [0x2041, 0x2053],
      [0x2190, 0x221a],
      // â‡‡â‡ˆâ‡‰â‡Šâ‡‹â‡Œâ‡â‡Žâ‡â‡â‡‘â‡’â‡“â‡”â‡•â‡–â‡—â‡˜â‡™â‡šâ‡›â‡œâ‡â‡žâ‡Ÿâ‡ â‡¡â‡¢â‡£â‡¤â‡¥â‡¦â‡§â‡¨â‡©â‡ªâ‡«â‡¬â‡­â‡®â‡¯â‡°â‡±â‡²â‡³â‡´â‡µâ‡¶â‡·â‡¸â‡¹â‡ºâ‡»â‡¼â‡½â‡¾â‡¿âˆ€âˆâˆ‚âˆƒâˆ„âˆ…âˆ†âˆ‡âˆˆâˆ‰âˆŠâˆ‹âˆŒâˆâˆŽ
      // âˆâˆâˆ‘âˆ’âˆ“âˆ”âˆ•âˆ–âˆ—âˆ˜âˆ™âˆš
      [0x221b, 0x2775],
      // â‰â‰‘â‰’â‰“â‰”â‰•â‰–â‰—â‰˜â‰™â‰šâ‰›â‰œâ‰â‰žâ‰Ÿâ‰ â‰¡â‰¢â‰£â‰¤â‰¥â‰¦â‰§â‰¨â‰©â‰ªâ‰«â‰¬â‰­â‰®â‰¯â‰°â‰±â‰²â‰³â‰´â‰µ
      [0x2794, 0x2e7f],
      // âž³âž´âžµâž¶âž·âž¸âž¹âžºâž»âž¼âž½âž¾âž¿âŸ€âŸâŸ‚âŸƒâŸ„âŸ…âŸ†âŸ‡âŸˆâŸ‰âŸŠâŸ‹âŸŒâŸâŸŽâŸâŸâŸ‘âŸ’âŸ“âŸ”âŸ•âŸ–âŸ—âŸ˜âŸ™âŸšâŸ›âŸœâŸâŸžâŸŸâŸ âŸ¡âŸ¢âŸ£âŸ¤âŸ¥
      // âŸ¦âŸ§âŸ¨âŸ©âŸªâŸ«âŸ¬âŸ­âŸ®âŸ¯âŸ°âŸ±âŸ²âŸ³âŸ´âŸµâŸ¶âŸ·âŸ¸âŸ¹âŸºâŸ»âŸ¼âŸ½âŸ¾âŸ¿â €
      // â â ‚â ƒâ „â …â †â ‡â ˆâ ‰â Šâ ‹â Œâ â Žâ â â ‘â ’â “â ”â •â –â —â ˜â ™â šâ ›â œâ â žâ Ÿâ  â ¡â ¢â £â ¤â ¥â ¦â §â ¨â ©â ªâ «â ¬â ­â ®â ¯â °â ±â ²â ³â ´â µâ ¶â ·â ¸â ¹â ºâ »â ¼â ½â ¾â ¿
      // â¡€â¡â¡‚â¡ƒâ¡„â¡…â¡†â¡‡â¡ˆâ¡‰â¡Šâ¡‹â¡Œâ¡â¡Žâ¡â¡â¡‘â¡’â¡“â¡”â¡•â¡–â¡—â¡˜â¡™â¡šâ¡›â¡œâ¡â¡žâ¡Ÿâ¡ â¡¡â¡¢â¡£â¡¤â¡¥â¡¦â¡§â¡¨â¡©â¡ªâ¡«â¡¬â¡­â¡®â¡¯â¡°â¡±â¡²â¡³â¡´â¡µâ¡¶â¡·â¡¸â¡¹â¡ºâ¡»â¡¼â¡½â¡¾â¡¿
      // â¢€â¢â¢‚â¢ƒâ¢„â¢…â¢†â¢‡â¢ˆâ¢‰â¢Šâ¢‹â¢Œâ¢â¢Žâ¢â¢â¢‘â¢’â¢“â¢”â¢•â¢–â¢—â¢˜â¢™â¢šâ¢›â¢œâ¢â¢žâ¢Ÿâ¢ â¢¡â¢¢â¢£â¢¤â¢¥â¢¦â¢§â¢¨â¢©â¢ªâ¢«â¢¬â¢­â¢®â¢¯â¢°â¢±â¢²â¢³â¢´â¢µâ¢¶â¢·â¢¸â¢¹â¢ºâ¢»â¢¼â¢½â¢¾â¢¿
      //â£€â£â£‚â£ƒâ£„â£…â£†â£‡â£ˆâ£‰â£Šâ£‹â£Œâ£â£Žâ£â£â£‘â£’â£“â£”â£•â£–â£—â£˜â£™â£šâ£›â£œâ£â£žâ£Ÿâ£ â£¡â£¢â££â£¤â£¥â£¦â£§â£¨â£©â£ªâ£«â£¬â£­â£®â£¯â£°â£±â£²â£³â£´â£µâ£¶â£·â£¸â£¹â£ºâ£»â£¼â£½â£¾â£¿
      // â¤€â¤â¤‚â¤ƒâ¤„â¤…â¤†â¤‡â¤ˆâ¤‰â¤Šâ¤‹â¤Œâ¤â¤Žâ¤â¤â¤‘â¤’â¤“â¤”â¤•â¤–â¤—â¤˜â¤™â¤šâ¤›â¤œâ¤â¤žâ¤Ÿâ¤ 
      // â¤¡â¤¢â¤£â¤¤â¤¥â¤¦â¤§â¤¨â¤©â¤ªâ¤«â¤¬â¤­â¤®â¤¯â¤°â¤±â¤²â¤³â¤´â¤µâ¤¶â¤·â¤¸â¤¹â¤ºâ¤»â¤¼â¤½â¤¾â¤¿â¥€â¥â¥‚â¥ƒâ¥„â¥…â¥†â¥‡â¥ˆâ¥‰
      // â¥Šâ¥‹â¥Œâ¥â¥Žâ¥â¥â¥‘â¥’â¥“â¥”â¥•â¥–â¥—â¥˜â¥™â¥šâ¥›â¥œâ¥â¥žâ¥Ÿâ¥ â¥¡â¥¢â¥£â¥¤â¥¥â¥¦â¥§â¥¨â¥©â¥ªâ¥«â¥¬â¥­â¥®â¥¯â¥°â¥±â¥²â¥³â¥´â¥µâ¥¶â¥·â¥¸â¥¹â¥ºâ¥»â¥¼â¥½â¥¾â¥¿â¦€
      // â¦â¦‚â¦ƒâ¦„â¦…â¦†â¦‡â¦ˆâ¦‰â¦Šâ¦‹â¦Œâ¦â¦Žâ¦â¦â¦‘â¦’â¦“â¦”â¦•â¦–â¦—â¦˜â¦™â¦šâ¦›â¦œâ¦â¦žâ¦Ÿâ¦ â¦¡â¦¢â¦£â¦¤â¦¥â¦¦â¦§â¦¨â¦©â¦ªâ¦«â¦¬â¦­â¦®â¦¯â¦°â¦±â¦²â¦³â¦´â¦µâ¦¶â¦·â¦¸â¦¹â¦ºâ¦»â¦¼â¦½â¦¾â¦¿â§€â§â§‚â§ƒâ§„â§…â§†â§‡â§ˆâ§‰â§Šâ§‹â§Œâ§
      // â§Žâ§â§â§‘â§’â§“â§”â§•â§–â§—â§˜â§™â§šâ§›â§œâ§â§žâ§Ÿâ§ â§¡â§¢â§£â§¤â§¥â§¦â§§â§¨â§©â§ªâ§«â§¬â§­â§®â§¯â§°â§±â§²â§³â§´â§µâ§¶â§·â§¸â§¹â§ºâ§»â§¼â§½â§¾â§¿â¨€â¨â¨‚â¨ƒâ¨„â¨…â¨†â¨‡â¨ˆâ¨‰
      // â¨Šâ¨‹â¨Œâ¨â¨Žâ¨â¨â¨‘â¨’â¨“â¨”â¨•â¨–â¨—â¨˜â¨™â¨šâ¨›â¨œâ¨â¨žâ¨Ÿâ¨ â¨¡â¨¢â¨£â¨¤â¨¥â¨¦â¨§â¨¨â¨©â¨ªâ¨«â¨¬â¨­â¨®â¨¯â¨°â¨±â¨²â¨³â¨´â¨µâ¨¶â¨·â¨¸â¨¹â¨ºâ¨»â¨¼â¨½â¨¾â¨¿â©€â©â©‚â©ƒâ©„â©…â©†â©‡â©ˆâ©‰â©Šâ©‹â©Œâ©â©Žâ©â©
      // â©‘â©’â©“â©”â©•â©–â©—â©˜â©™â©šâ©›â©œâ©â©žâ©Ÿâ© â©¡â©¢â©£â©¤â©¥â©¦â©§â©¨â©©â©ªâ©«â©¬â©­â©®â©¯â©°â©±â©²â©³â©´â©µâ©¶â©·â©¸â©¹â©ºâ©»â©¼â©½â©¾â©¿âª€âªâª‚âªƒâª„âª…âª†âª‡âªˆâª‰âªŠâª‹âªŒâªâªŽâªâªâª‘âª’âª“âª”âª•âª–âª—âª˜
      // âª™âªšâª›âªœâªâªžâªŸâª âª¡âª¢âª£âª¤âª¥âª¦âª§âª¨âª©âªªâª«âª¬âª­âª®âª¯âª°âª±âª²âª³âª´âªµâª¶âª·âª¸âª¹âªºâª»âª¼âª½âª¾âª¿â«€â«â«‚â«ƒâ«„â«…â«†â«‡â«ˆâ«‰â«Šâ«‹â«Œâ«â«Žâ«â«â«‘â«’â«“â«”â«•â«–â«—â«˜â«™â«šâ«›â«œâ«â«žâ«Ÿâ« â«¡
      // â«¢â«£â«¤â«¥â«¦â«§â«¨â«©â«ªâ««â«¬â«­â«®â«¯â«°â«±â«²â«³â«´â«µâ«¶â«·â«¸â«¹â«ºâ«»â«¼â«½â«¾â«¿â¬€â¬â¬‚â¬ƒâ¬„â¬…â¬†â¬‡â¬ˆâ¬‰â¬Šâ¬‹â¬Œâ¬â¬Žâ¬â¬â¬‘â¬’â¬“â¬”â¬•â¬–â¬—â¬˜â¬™â¬š
      // â¬›â¬œâ¬â¬žâ¬Ÿâ¬ â¬¡â¬¢â¬£â¬¤â¬¥â¬¦â¬§â¬¨â¬©â¬ªâ¬«â¬¬â¬­â¬®â¬¯â¬°â¬±â¬²â¬³â¬´â¬µâ¬¶â¬·â¬¸â¬¹â¬ºâ¬»â¬¼â¬½â¬¾â¬¿â­€â­â­‚â­ƒâ­„â­…â­†â­‡â­ˆâ­‰â­Šâ­‹â­Œâ­â­Žâ­
      // â­â­‘â­’â­“â­”â­•â­–â­—â­˜â­™â­šâ­›â­œâ­â­žâ­Ÿâ­ â­¡â­¢â­£â­¤â­¥â­¦â­§â­¨â­©â­ªâ­«â­¬â­­â­®â­¯â­°â­±â­²â­³â­´â­µâ­¶â­·â­¸â­¹â­ºâ­»â­¼â­½â­¾â­¿â®€â®â®‚â®ƒâ®„â®…â®†â®‡â®ˆâ®‰â®Šâ®‹â®Œâ®â®Žâ®â®â®‘â®’â®“â®”â®•â®–
      // â®—â®˜â®™â®šâ®›â®œâ®â®žâ®Ÿâ® â®¡â®¢â®£â®¤â®¥â®¦â®§â®¨â®©â®ªâ®«â®¬â®­â®®â®¯â®°â®±â®²â®³â®´â®µâ®¶â®·â®¸â®¹â®ºâ®»â®¼â®½â®¾â®¿â¯€â¯â¯‚â¯ƒâ¯„â¯…â¯†â¯‡â¯ˆâ¯‰â¯Šâ¯‹â¯Œâ¯â¯Žâ¯â¯â¯‘â¯’â¯“â¯”â¯•â¯–â¯—â¯˜â¯™â¯šâ¯›â¯œâ¯â¯žâ¯Ÿâ¯ 
      // â¯¡â¯¢â¯£â¯¤â¯¥â¯¦â¯§â¯¨â¯©â¯ªâ¯«â¯¬â¯­â¯®â¯¯â¯°â¯±â¯²â¯³â¯´â¯µâ¯¶â¯·â¯¸â¯¹â¯ºâ¯»â¯¼â¯½â¯¾â¯¿
      // â°€â°â°‚â°ƒâ°„â°…â°†â°‡â°ˆâ°‰â°Šâ°‹â°Œâ°â°Žâ°â°â°‘â°’â°“â°”â°•â°–â°—â°˜â°™â°šâ°›â°œâ°â°žâ°Ÿâ° â°¡â°¢â°£â°¤â°¥â°¦â°§â°¨â°©â°ªâ°«â°¬â°­â°®â°¯â°°â°±â°²â°³â°´
      //â°µâ°¶â°·â°¸â°¹â°ºâ°»â°¼â°½â°¾â°¿â±€â±â±‚â±ƒâ±„â±…â±†â±‡â±ˆâ±‰â±Šâ±‹â±Œâ±â±Žâ±â±â±‘â±’â±“â±”â±•â±–â±—â±˜â±™â±šâ±›â±œâ±â±žâ±Ÿâ± â±¡â±¢â±£â±¤â±¥â±¦â±§â±¨â±©â±ªâ±«â±¬â±­â±®â±¯â±°â±±â±²â±³â±´â±µâ±¶â±·
      // â±¸â±¹â±ºâ±»â±¼â±½â±¾â±¿â²€â²â²‚â²ƒâ²„â²…â²†â²‡â²ˆâ²‰â²Šâ²‹â²Œâ²â²Žâ²â²â²‘â²’â²“â²”â²•â²–â²—â²˜â²™â²šâ²›â²œâ²â²žâ²Ÿâ² â²¡â²¢â²£â²¤â²¥â²¦â²§â²¨â²©â²ªâ²«â²¬â²­â²®â²¯â²°â²±
      // â²²â²³â²´â²µâ²¶â²·â²¸â²¹â²ºâ²»â²¼â²½â²¾â²¿â³€â³â³‚â³ƒâ³„â³…â³†â³‡â³ˆâ³‰â³Šâ³‹â³Œâ³â³Žâ³â³â³‘â³’â³“â³”â³•â³–â³—â³˜â³™â³šâ³›â³œâ³â³žâ³Ÿâ³ â³¡â³¢â³£â³¤â³¥â³¦â³§â³¨â³©â³ªâ³«â³¬â³­â³®â³¯â³°â³±â³²â³³â³´â³µâ³¶â³·â³¸
      // â³¹â³ºâ³»â³¼â³½â³¾â³¿â´€â´â´‚â´ƒâ´„â´…â´†â´‡â´ˆâ´‰â´Šâ´‹â´Œâ´â´Žâ´â´â´‘â´’â´“â´”â´•â´–â´—â´˜â´™â´šâ´›â´œâ´â´žâ´Ÿâ´ â´¡â´¢â´£â´¤â´¥â´¦â´§â´¨â´©â´ªâ´«â´¬â´­â´®â´¯
      // â´°â´±â´²â´³â´´â´µâ´¶â´·â´¸â´¹â´ºâ´»â´¼â´½â´¾â´¿âµ€âµâµ‚âµƒâµ„âµ…âµ†âµ‡âµˆâµ‰âµŠâµ‹âµŒâµâµŽâµâµâµ‘âµ’âµ“âµ”âµ•âµ–âµ—âµ˜âµ™âµšâµ›âµœâµâµžâµŸâµ âµ¡âµ¢âµ£âµ¤âµ¥âµ¦âµ§
      // âµ¨âµ©âµªâµ«âµ¬âµ­âµ®âµ¯âµ°âµ±âµ²âµ³âµ´âµµâµ¶âµ·âµ¸âµ¹âµºâµ»âµ¼âµ½âµ¾âµ¿â¶€â¶â¶‚â¶ƒâ¶„â¶…â¶†â¶‡â¶ˆâ¶‰â¶Šâ¶‹â¶Œâ¶â¶Žâ¶â¶â¶‘â¶’â¶“â¶”â¶•â¶–â¶—â¶˜â¶™â¶šâ¶›â¶œâ¶â¶žâ¶Ÿâ¶ â¶¡
      // â¶¢â¶£â¶¤â¶¥â¶¦â¶§â¶¨â¶©â¶ªâ¶«â¶¬â¶­â¶®â¶¯â¶°â¶±â¶²â¶³â¶´â¶µâ¶¶â¶·â¶¸â¶¹â¶ºâ¶»â¶¼â¶½â¶¾â¶¿â·€â·â·‚â·ƒâ·„â·…â·†â·‡â·ˆâ·‰â·Šâ·‹â·Œâ·
      // â·Žâ·â·â·‘â·’â·“â·”â·•â·–â·—â·˜â·™â·šâ·›â·œâ·â·žâ·Ÿâ· â·¡â·¢â·£â·¤â·¥â·¦â·§â·¨â·©â·ªâ·«â·¬â·­â·®â·¯â·°â·±â·²â·³â·´â·µâ·¶â··â·¸â·¹â·ºâ·»â·¼â·½â·¾â·¿â¸€â¸â¸‚â¸ƒâ¸„â¸…â¸†â¸‡â¸ˆâ¸‰â¸Šâ¸‹â¸Œâ¸â¸Žâ¸â¸â¸‘â¸’â¸“â¸”â¸•â¸–â¸—â¸˜â¸™â¸šâ¸›â¸œâ¸â¸žâ¸Ÿâ¸ â¸¡â¸¢â¸£â¸¤â¸¥â¸¦â¸§â¸¨â¸©â¸ªâ¸«â¸¬â¸­â¸®â¸¯â¸°â¸±â¸²â¸³â¸´â¸µâ¸¶â¸·â¸¸â¸¹â¸ºâ¸»
      // â¸¼â¸½â¸¾â¸¿â¹€â¹â¹‚â¹ƒâ¹„â¹…â¹†â¹‡â¹ˆâ¹‰â¹Šâ¹‹â¹Œâ¹â¹Žâ¹â¹â¹‘â¹’â¹“â¹”â¹•â¹–â¹—â¹˜â¹™â¹šâ¹›â¹œâ¹â¹žâ¹Ÿâ¹ â¹¡â¹¢â¹£â¹¤â¹¥â¹¦â¹§â¹¨â¹©â¹ªâ¹«â¹¬â¹­â¹®â¹¯â¹°â¹±â¹²â¹³â¹´â¹µâ¹¶â¹·â¹¸â¹¹â¹ºâ¹»â¹¼â¹½â¹¾â¹¿
      [0x3001, 0x3003],
      [0x3008, 0x3020],
      0x3030,
      [0xfd3e, 0xfd3f],
      [0xfe45, 0xfe46], // ï¹…ï¹†
  ]);
  // The following characters cannot be included in an identifier
  const IDENTIFIER_CONTINUE_PROHIBITED = expand([
      [0x0000, 0x0020],
      [0x007f, 0x009f],
      0x005c,
      0x0060,
      [0xfffe, 0xffff],
  ]);
  // The following characters cannot be the first character of an identifier
  const IDENTIFIER_START_PROHIBITED = [
      ...IDENTIFIER_CONTINUE_PROHIBITED,
      0x0021,
      0x0022,
      0x0023,
      0x0024,
      0x0025,
      0x0026,
      0x0027,
      0x0028,
      0x0029,
      0x002e,
      0x003a,
      0x003c,
      0x003f,
      0x0040,
      0x005b,
      0x005d,
      0x005e,
      0x007b,
      0x007d,
      0x007e, // TILDE: **`~`**
  ];
  // These characters in strings and identifiers may be escaped.
  //
  // Unicode characters with the White_Space property.
  // See: https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
  const WHITE_SPACE = [
      ...PATTERN_WHITE_SPACE,
      0x0000,
      0x00a0,
      0x1680,
      0x180e,
      0x2000,
      0x2001,
      0x2002,
      0x2003,
      0x2004,
      0x2005,
      0x2006,
      0x2007,
      0x2008,
      0x2009,
      0x200a,
      0x202f,
      0x205f,
      0x3000, // IDEOGRAPHIC SPACE
  ];
  // These are a set of characters that are visually confusing.
  // When used in identifiers or strings, they should be escaped.
  // See http://www.unicode.org/Public/security/revision-05/confusables.txt
  const CONFUSABLE_CHARACTERS = [
      0x07fa,
      0xfe4d,
      0xfe4e,
      0xfe4f,
      0x2010,
      0x2011,
      0x2012,
      0x2013,
      0xfe58,
      0x2043,
      0x02d7,
      0xff5e,
      0xff1a,
      0x0589,
      0x0703,
      0x0704,
      0xfe30,
      0x205a,
      0x05c3,
      0x02f8,
      0xa789,
      0x2236,
      0xa4fd,
      0x037e,
      0xff01,
      0x01c3,
      0x0294,
      0x097d,
      0x2024,
      0x06d4,
      0x0701,
      0x0702,
      0x0660,
      0x06f0,
      0x30fb,
      0xff65,
      0x0387,
      0x10101,
      0x2027,
      0xff02,
      0x201c,
      0x201d, // RIGHT DOUBLE QUOTATION MARK â†’ APOSTROPHE
  ];
  // In a string or symbol all these characters are escaped to a Unicode escape
  // sequence
  const INVISIBLE_CHARS = expand([
      ...WHITE_SPACE,
      ...CONFUSABLE_CHARACTERS,
      [0x0000, 0x001f],
      [0x007f, 0x009f],
      0x00ad,
      0x061c,
      0x180e,
      0x200b,
      0x200c,
      0x200d,
      0x200e,
      0x200f,
      0x2060,
      0x2061,
      0x2062,
      0x2063,
      0x2064,
      0x2066,
      0x2067,
      0x2068,
      0x2069,
      0x206a,
      0x206b,
      0x206c,
      0x206d,
      0x206e,
      0x206f,
      0x2800,
      [0xfdd0, 0xfdef],
      0xfeff,
      0xfffe,
      0xffff, // Non-character
  ]);
  // When escaped, these characters are escaped to the specified special escape
  // sequence
  const ESCAPED_CHARS = new Map([
      [0x0000, '\\0'],
      // [    // 0x0007,  '\\a'], // Alert
      [0x0008, '\\b'],
      [0x0009, '\\t'],
      [0x000a, '\\n'],
      // [    // 0x000b,  '\\v'], // Vertical tab
      [0x000c, '\\f'],
      [0x000d, '\\r'],
      [0x0020, ' '],
      [0x005c, '\\\\'],
      [0x0027, "\\'"],
      [0x0022, '\\"'],
  ]);
  const REVERSED_ESCAPED_CHARS = new Map([
      [0x0030, 0x0000],
      [0x005c, 0x005c],
      [0x0027, 0x0027],
      [0x022, 0x0022],
      // // [  // 'a',  0x0007],
      [0x0062, 0x0008],
      [0x0066, 0x000c],
      [0x006e, 0x000a],
      [0x0072, 0x000d],
      [0x0073, 0x0020],
      [0x0074, 0x0009], // "\t"
      // [  // 'v',  0x000b],
  ]);
  // See https://www.unicode.org/Public/UCD/latest/ucd/PropList.txt
  // Property: Hex_Digit
  const HEX_DIGITS = new Map([
      [0x0030, 0],
      [0x0031, 1],
      [0x0032, 2],
      [0x0033, 3],
      [0x0034, 4],
      [0x0035, 5],
      [0x0036, 6],
      [0x0037, 7],
      [0x0038, 8],
      [0x0039, 9],
      [0x0061, 10],
      [0x0041, 10],
      [0x0062, 11],
      [0x0042, 11],
      [0x0063, 12],
      [0x0043, 12],
      [0x0064, 13],
      [0x0044, 13],
      [0x0065, 14],
      [0x0045, 14],
      [0x0066, 15],
      [0x0046, 15],
      [0xff10, 0],
      [0xff11, 1],
      [0xff12, 2],
      [0xff13, 3],
      [0xff14, 4],
      [0xff15, 5],
      [0xff16, 6],
      [0xff17, 7],
      [0xff18, 8],
      [0xff19, 9],
      [0xff21, 10],
      [0xff22, 11],
      [0xff23, 12],
      [0xff24, 13],
      [0xff25, 14],
      [0xff26, 15],
      [0xff41, 10],
      [0xff42, 11],
      [0xff43, 12],
      [0xff44, 13],
      [0xff45, 14],
      [0xff46, 15], //FULLWIDTH LATIN SMALL LETTER F
  ]);
  // Derived from HEX_DIGITS
  // (there isn't a Unicode property for decimal digits, but
  // there is one for hex digits)
  const DIGITS = new Map([
      [0x0030, 0],
      [0x0031, 1],
      [0x0032, 2],
      [0x0033, 3],
      [0x0034, 4],
      [0x0035, 5],
      [0x0036, 6],
      [0x0037, 7],
      [0x0038, 8],
      [0x0039, 9],
      [0xff10, 0],
      [0xff11, 1],
      [0xff12, 2],
      [0xff13, 3],
      [0xff14, 4],
      [0xff15, 5],
      [0xff16, 6],
      [0xff17, 7],
      [0xff18, 8],
      [0xff19, 9],
  ]);
  const FANCY_UNICODE = new Map([
      //   0x00ab: '<<',
      [0x00ac, '!'],
      [0x00b1, '+-'],
      [0x2213, '-+'],
      [0x00d7, '*'],
      [0x00f7, '/'],
      [0x2215, '/'],
      [0x2024, '.'],
      [0x2025, '..'],
      [0x2026, '...'],
      [0x2027, '.'],
      [0x2032, "'"],
      [0x2033, "''"],
      [0x2034, "'''"],
      [0x2042, '***'],
      [0x2044, '/'],
      [0x2047, '??'],
      [0x2048, '?!'],
      [0x2049, '!?'],
      [0x204e, '*'],
      [0x2051, '**'],
      [0x2056, '...'],
      [0x2059, '.....'],
      [0x205a, ':'],
      [0x205b, '.:.'],
      [0x2062, '*'],
      [0x2064, '+'],
      [0x03c0, 'Pi'],
      [0x203c, '!!'],
      [0x2148, 'ImaginaryUnit'],
      [0x2147, 'ExponentialE'],
      [0x2102, 'ComplexNumber'],
      [0x211d, 'RealNumber'],
      [0x2115, 'NaturalNumber'],
      [0x2124, 'Integer'],
      [0x211a, 'RationalNumber'],
      [0x2190, '<-'],
      [0x2192, '->'],
      [0x2194, '<->'],
      // [     0x21A4,  '<-|'],
      [0x21a6, '|->'],
      [0x21d0, '=>'],
      [0x21d4, '<=>'],
      [0x2205, 'EmptySet'],
      [0x221e, 'Infinity'],
      [0x29dd, 'ComplexInfinity'],
      [0x2212, '-'],
      [0x2218, '.'],
      // [    0x22bb,  'Xor'], // âŠ»
      [0x22c0, '&&'],
      [0x22c1, '||'],
      [0x2227, '&&'],
      [0x2228, '||'],
      // [  0x2254,  ':='], // COLON EQUALS
      // [  0x2255,  '=:'], // EQUALS COLON
      [0x2237, '::'],
      [0x2260, '!='],
      [0x2261, '=='],
      [0x2262, '!=='],
      [0x2263, '==='],
      [0x2a7d, '<='],
      [0x2a7e, '>='],
      [0x2264, '<='],
      [0x2265, '>='],
      [0x2266, '<='],
      [0x2267, '>='],
      [0x226a, '<<'],
      [0x226b, '>>'],
      [0x25b7, '|>'],
      [0x25c1, '<|'],
      [0x29d0, '||>'],
      [0x29cf, '<||'],
      [0x21dd, '~>'],
      [0x21dc, '<~'],
      //
      // Perl/Raku support a collection of infix operators
      //
      [0x2208, 'in'],
      [0x2209, '!in'],
      // 0x220B,	// âˆ‹	(cont)
      // 0x220C, //  âˆŒ	!(cont)
      // 0x2286, // âŠ†		(<=)
      // 0x2288, // âŠˆ		!(<=)
      // 0x2282, // âŠ‚		(<)
      // 0x2284, //âŠ„		!(<)
      // 0x2287, // âŠ‡		(>=)
      // 0x2289, //âŠ‰		!(>=)
      // 0x2283, // âŠƒ		(>)
      // 0x2285, // âŠ…		!(>)
      // 0x222A, //âˆª		(|)
      // 0x2229, // âˆ©		(&)
      // 0x2216, // âˆ–		(-) SetMinus
      // 0x2296, // âŠ–		(^)
      // 0x228D, // âŠ		(.)
      // 0x228E, //	(+)
      [0x2a75, '=='],
      [0x2a76, '==='],
      [0x2400, '\\0'],
      [0x2408, '\\b'],
      [0x2409, '\\t'],
      [0x240a, '\\n'],
      [0x2424, '\\n'],
      [0x240d, '\\r'], // SYMBOL FOR CARRIAGE RETURN â
  ]);
  reverse(FANCY_UNICODE);
  /**
   * Build the reverse fancy Unicode table from the FANCY_UNICODE table
   */
  function reverse(table) {
      const result = new Map();
      for (const [k, v] of Object.entries(table)) {
          if (result.has(v)) {
              const ks = result.get(v);
              ks.push(parseInt(k));
              result.set(v, ks);
          }
          else {
              result.set(v, [parseInt(k)]);
          }
      }
      return result;
  }
  function expand(source) {
      const result = [];
      for (const entry of source) {
          if (typeof entry === 'number') {
              result.push(entry);
          }
          else {
              for (let i = entry[0]; i <= entry[1]; i++) {
                  result.push(i);
              }
          }
      }
      return result;
  }
  function isLinebreak(c) {
      return LINEBREAK_CHARACTER.includes(c);
  }
  /** Most restrictive whitespace only TAB or SPACE */
  function isInlineSpace(c) {
      return c === 0x0009 || c === 0x0020;
  }
  /** Everything in pattern white space, plus some other
   * characters considered whitespace */
  function isWhitespace(c) {
      return WHITE_SPACE.includes(c);
  }
  /** A 'break' character is an whitespace, operator, punctuation, bracket, etc..
   * It indicates the end of an identifier (or number).
   */
  function isBreak(c) {
      return WHITE_SPACE.includes(c) || PATTERN_SYNTAX.includes(c);
  }
  function isIdentifierContinueProhibited(c) {
      return IDENTIFIER_CONTINUE_PROHIBITED.includes(c);
  }
  function isIdentifierStartProhibited(c) {
      return IDENTIFIER_START_PROHIBITED.includes(c);
  }
  function isInvisible(c) {
      return INVISIBLE_CHARS.includes(c);
  }
  function codePointLength(code) {
      console.assert(String.fromCodePoint(code).length === (code > 0xffff ? 2 : 1));
      return code > 0xffff ? 2 : 1;
  }

  /**
   * The parser will attempt to continue parsing even when an error is
   * encountered.
   *
   * However, in the rare cases where parsing cannot proceed, this
   * error will be thrown.
   *
   * This would happen if a `#error` directive is encountered.
   */
  class FatalParsingError extends Error {
      constructor(msg) {
          super();
          this.message = msg;
      }
  }
  /**
   * The `Parser` keeps track of what we are parsing (the source) and what we have
   * parsed so far (the offset).
   */
  class Parser {
      constructor(rules, source, url) {
          this._offset = 0;
          this.length = 0;
          this.rules = rules;
          this.source = source;
          this.url = url;
          this.length = source.length;
          this._trace = [];
      }
      get(offset) {
          return this.source.codePointAt(offset);
      }
      atEnd() {
          return this.offset >= this.source.length;
      }
      atLinebreak() {
          return isLinebreak(this.source.codePointAt(this.offset));
      }
      atString(s) {
          let i = 0;
          let match = true;
          const start = this.offset;
          while (match && i < s.length && i < this.source.length) {
              match = this.get(start + i) === s.codePointAt(i);
              i += 1;
          }
          return match;
      }
      slice(start, end) {
          return this.source.slice(start, end);
      }
      get offset() {
          return this._offset;
      }
      trace(rule) {
          return [
              ...this._trace,
              typeof rule === 'string'
                  ? rule
                  : typeof rule === 'function'
                      ? '???'
                      : rule[0],
          ];
      }
      skipTo(offset) {
          this._offset = offset;
          return this;
      }
      fatalError(msg) {
          throw new FatalParsingError(msg);
      }
      hasRule(rule) {
          return this.rules.has(rule);
      }
      parse(rule, fromOffset) {
          this._trace.push(typeof rule === 'string'
              ? rule
              : typeof rule === 'function'
                  ? '???'
                  : rule[0]);
          if (fromOffset !== undefined)
              this.skipTo(fromOffset);
          let result;
          if (typeof rule === 'string')
              result = this.rules.parse(rule, this);
          else if (typeof rule === 'function')
              result = rule(this);
          else
              result = rule[1](this);
          this._trace.pop();
          return result;
      }
      parseWhitespace() {
          if (!this.hasRule('whitespace'))
              return this.ignore();
          return this.parse('whitespace');
      }
      ignore() {
          const result = new Result(this);
          return result.ignore();
      }
      failure() {
          const result = new Result(this);
          return result.failure();
      }
  }
  /**
   * The result of applying a parsing rule:
   * - `Ignore`: the rule matched and the result can be ignored
   * - `Failure`: the rule did not match at all. Maybe try something else?
   * - `Success`: the rule matched and generated a value that can be passed on.
   * - `Error`: the rule matched, then something went wrong. Probably a
   * syntax error. It still produced a value so the parsing can attempt to
   * recover and continue (Panic Mode).
   */
  class Result {
      constructor(parser) {
          this._parser = parser;
          this._range = [parser.offset, parser.offset];
      }
      copyDiagnostics(from) {
          if (!from.isError)
              return;
          if (this._diagnostics === undefined)
              this._diagnostics = [];
          if (from._diagnostics) {
              this._diagnostics = [...this._diagnostics, ...from._diagnostics];
          }
      }
      get parser() {
          return this._parser;
      }
      get diagnostics() {
          var _a;
          return (_a = this._diagnostics) !== null && _a !== void 0 ? _a : [];
      }
      get isFailure() {
          return this._diagnostics === undefined && this._value === undefined;
      }
      get isEmpty() {
          return this._diagnostics === undefined && this._value === null;
      }
      get isSuccess() {
          return (this._diagnostics === undefined &&
              this._value !== undefined &&
              this._value !== null);
      }
      get isError() {
          return this._diagnostics !== undefined;
      }
      get start() {
          return this._range[0];
      }
      get end() {
          return this._range[1];
      }
      set end(val) {
          this._range[1] = val;
      }
      set range(val) {
          this._range = val;
      }
      get value() {
          return this._value;
      }
      set value(val) {
          this._value = val;
      }
      /**
       * Use when a portion of the source has been successfully parsed.
       */
      success(val) {
          this._value = val;
          this._range[1] = this._parser.offset - 1;
          return this;
      }
      // successAt(val: IR, offset: number): Result<IR> {
      //   this._value = val;
      //   this._parser.skipTo(offset);
      //   this._range[1] = offset - 1;
      //   return this;
      // }
      /**
       * A `failure` indicates a failed attempt to parse, with no presumption
       * of success, for example when exploring multiple alternatives.
       *
       * `state` indicate where to restart parsing from.
       *
       * The `error` includes the origin (offset) of the failure. It could be after
       * the `state`.
       *
       */
      failure() {
          this._parser.skipTo(this._range[0]);
          return this;
      }
      /**
       * An `ignore` result indicates success in parsing, but with a result that
       * can be ignored.
       *
       * This is useful for whitespace, keywords, braces and other similar syntactic
       * constructs.
       *
       * `next` is the offset from which parsing can continue.
       * `start` is the offset in the source where the element was first ignored.
       *
       */
      ignore() {
          this._value = null;
          return this;
      }
      ignoreUntil(offset) {
          this._parser.skipTo(offset);
          this._range[1] = this._parser.offset;
          this._value = null;
          return this;
      }
      /**
       * An `error` is used when an unexpected failure was encountered.
       * It typically indicates a syntax error.
       *
       * Nonetheless, an attempt is made to recover.
       *
       * The range indicate the portion of the source covered by this result.
       * The optional `pos` indicate where the error occurred. It's the `end`
       * by default.
       *
       */
      error(value, msg, fixits) {
          this._value = value;
          this._range[1] = this._parser.offset - 1;
          if (!this._diagnostics)
              this._diagnostics = [];
          this._diagnostics.push({
              severity: 'error',
              range: [this._range[0], this._range[1]],
              message: typeof msg === 'function' ? msg(this) : msg,
              fixits,
          });
          return this;
      }
      errorAt(value, msg, pos, fixits) {
          this._value = value;
          this._range[1] = this._parser.offset - 1;
          if (!this._diagnostics)
              this._diagnostics = [];
          this._diagnostics.push({
              severity: 'error',
              range: [this._range[0], this._range[1], pos],
              message: typeof msg === 'function' ? msg(this) : msg,
              fixits,
          });
          return this;
      }
      errorFrom(result, value) {
          this._value = value;
          this._range[1] = this._parser.offset - 1;
          if (!this._diagnostics)
              this._diagnostics = [];
          if (result._diagnostics) {
              this._diagnostics = [...this._diagnostics, ...result._diagnostics];
          }
          return this;
      }
      warning(msg, fixits) {
          this._range[1] = this._parser.offset - 1;
          if (!this._diagnostics)
              this._diagnostics = [];
          this._diagnostics.push({
              severity: 'warning',
              range: [this._range[0], this._range[1]],
              message: msg,
              fixits,
          });
          return this;
      }
  }
  function skipUntilString(parser, pattern) {
      let i = parser.offset;
      const cps = [...pattern].map((x) => x.codePointAt(0));
      while (i < pattern.length - cps.length) {
          let c = parser.get(i);
          if (c === cps[0]) {
              let match = true;
              let j = 1;
              while (match && j < cps.length) {
                  c = parser.get(i);
                  match = c === cps[j];
                  if (match) {
                      j += 1;
                      i += codePointLength(c);
                  }
              }
              if (match)
                  return i;
          }
          i += codePointLength(c);
      }
      return -1;
  }

  function description(c) {
      if (typeof c === 'string')
          return c;
      return c[0];
  }
  function parseCodepoint(parser, value) {
      const result = new Result(parser);
      const start = parser.offset;
      if (parser.get(start) !== value)
          result.failure();
      parser.skipTo(start + codePointLength(value));
      return result.success(String.fromCodePoint(value));
  }
  function codepoint(value) {
      return [
          `U+${('0000' + value.toString(16)).slice(-4)} (${String.fromCodePoint(value)})`,
          (parser) => parseCodepoint(parser, value),
      ];
  }
  /**
   * Apply a function to one or more results.
   *
   * Similar to an _action_ with YACC/Bison.
   *
   * Compute the semantic value of the whole construct from the semantic
   * values of its parts.
   */
  // export function map<T = string, IR>(
  //   f: (result: T) => IR,
  //   ...results: Result<T>[]
  // ): IR[] {
  //   return results.map((x) => {
  //     if (x.isFailure || x.isIgnore) return x;
  //     return { ...x, value: f(x.value) };
  //   });
  // }
  /**
   *
   * Combine one or more results into a single result using the `f()` function.
   *
   * Keep all the diagnostics (if any of the results has an error, the overall
   * result is an error).
   * If there are no results, the result is empty (not a failure).
   */
  function combine(parser, f, results, errors, msg) {
      const result = new Result(parser);
      let maxOffset = 0;
      let minOffset = Infinity;
      // Get all the values
      for (const res of results) {
          result.copyDiagnostics(res);
          if (res.isSuccess || res.isError) {
              maxOffset = Math.max(maxOffset, res.end);
              minOffset = Math.min(minOffset, res.end);
          }
      }
      result.range = [minOffset, maxOffset];
      // If we haven't captured any values, return an empty result (`value === null`)
      result.value = results.length > 0 ? f(...results) : null;
      if (msg)
          result.error(result.value, msg);
      if (errors)
          for (const err of errors)
              result.copyDiagnostics(err);
      return result;
  }
  // export function accept<S>(value: S, error?: DiagnosticMessage): Combinator<S> {}
  // export function acceptIf<S>(
  //   value: S,
  //   p: (value: S) => boolean,
  //   error?: DiagnosticMessage
  // ): Combinator<S> {}
  function parseString(parser, value) {
      const result = new Result(parser);
      let i = 0;
      let match = true;
      const start = parser.offset;
      while (i < value.length && match && i < parser.length) {
          match = parser.get(start + i) === value.codePointAt(i);
          i++;
      }
      if (match && i === value.length) {
          parser.skipTo(parser.offset + i);
          result.success(value);
      }
      return result;
  }
  /** Combinator for a sequence of one or more characters */
  function literal(value) {
      console.assert(value.length > 0);
      //
      // Special case when value is a single character
      //
      if (value.length === 1)
          return codepoint(value.codePointAt(0));
      //
      // General case: value is more than a single char
      //
      return [`**\`${value}\`**`, (parser) => parseString(parser, value)];
  }
  /**
   * Generator for an ordered, non-empty, sequence of elements separated
   * by whitespace.
   *
   * If the first one fails, the sequence fails (softly).
   * After the first one, if a generator fails, the sequence returns an
   * error.
   */
  function sequence(cs, f) {
      return [
          cs.map((x) => description(x)).join(' '),
          (parser) => {
              const results = [];
              const whitespaces = [];
              let isFirst = true;
              whitespaces.push(parser.parseWhitespace());
              for (const c of cs) {
                  const pos = parser.offset;
                  const res = parser.parse(c);
                  results.push(res);
                  // If this is the first element, return a failure.
                  if (res.isFailure && isFirst)
                      return res;
                  if (res.isFailure) {
                      // We got a failure later in the sequence,
                      // the whole sequence is in error
                      return combine(parser, f, results, whitespaces, [
                          'unexpected-symbol',
                          String.fromCodePoint(parser.get(pos)),
                          parser.trace(c),
                      ]);
                  }
                  isFirst = false;
                  whitespaces.push(parser.parseWhitespace());
              }
              return combine(parser, f, results, whitespaces);
          },
      ];
  }
  /**
   * Explore multiple alternatives.
   * Select the first one that matches.
   *
   */
  function either(cs, f) {
      return [
          cs.map((x) => description(x)).join(' | '),
          (parser) => {
              // Pick the first alternative that succeeds
              const start = parser.offset;
              let error;
              for (const c of cs) {
                  parser.skipTo(start);
                  const result = parser.parse(c);
                  if (f && (result.isSuccess || result.isError)) {
                      result.value = f(result);
                  }
                  if (result.isSuccess)
                      return result;
                  if (!error && result.isError)
                      error = result;
              }
              if (error) {
                  parser.skipTo(error.end + 1);
                  return error;
              }
              // No alternative succeeded
              parser.skipTo(start);
              return parser.failure();
          },
      ];
  }
  /**
   * 0 or more `something`.
   *
   * The parser of this combinator will never fail (since Ã¸ is an acceptable match).
   * If there are 0 something, the parser will return an Ignore result.
   */
  function some(something, f) {
      return [
          `(${description(something)})*`,
          (parser) => {
              const whitespaces = [parser.parseWhitespace()];
              let res = parser.parse(something);
              const results = [res];
              while (!parser.atEnd() && (res.isSuccess || res.isEmpty)) {
                  whitespaces.push(parser.parseWhitespace());
                  res = parser.parse(something);
                  results.push(res);
              }
              return combine(parser, f, results, whitespaces);
          },
      ];
  }
  /**
   *  Succeeds even if `something` fails
   */
  function maybe(something) {
      return [
          `\\[${description(something)}\\]`,
          (parser) => {
              const start = parser.offset;
              const result = parser.parse(something);
              if (result.isSuccess || result.isEmpty)
                  return result;
              if (result.isFailure) {
                  parser.skipTo(start);
                  return parser.ignore();
              }
              return result;
          },
      ];
  }
  /**
   * Return an error if `something` is a failure
   */
  function must(something, inMsg) {
      return [
          `(${description(something)})!`,
          (parser) => {
              const result = parser.parse(something);
              if (result.isSuccess || result.isEmpty || result.isError)
                  return result;
              // We could not process the next character, skip it and try to continue
              let retryCount = 5;
              const pos = parser.offset; // Position of where the unexpected error occurred
              let msg = inMsg;
              if (!msg) {
                  msg = parser.atEnd()
                      ? ['expression-expected']
                      : [
                          'unexpected-symbol',
                          String.fromCodePoint(parser.get(pos)),
                          parser.trace(something),
                      ];
              }
              while (retryCount > 0 && !parser.atEnd()) {
                  parser.skipTo(parser.offset + 1);
                  const res = parser.parse(something);
                  if (res.isSuccess || res.isEmpty) {
                      result.errorAt(res.value, msg, pos);
                      result.copyDiagnostics(res);
                      return result;
                  }
                  retryCount -= 1;
              }
              return result.errorAt(result.value, msg, pos);
          },
      ];
  }
  // export function ignore(something: string | Combinator): Combinator {
  //   return [
  //     `\\[${description(something)}\\]!`,
  //     (parser: Parser): Result<any> => parser.parse(something).ignore(),
  //   ];
  // }
  function eof() {
      return [
          '_eof_',
          (parser) => {
              const result = new Result(parser);
              return parser.atEnd() ? result.success(true) : result.failure();
          },
      ];
  }

  // import { REVERSE_FANCY_UNICODE } from './characters';
  // function any<T>(
  //   seq: Combinator[],
  //   map: (result: Result<T>[]) => Result<T>
  // ): Combinator<T> {}
  // function manySeparated<T>(
  //   sep: string,
  //   map: (result: Result<T>[]) => Result<T>
  // ): Combinator<T> {}
  /**
   * An element bracketed by open and close delimiters.
   *
   */
  function between(open, something, close) {
      // @todo: could have a specialized version for when open and close
      // are single chars
      return [
          `**\`${open}\`** (${description(something)})* **\`${close}\`**`,
          (parser) => {
              const result = new Result(parser);
              if (!parser.atString(open))
                  return result.failure();
              const start = parser.offset;
              parser.skipTo(start + open.length);
              const res = parser.parse(something);
              if (res.isError) {
                  result.copyDiagnostics(res);
                  result.range = [result.start, skipUntilString(parser, close)];
                  return result;
              }
              if (!parser.atString(close)) {
                  return result.error(res.value, ['closing-bracket-expected', close]);
              }
              parser.skipTo(parser.offset + close.length);
              result.value = res.value;
              return result;
          },
      ];
  }
  // export function maybeWhitespaceAround(
  //   something: string | Combinator<string>,
  //   msg?: SignalCode
  // ): Combinator<string> {
  //   // @todo: could have a version that specializes for when something
  //   // is a string.
  //   const combinator = normalize(something);
  //   return (initialState: ParserState): Result<string> => {
  //     let state = skipWhitespace(initialState);
  //     const result = combinator(state);
  //     if (result.kind !== 'success') {
  //       return failure(initialState, state.offset, msg);
  //     }
  //     state = skipWhitespace(result.state);
  //     return success(initialState, state.offset, result.value);
  //   };
  // }
  function manySeparatedBetween(open, something, separator, close, f) {
      return [
          `**\`${open}\`** (${description(something)}+#**\`${separator}\`** **\`${close}\`**`,
          (parser) => {
              const result = new Result(parser);
              if (!parser.parse(literal(open)).isSuccess)
                  return result.failure();
              const values = [];
              let done = false;
              while (!done && !parser.atEnd()) {
                  const res = parser.parse(something);
                  result.copyDiagnostics(res);
                  done = !res.isSuccess;
                  if (!done) {
                      values.push(res);
                      done = !parser.parse(literal(separator)).isSuccess;
                  }
              }
              if (values.length === 0) {
                  return result.error(f([]), 'expression-expected');
              }
              if (!parser.parse(literal(close)).isSuccess) {
                  return result.error(f(values), ['closing-bracket-expected', close]);
              }
              return result.success(f(values));
          },
      ];
  }
  /**
   * Return the ops sorted by length of the symbol so that,
   * e.g. '<<-' is before '<-'
   */
  // function sortedOps<U>(ops: OpsTable<U>): OpsTable<U> {
  //   return [...ops].sort((a: OpRecord<U>, b: OpRecord<U>): number => {
  //     if (a[1].length === b[1].length) {
  //       if (a[1] === b[1]) {
  //         return b[2] - a[2];
  //       }
  //       return b[1] < a[1] ? -1 : +1;
  //     }
  //     return b[1].length - a[1].length;
  //   });
  // }
  /**
   * A sequence of prefix, infix and suffix operators with `term`
   * operands.
   *
   * The `f` mapping function is called according to the specified
   * precedence info in the `OpsTable`
   */
  function operatorSequence(ops, term, f) {
      const termDesc = description(term);
      return [
          ops
              .map((x) => {
              var _a;
              const [_data, op, prec] = x;
              const assoc = (_a = x[3]) !== null && _a !== void 0 ? _a : 'right';
              if (assoc === 'prefix') {
                  return `**\`${op}\`**<sub>${prec}</sub> ${termDesc}`;
              }
              else if (assoc === 'suffix') {
                  return `${termDesc} **\`${op}\`**<sub>${prec}</sub>`;
              }
              else if (assoc === 'left') {
                  return `_Â·Â·Â·_ **\`${op}\`**<sub>${prec}L</sub> ${termDesc}`;
              }
              return `${termDesc} **\`${op}\`**<sub>${prec}R</sub> _Â·Â·Â·_`;
          })
              .join(' | '),
          (parser) => parseWithPrecedence(parser, ops, term),
      ];
  }
  // function prefixOps<U>(ops: OpsTable<U>, minPrec: number): OpsTable<U> {
  //   return ops.filter((x) => {
  //     const [_data, _op, prec, assoc] = x;
  //     return prec >= minPrec && assoc === 'prefix';
  //   });
  // }
  // function suffixOps<U>(ops: OpsTable<U>, minPrec: number): OpsTable<U> {
  //   return ops.filter((x) => {
  //     const [_data, _op, prec, assoc] = x;
  //     return prec >= minPrec && assoc === 'suffix';
  //   });
  // }
  // function infixOps<U>(ops: OpsTable<U>, minPrec: number): OpsTable<U> {
  //   return ops.filter((x) => {
  //     const [_data, _op, prec, assoc] = x;
  //     return prec >= minPrec && assoc !== 'suffix' && assoc !== 'prefix';
  //   });
  // }
  // function parseOp<T, U>(parser: Parser, ops: OpsTable<U>): OpRecord<U> {
  //   for (const opRecord of ops) {
  //     const [_data, op, _precedence, _assoc] = opRecord;
  //     if (parser.atString(op)) {
  //       parser.skipTo(parser.offset + op.length);
  //       return opRecord;
  //     }
  //     if (
  //       REVERSE_FANCY_UNICODE.has(op) &&
  //       REVERSE_FANCY_UNICODE.get(op).includes(parser.get(parser.offset))
  //     ) {
  //       parser.skipTo(parser.offset + 1);
  //       return opRecord;
  //     }
  //   }
  //   return [undefined, undefined, undefined, undefined];
  // }
  // if (prec < minPrec) return null;
  // prec += def.associativity === 'left' ? 1 : 0;
  function parseWithPrecedence(parser, ops, term, _f) {
      return parser.parse(term);
      // const result = new Result<IR>(parser);
      // const start = parser.offset;
      // //
      // // Shunting-yard algorithm
      // //
      // // Start off with an empty output stream and an empty stack.
      // const opStack = [];
      // const operandStack = [];
      // let lhs: IR;
      // ops = sortedOps(infixOps(ops, 0));
      // // Repeatedly read a symbol from the input.
      // while (true) {
      //   // 1. Is is an operand?
      //   // If it is part of a number (i.e., a digit or a decimal separator),
      //   //      then keep reading tokens until an operand or parenthesis is encountered,
      //   //       and convert the entire string just read into a number,
      //   //      and transfer the number to the output stream.
      //   // parseOperand() = one or more infix, a term, one or more postfix
      //   if (false) {
      //     // push on output stream (= lhs)
      //   } else {
      //     const [data, op, precedecence, assoc] = parseOp(parser, ops);
      //     if (!op) break;
      //     console.assert(opStack.length > 0);
      //     // 2. Is it a left-associative infix operator?
      //     if (assoc === 'left') {
      //       // If it is a left-associative operator,
      //       //      then repeatedly pop from the stack into the output stream
      //       //      until either the stack becomes empty
      //       //      or the top of the stack is a parenthesis
      //       //      or a lower-precedence operator.
      //       //      After that, push it onto the stack.
      //     }
      //     // 3. Is it a right-associative infix operator?
      //     if (assoc === 'right') {
      //       // If it is a right-associative operator,
      //       //      then repeatedly pop from the stack into the output stream
      //       //      until either the stack becomes empty
      //       //      or the top of the stack is a parenthesis
      //       //      or an operator of lower or equal precedence.
      //       //      After that, push it onto the stack.
      //     }
      //     // If it is an opening parenthesis,
      //     //      push it onto the stack.
      //     // If it is a closing parenthesis,
      //     //      repeatedly pop operators from the stack into the output stream until an opening parenthesis is encountered. Pop the opening parenthesis off the stack, but do not emit it into the output stream.
      //   }
      // }
      // return result.success(lhs);
  }
  // function parseWithPrecedence<T, U>(
  //   parser: Parser<T>,
  //   ops: OpsTable<U>,
  //   term: string | Combinator<T>,
  //   f: (op: U, lhs?: T, rhs?: T) => T,
  //   minPrec: number
  // ): Result<T> {
  //   //
  //   // 1. Parse a prefix operator
  //   //
  //   const result = parsePrefixOp(parser, ops, term, f, minPrec);
  //   if (! result.isFailure) return result;
  //   //
  //   // 2. Parse an infix operator
  //   //
  //   const lhs = parseInfixOp(parser, ops, term, f, minPrec);
  //   //
  //   // 3. Parse a suffix operator
  //   //
  //   return lhs;
  // }
  /**
   * Parse a prefix operator
   */
  // function parsePrefixOp<T, U>(
  //   parser: Parser<T>,
  //   ops: OpsTable<U>,
  //   term: string | Combinator<T>,
  //   f: (op: U, lhs?: T, rhs?: T) => T,
  //   minPrec: number
  // ): Result<T> {
  //   const start = parser.offset;
  //   const prefix = prefixOps(ops, minPrec);
  //   // eslint-disable-next-line @typescript-eslint/no-unused-vars
  //   // eslint-disable-next-line prefer-const
  //   const opRecord = parseOp(parser, prefix);
  //   if (!opRecord[1]) return parser.failure();
  //   // We've found an eligible prefix operator.
  //   parser.skipTo(parser.offset + opRecord[1].length);
  //   const whitespace = parseWhitespace(parser);
  //   if (
  //     whitespace.isError ||
  //     (whitespace.isIgnore && whitespace.next !== whitespace.start)
  //   ) {
  //     // There was some whitespace after the operator:
  //     // it's not a prefix operator.
  //     parser.skipTo(start);
  //     return parser.failure();
  //   }
  //   // It *is* a prefix operator...
  //   // const rhs = parser.parse(term);
  //   const rhs = parseWithPrecedence<T, U>(parser, ops, term, f, opRecord[2]);
  //   if (rhs.kind !== 'success') return rhs;
  //   return parser.success(
  //     [start, parser.offset],
  //     f(opRecord[0], undefined, rhs.value)
  //   );
  // }
  // /**
  //  * Parse an infix operator
  //  */
  // function parseInfixOp<T, U>(
  //   parser: Parser<T>,
  //   ops: OpsTable<U>,
  //   term: string | Combinator<T>,
  //   f: (op: U, lhs?: T, rhs?: T) => T,
  //   minPrec: number
  // ): Result<T> {
  //   const start = parser.offset;
  //   const lhs = parser.parse(term);
  //   // const lhs = parseWithPrecedence<T, U>(
  //   //   parser,
  //   //   infixOps(ops, minPrec + 1),
  //   //   term,
  //   //   f,
  //   //   minPrec
  //   // );
  //   if (lhs.value === undefined || lhs.value === null) return lhs;
  //   const offsetAfterLhs = parser.offset;
  //   let whitespace = parseWhitespace(parser);
  //   const hasLeadingWhitespace = whitespace.value === null;
  //   const opRecord = matchOp(parser, infixOps(ops, minPrec + 1));
  //   if (!opRecord[1]) return lhs;
  //   // We've found an eligible infix operator.
  //   parser.skipTo(parser.offset + opRecord[1].length);
  //   whitespace = parseWhitespace(parser);
  //   if (
  //     (!hasLeadingWhitespace || whitespace.value === null) &&
  //     (hasLeadingWhitespace || whitespace.value === null)
  //   ) {
  //     // There was some whitespace before or after, but not both.
  //     // It's not an infix operator (might be a prefix).
  //     // e.g. in `2 + -3`, the '-' is not an infix.
  //     parser.skipTo(offsetAfterLhs);
  //     return lhs;
  //   }
  //   // It *is* an infix operator...
  //   // const rhs = parser.parse(term);
  //   const rhs = parseWithPrecedence<T, U>(parser, ops, term, f, opRecord[2]);
  //   if (rhs.kind !== 'success') return rhs;
  //   return parser.result(
  //     [start, parser.offset],
  //     f(opRecord[0], lhs.value, rhs.value),
  //     [...(lhs.errors ?? []), ...(rhs.errors ?? [])]
  //   );
  // }

  // @todo: the numeric parsers should return strings rather than
  // number to better support big numbers
  function parseExponent(parser, prefix) {
      const result = new Result(parser);
      const start = parser.offset;
      let i = start;
      if (i >= parser.length)
          return result.failure();
      if (prefix === 'p') {
          if (parser.get(i) !== 0x0070 && parser.get(i) !== 0x0050)
              return result.failure();
      }
      else {
          // Prefix 'e' or 'E'
          if (parser.get(i) !== 0x0065 && parser.get(i) !== 0x0045)
              return result.failure();
      }
      i += 1;
      let sign = 1;
      // Is it the minus sign (-)
      if (parser.get(i) === 0x002d) {
          i++;
          sign = -1;
      }
      else if (parser.get(i) === 0x002b) {
          // It's the plus sign (+)
          i++;
      }
      if (parser.offset !== i && !DIGITS.has(parser.get(i))) {
          // There was a '+' or '-' followed by a non-digit
          parser.skipTo(i);
          return result.error(0, 'exponent-expected');
      }
      let value = 0;
      while (DIGITS.has(parser.get(i))) {
          value = value * 10 + DIGITS.get(parser.get(i++));
      }
      parser.skipTo(i);
      return result.success(sign * value);
  }
  function applyExponent(parser, start, value) {
      const result = new Result(parser);
      let exp = parseExponent(parser, 'e');
      if (exp.isSuccess) {
          // Note: using "Math.pow" loses some accuracy, i.e.:
          // `0.1e-4 = 0.000009999999999999999`
          // Instead, use the Javascript parsing function
          // result = result * Math.pow(10, exp.value);
          value = Number.parseFloat(value.toString() + 'e' + exp.value.toString());
      }
      else if (exp.isFailure) {
          exp = parseExponent(parser, 'p');
          if (exp.isSuccess) {
              value = value * Math.pow(2, exp.value);
          }
      }
      if (exp.isSuccess || exp.isFailure)
          return result.success(value);
      return result.error(value, 'exponent-expected');
  }
  function parseBinaryNumber(parser) {
      const result = new Result(parser);
      const start = parser.offset;
      let i = start;
      // `0b` prefix
      if (parser.get(i++) !== 0x0030 || parser.get(i++) !== 0x0062) {
          return result.failure();
      }
      // Whole part
      let value = 0;
      let done = false;
      while (!done && i < parser.length) {
          const c = HEX_DIGITS.get(parser.get(i++));
          if (c === 0) {
              value = value << 1;
          }
          else if (c === 1) {
              value = (value << 1) + 1;
          }
          else if (parser.get(i - 1) === 0x005f) ;
          else {
              done = true;
              i -= 1;
          }
      }
      // Fractional part. Check for '.'
      if (parser.get(i) === 0x002e) {
          i += 1;
          let frac = 0.5;
          let fracPart = 0;
          done = false;
          while (!done && i < parser.length) {
              const c = HEX_DIGITS.get(parser.get(i++));
              if (c === 0) {
                  frac = frac / 2;
              }
              else if (c === 1) {
                  fracPart += frac;
                  frac = frac / 2;
              }
              else if (parser.get(i - 1) === 0x005f) ;
              else {
                  done = true;
                  i -= 1;
              }
          }
          value += fracPart;
      }
      // Exponent
      parser.skipTo(i);
      return applyExponent(parser, start, value);
  }
  function parseHexadecimalNumber(parser) {
      const result = new Result(parser);
      const start = parser.offset;
      let i = start;
      // `0x` prefix
      if (parser.get(i++) !== 0x0030 || parser.get(i++) !== 0x0078) {
          return result.failure();
      }
      // Whole part
      let value = 0;
      let done = false;
      while (!done && i < parser.length) {
          const c = parser.get(i++);
          if (HEX_DIGITS.has(c)) {
              value = value * 16 + HEX_DIGITS.get(c);
          }
          else if (c !== 0x005f) {
              // If it's neither a digit nor a "_" separator, we're done
              done = true;
              i -= 1;
          }
      }
      // Fractional part
      if (parser.get(i++) === 0x002e) {
          let frac = 0.0625; // 1/16
          done = false;
          let fracPart = 0;
          while (!done && i < parser.length) {
              const c = parser.get(i++);
              if (HEX_DIGITS.has(c)) {
                  fracPart += frac * HEX_DIGITS.get(c);
                  frac = frac / 16;
              }
              else if (c !== 0x005f) {
                  // If it's neither a digit nor a "_" separator, we're done
                  done = true;
                  i -= 1;
              }
              else {
                  parser.skipTo(i);
                  return result.error(value + fracPart, 'hexadecimal-number-expected');
              }
          }
          value += fracPart;
      }
      // Exponent
      parser.skipTo(i);
      return applyExponent(parser, start, value);
  }
  function parseFloatingPointNumber(parser) {
      const result = new Result(parser);
      const start = parser.offset;
      if (!DIGITS.has(parser.get(start)))
          return result.failure();
      let i = start;
      // Whole part
      let value = 0;
      let done = false;
      while (!done && i < parser.length) {
          const c = parser.get(i++);
          if (DIGITS.has(c)) {
              value = value * 10 + DIGITS.get(c);
          }
          else if (c !== 0x005f) {
              // If it's neither a digit nor a "_" separator, we're done
              done = true;
              i -= 1;
          }
      }
      // Fractional part
      if (parser.get(i) === 0x002e) {
          i += 1;
          let frac = 0.1; // 1/10
          done = false;
          let fracPart = 0;
          while (!done && i < parser.length) {
              const c = parser.get(i++);
              if (DIGITS.has(c)) {
                  fracPart += frac * DIGITS.get(c);
                  frac = frac / 10;
              }
              else if (c !== 0x005f) {
                  // If it's neither a digit nor a "_" separator, we're done
                  done = true;
                  i -= 1;
              }
              else {
                  parser.skipTo(i);
                  return result.error(value + fracPart, 'decimal-number-expected');
              }
          }
          value += fracPart;
      }
      // Exponent
      parser.skipTo(i);
      return applyExponent(parser, start, value);
  }
  function parseNumber(parser) {
      // Note: the order of the parsing matters.
      // Parse the numbers with a `0` prefix first (`0b`, `0x`)
      // then parse floating point number last.
      // Otherwise "0" is ambiguous.
      let result = parseBinaryNumber(parser);
      if (result.isFailure)
          result = parseHexadecimalNumber(parser);
      if (result.isFailure)
          result = parseFloatingPointNumber(parser);
      return result;
  }
  function parseSignedNumber(parser) {
      const result = new Result(parser);
      const start = parser.offset;
      let i = start;
      // Is it the minus sign (-)
      let sign = 1;
      if (parser.get(i) === 0x002d) {
          i++;
          sign = -1;
      }
      else if (parser.get(i) === 0x002b) {
          // It's the plus sign (+)
          i++;
      }
      parser.skipTo(i);
      const numResult = parseNumber(parser);
      if (numResult.isSuccess)
          return result.success(sign * numResult.value);
      if (numResult.isError) {
          return result.errorFrom(numResult, sign * numResult.value);
      }
      return result.failure();
  }

  function skipInlineSpaces(parser) {
      let i = parser.offset;
      let c;
      do {
          c = parser.get(i++);
      } while (c === 0x0020 || c === 0x0009);
      parser.skipTo(i - 1);
  }
  // export function parseNewline(state: ParserState): Result<void> {
  //   let i = state.offset;
  //   const c = state.source[i++];
  //   if (c === '\r' || c === '\u2028' || c === '\u2029') {
  //     return success(state, i);
  //   }
  //   if (c === '\n') {
  //     if (state.source[i] === '\r') return success(state, i + 2);
  //     return success(state, i);
  //   }
  //   return failure(state);
  // }
  /**
   * Skip all characters until a linebreak
   */
  function skipUntilLinebreak(parser) {
      let found = false;
      let i = parser.offset;
      while (!found && i < parser.length) {
          const c = parser.get(i++);
          if (c === 0x000d || c === 0x2028 || c === 0x2029) {
              found = true;
          }
          if (c === 0x000a) {
              if (parser.get(i) === 0x000d) {
                  i += 1;
              }
              found = true;
          }
      }
      parser.skipTo(i);
  }
  /**
   * If we are on a linebreak, skip it
   */
  function skipLinebreak(parser) {
      const c = parser.get(parser.offset);
      if (c === 0x000d || c === 0x2028 || c === 0x2029) {
          parser.skipTo(parser.offset + 1);
          return;
      }
      if (c === 0x000a) {
          if (parser.get(parser.offset + 1) === 0x000d) {
              parser.skipTo(parser.offset + 2);
          }
          else {
              parser.skipTo(parser.offset + 1);
          }
      }
  }
  /**
   * Whitespace includes space, tab, mathematical space, and comments.
   */
  function parseWhitespace(parser) {
      let done = false;
      const result = new Result(parser);
      let i = parser.offset;
      while (!done && i < parser.length) {
          const offset = parser.offset;
          while (!done) {
              const c = parser.get(i);
              done = !isWhitespace(c);
              if (!done)
                  i += codePointLength(c);
          }
          result.copyDiagnostics(parseLineComment(parser.skipTo(i)));
          result.copyDiagnostics(parseBlockComment(parser));
          if (result.isError)
              return result;
          done = offset === parser.offset;
          i = parser.offset;
      }
      parser.skipTo(i);
      return result.ignore();
  }
  function parseLineComment(parser) {
      const result = new Result(parser);
      // Check for "//"
      if (parser.get(parser.offset) === 0x002f &&
          parser.get(parser.offset + 1) === 0x002f) {
          skipUntilLinebreak(parser);
      }
      // @todo: warning for trailing whitespace
      return result.ignore();
  }
  function parseBlockComment(parser) {
      // `/*` prefix
      const result = new Result(parser);
      let i = parser.offset;
      if (parser.get(i) !== 0x002f || parser.get(i + 1) !== 0x002a) {
          return result.failure();
      }
      i += 2;
      let level = 1;
      while (level > 0 && i < parser.length) {
          const c = parser.get(i);
          if (c === 0x002f && parser.get(i + 1) === 0x002a) {
              level += 1;
              i += 2;
          }
          else if (c === 0x002a && parser.get(i + 1) === 0x002f) {
              level -= 1;
              i += 2;
          }
          else {
              i += codePointLength(c);
          }
      }
      if (level > 0) {
          parser.skipTo(parser.offset + i);
          return result.errorAt(null, 'end-of-comment-expected', result.start);
      }
      return result.ignoreUntil(i);
  }
  function parseShebang(parser) {
      // Are the first two characters "#" and "!"?
      const result = new Result(parser);
      if (parser.offset !== 0 ||
          parser.get(0) !== 0x0023 ||
          parser.get(1) !== 0x0021) {
          return result.failure();
      }
      skipUntilLinebreak(parser);
      return result.success(true);
  }

  /** Parse an escape sequence such as `\n` or `\u0041`*/
  function parseEscapeSequence(parser) {
      const result = new Result(parser);
      // Is it a backslash?
      if (parser.get(parser.offset) !== 0x005c)
          return result.failure();
      const start = parser.offset;
      // Is is a common escape sequence? ("\b", "\n", etc...)
      const replacement = REVERSED_ESCAPED_CHARS.get(parser.get(start + 1));
      if (replacement !== undefined) {
          parser.skipTo(start + 2);
          return result.success(String.fromCodePoint(replacement));
      }
      // Is i a Unicode escape sequence: "\u0041", "\u{0041}"
      let i = start + 1;
      const escapeChar = parser.get(i++);
      // Is it a "u"?
      if (escapeChar !== 0x0075) {
          parser.skipTo(i);
          // Some unrecognized escape sequence, i.e. `\z`. Return "z" and an error.
          return result.errorAt(String.fromCodePoint(escapeChar), ['invalid-escape-sequence', '\\' + String.fromCodePoint(escapeChar)], start);
      }
      let code = 0;
      let invalidChar = false;
      let done = false;
      let codepointString = '';
      //  Is it a `{`
      if (parser.get(i) === 0x007b) {
          i += 1;
          // At least one and up to 8 hex digits
          while (!done && i < start + 11) {
              const c = parser.get(i++);
              codepointString += String.fromCodePoint(c);
              invalidChar = invalidChar || !HEX_DIGITS.has(c);
              if (!invalidChar)
                  code = 16 * code + HEX_DIGITS.get(c);
              done = parser.get(i) === 0x007d; // "}"
          }
          if (done)
              i += 1;
      }
      else {
          // Exactly 4 hex digits
          while (!invalidChar && i <= parser.offset + 5) {
              const c = parser.get(i++);
              codepointString += String.fromCodePoint(c);
              invalidChar = !HEX_DIGITS.has(c);
              if (!invalidChar)
                  code = 16 * code + HEX_DIGITS.get(c);
          }
          done = i <= parser.length;
      }
      parser.skipTo(i);
      if (invalidChar || !done) {
          return result.errorAt('\ufffd', ['invalid-unicode-codepoint-string', codepointString], start);
      }
      // Validate that the codepoint is a Unicode scalar value:
      // - In the range of Unicode codepoints: [0..0x10ffff]
      // - Not in the Surrogate range (a surrogate codepoint is valid
      // as part of a UTF-16 encoding, but not as a standalone codepoint)
      // If not return `'\ufffd'`, the Unicode Replacement Character.
      if (code > 0x10ffff) {
          return result.errorAt('\ufffd', [
              'invalid-unicode-codepoint-value',
              'U+' + ('00000' + code.toString(16)).slice(-8).toUpperCase(),
          ], start);
      }
      if (code >= 0xd800 && code <= 0xdfff) {
          return result.errorAt('\ufffd', [
              'invalid-unicode-codepoint-value',
              'U+' + ('0000' + code.toString(16)).slice(-4).toUpperCase(),
          ], start);
      }
      return result.success(String.fromCodePoint(code));
  }
  /** An extended string is surrounded by `###"..."###` or `#"..."#` and
   * contains no escape sequence. Convenient for strings that contain lots
   * of characters that would otherwise need to be escaped: quotation marks,
   * backslash, etc...
   *
   */
  function parseExtendedString(parser) {
      const start = parser.offset;
      const result = new Result(parser);
      // Not a hashtag? Bail.
      if (parser.get(start) !== 0x0023)
          return result.failure();
      // Look for a sequence of '#'s
      let prefixLength = 0;
      let i = start;
      while (parser.get(i++) === 0x0023)
          prefixLength += 1;
      i -= 1;
      // Not a quote? We bail.
      if (parser.get(i++) !== 0x0022)
          return result.failure();
      let value = '';
      let done = false;
      let found = false;
      do {
          const c = parser.get(i++);
          done = i >= parser.length || isLinebreak(c);
          if (c === 0x0022) {
              // We have a quote.
              // Do we have a string of '#'?
              let j = prefixLength;
              while (j > 0 && parser.get(i + j - 1) === 0x0023)
                  j -= 1;
              found = j === 0;
              if (found)
                  i += prefixLength;
          }
          if (!done && !found)
              value += String.fromCodePoint(c);
      } while (!done && !found);
      parser.skipTo(i);
      if (!found) {
          return result.error(value, [
              'string-literal-closing-delimiter-expected',
              '#'.repeat(prefixLength) + '"',
          ]);
      }
      return result.success(value);
  }
  /** At the `\` of a `\(...)` expression */
  function parseInterpolation(parser, expression) {
      const result = new Result(parser);
      if (expression === undefined ||
          parser.get(parser.offset) !== 0x005c ||
          parser.get(parser.offset + 1) !== 0x0028) {
          return result.failure();
      }
      const startExpr = parser.offset + 2;
      const expr = parser.parse(expression, startExpr);
      result.copyDiagnostics(expr);
      // After the expression, we should have a closing parenthesis
      if (parser.get(parser.offset) !== 0x0029) {
          return result.error(expr.value, ['closing-bracket-expected', ')']);
      }
      parser.skipTo(parser.offset + 1);
      result.value = expr.value;
      return result;
  }
  /** A single line string is surrounded by quotation mark and may include escape sequences.
   *
   * @param expression - a function that parses an expression inside a `\()` escape sequence
   *
   */
  function parseSingleLineString(parser, expression) {
      const result = new Result(parser);
      const start = parser.offset;
      // Not a quote? Bail.
      if (parser.get(start) !== 0x0022)
          return result.failure();
      if (parser.get(start + 1) === 0x0022 && parser.get(start + 2) !== 0x0022) {
          // This is two quotes in a row, but not three.
          // It's the empty string!
          parser.skipTo(parser.offset + 2);
          return result.success(['']);
      }
      // Is this three quotes in a row?
      if (parser.get(start + 1) === 0x0022 && parser.get(start + 2) === 0x0022) {
          // It's not a single line string (might be a multiline string)
          return result.failure();
      }
      // It **is** a single line string
      let done = false;
      let found = false;
      parser.skipTo(start + 1);
      const values = [];
      let value = '';
      while (!done && !found && !parser.atEnd()) {
          const c = parser.get(parser.offset);
          found = c === 0x0022;
          done = isLinebreak(c);
          if (c === 0x005c) {
              const interpolation = parseInterpolation(parser, expression);
              if (!interpolation.isFailure) {
                  values.push(value);
                  value = '';
                  result.copyDiagnostics(interpolation);
                  values.push(interpolation.value);
              }
              else {
                  const escape = parseEscapeSequence(parser);
                  result.copyDiagnostics(escape);
                  if (escape.isSuccess) {
                      value += escape.value;
                  }
                  else if (escape.isError) {
                      value += '\\' + escape.value;
                  }
              }
          }
          else {
              if (!done && !found)
                  value += String.fromCodePoint(c);
              parser.skipTo(parser.offset + 1);
          }
      }
      if (value) {
          values.push(value);
          value = '';
      }
      if (!found) {
          if (values.length === 0 && (parser.atEnd() || parser.atLinebreak())) {
              // We have a quote at the end of a line, that's probably an end-quote
              // with a missing open-quote.
              return result.error([''], ['string-literal-opening-delimiter-expected', '"']);
          }
          else {
              return result.error(values, [
                  'string-literal-closing-delimiter-expected',
                  '"',
              ]);
          }
      }
      result.success(values);
      return result;
  }
  /**
   * A multiline line string begins and end with a triple quotation mark """
   * It can span multiple lines and contain escape sequences.
   *
   * @param expression - a function that parses an expresion inside a `\()`
   * escape sequence
   *
   */
  function parseMultilineString(parser, expression // (parser: Parser) => Result<T>
  ) {
      const result = new Result(parser);
      const start = parser.offset;
      // Do we have three quotes in a row?
      if (parser.get(start) !== 0x0022 ||
          parser.get(start + 1) !== 0x0022 ||
          parser.get(start + 2) !== 0x0022) {
          return result.failure();
      }
      skipInlineSpaces(parser.skipTo(start + 3));
      if (!parser.atLinebreak()) {
          return result.error([''], 'multiline-string-expected');
      }
      skipLinebreak(parser);
      // Iterate over each line...
      let done = false;
      let i = parser.offset;
      const lines = [];
      let values = [];
      let value = '';
      while (!done && i < parser.length) {
          const c = parser.get(i);
          if (isLinebreak(c)) {
              // We got a new line.
              if (value)
                  values.push(value);
              value = '';
              lines.push(values);
              values = [];
              skipLinebreak(parser.skipTo(i));
              i = parser.offset;
          }
          else {
              // We're on a line...
              done =
                  c === 0x0022 &&
                      parser.get(i + 1) === 0x0022 &&
                      parser.get(i + 2) === 0x0022;
              if (c === 0x005c) {
                  // We have an escape sequence...
                  if (isLinebreak(parser.get(i + 1))) {
                      // It's a `\\\n` sequence, just add them, we'll handle them later
                      value += '\\\n';
                      i += 2;
                  }
                  else {
                      parser.skipTo(i);
                      const interpolation = parseInterpolation(parser, expression);
                      if (!interpolation.isFailure) {
                          i = parser.offset;
                          values.push(value);
                          value = '';
                          result.copyDiagnostics(interpolation);
                          values.push(interpolation.value);
                      }
                      else {
                          const escape = parseEscapeSequence(parser);
                          i = parser.offset;
                          if (escape.isSuccess) {
                              value += escape.value;
                          }
                          else if (escape.isError) {
                              value += String.fromCodePoint(c);
                              result.copyDiagnostics(escape);
                          }
                      }
                  }
              }
              else {
                  if (!done)
                      value += String.fromCodePoint(c);
                  i += 1;
              }
          }
      }
      parser.skipTo(i + 2);
      const prefix = value;
      let validPrefix = true;
      if (prefix.length > 0) {
          // If there is a "prefix"...
          for (const c of prefix) {
              if (!isInlineSpace(c.codePointAt(0)))
                  validPrefix = false;
          }
          if (validPrefix) {
              // Remove the prefix from all the other lines
              // @todo: the lines *must* start with the prefix
              for (const line of lines) {
                  if (typeof line[0] === 'string' && line[0].startsWith(prefix)) {
                      line[0] = line[0].slice(prefix.length);
                  }
              }
          }
      }
      let resultValue = [];
      for (let i = 0; i <= lines.length - 1; i++) {
          const line = lines[i];
          const lastItem = line[line.length - 1];
          if (typeof lastItem === 'string' &&
              lastItem[lastItem.length - 1] === '\\') {
              line[line.length - 1] = lastItem.slice(-1);
              resultValue = [...resultValue, ...line];
          }
          else if (i === lines.length - 1) {
              resultValue = [...resultValue, ...line];
          }
          else {
              resultValue = [...resultValue, ...line, '\n'];
          }
      }
      if (!validPrefix) {
          return result.error(resultValue, 'multiline-whitespace-expected');
      }
      result.value = resultValue;
      return result;
  }

  function parseIdentifier(parser) {
      const result = parseVerbatimIdentifier(parser);
      if (!result.isFailure)
          return result;
      //
      // A non-verbatim identifier
      //
      const start = parser.offset;
      let code = parser.get(start);
      if (isIdentifierStartProhibited(code) || isBreak(code)) {
          return result.failure();
      }
      let done = false;
      let i = start;
      let id = '';
      while (!done && i < parser.length) {
          code = parser.get(i);
          done = isBreak(code) || isIdentifierContinueProhibited(code);
          if (!done) {
              const s = String.fromCodePoint(code);
              id += s;
              i += s.length;
          }
      }
      if (id.length === 0)
          return result.failure();
      parser.skipTo(i);
      return result.success(id);
  }
  /** A verbatim identifier is enclosed in backticks and can
   * include characters that are otherwise invalid (such as `+`).
   * It can also include escape sequences.
   */
  function parseVerbatimIdentifier(parser) {
      const result = new Result(parser);
      // Is it a backtick?
      if (parser.get(parser.offset) !== 0x0060)
          return result.failure();
      let done = false;
      let invalidChar = false;
      let i = parser.offset + 1; // Skip the initial backtick
      let id = '';
      let atLinebreak = false;
      while (!done && !atLinebreak && i < parser.length) {
          const code = parser.get(i);
          atLinebreak = isLinebreak(code);
          done = code === 0x0060; // GRAVE ACCENT = backtick
          if (!done) {
              if (code === 0x005c) {
                  // Escape sequence
                  parser.skipTo(i);
                  const escSequence = parseEscapeSequence(parser);
                  if (escSequence.isSuccess)
                      id += escSequence.value;
                  i = parser.offset;
              }
              else {
                  invalidChar = invalidChar || isIdentifierContinueProhibited(code);
                  const s = String.fromCodePoint(code);
                  id += s;
                  i += s.length;
              }
          }
      }
      if (!done) {
          parser.skipTo(i);
          // We reached the end of the line, or end of the source,
          // or found an invalid char without finding the closing '`'
          return result.errorAt('Missing', ['unbalanced-verbatim-symbol', id], result.start);
      }
      parser.skipTo(i + 1);
      if (id.length === 0) {
          return result.errorAt('Missing', 'empty-verbatim-symbol', result.start);
      }
      if (invalidChar || isIdentifierStartProhibited(id.charCodeAt(0))) {
          return result.errorAt('Missing', ['invalid-symbol-name', id], result.start);
      }
      return result.success(id);
  }

  class Grammar {
      constructor() {
          this.rules = {};
          this.ruleDescription = {};
          this.rule('quoted-text-item', 'U+0000-U+0009 U+000B-U+000C U+000E-U+0021 U+0023-U+2027 U+202A-U+D7FF | U+E000-U+10FFFF');
          this.rule('linebreak', '(U+000A \\[U+000D\\]) | U+000D | U+2028 | U+2029');
          this.rule('unicode-char', '_quoted-text-item_ | _linebreak_ | U+0022');
          this.rule('pattern-syntax', 'U+0021-U+002F | U+003A-U+0040 | U+005b-U+005E | U+0060 | U+007b-U+007e | U+00A1-U+00A7 | U+00A9 | U+00AB-U+00AC | U+00AE | U+00B0-U+00B1 | U+00B6 | U+00BB | U+00BF | U+00D7 | U+00F7 | U+2010-U+203E | U+2041-U+2053 | U+2190-U+2775 | U+2794-U+27EF | U+3001-U+3003 | U+3008-U+3020 | U+3030 | U+FD3E | U+FD3F | U+FE45 | U+FE46');
          this.rule('inline-space', 'U+0009 | U+0020');
          this.rule('pattern-whitespace', '_inline-space_ | U+000A | U+000B | U+000C | U+000D | U+0085 | U+200E | U+200F | U+2028 | U+2029');
          this.rule('whitespace', '_pattern-whitespace_ | U+0000 | U+00A0 | U+1680 | U+180E | U+2000-U+200A | U+202f | U+205f | U+3000');
          this.rule('line-comment', '**`//`** (_unicode-char_)* _linebreak_)');
          this.rule('block-comment', '**`/*`** (((_unicode-char_)\\* _linebreak_)) | _block-comment_) **`*/`**');
          this.rule('digit', 'U+0030-U+0039 | U+FF10-U+FF19');
          this.rule('hex-digit', '_digit_ | U+0041-U+0046 | U+0061-U+0066 | U+FF21-FF26 | U+FF41-U+FF46');
          this.rule('binary-digit', 'U+0030 | U+0031 | U+FF10 | U+FF11');
          this.rule('numerical-constant', '**`NaN`** | **`Infinity`** | **`+Infinity`** | **`-Infinity`**');
          this.rule('base-10-exponent', '(**`e`** | **`E`**) \\[_sign_\\](_digit_)+');
          this.rule('base-2-exponent', '(**`p`** | **`P`**) \\[_sign_\\](_digit_)+');
          this.rule('binary-number', '**`0b`** (_binary-digit_)+ \\[**`.`** (_binary-digit_)+ \\]\\[_exponent_\\]');
          this.rule('hexadecimal-number', '**`0x`** (_hex-digit_)+ \\[**`.`** (_hex-digit_)+ \\]\\[_exponent_\\]');
          this.rule('decimal-number', '(_digit_)+ \\[**`.`** (_digit_)+ \\]\\[_exponent_\\]');
          this.rule('sign', '**`+`** | **`-`**');
          this.rule('symbol', '_verbatim-symbol_ | _inline-symbol_');
          this.rule('verbatim-symbol', '**``` ` ```** (_escape-sequence_ | _symbol_start_) (_escape-sequence_ | _symbol_continue_)* **``` ` ```**');
          this.rule('inline-symbol', '_symbol-start_ (_symbol_continue_)*');
          this.rule('escape-expression', '**`\\(`** _expression_ **`)`**');
          this.rule('single-line-string', '**`"`** (_escape-sequence_ | _escape-expression_ | _quoted-text-item_)* **`"`**');
          this.rule('multiline-string', '**`"""`** _multiline-string-line_ **`"""`**');
          this.rule('extended-string', '...');
          this.rule('shebang', '**`#!`** (unicode-char)* (_linebreak | _eof_)');
          this.rule('shebang', parseShebang);
      }
      /** Define a new rule or a rule description */
      rule(name, def) {
          if (typeof def === 'string') {
              this.ruleDescription[name] = def;
          }
          else if (typeof def === 'function') {
              if (!this.ruleDescription[name])
                  this.ruleDescription[name] = `_${name}_`;
              this.rules[name] = def;
          }
          else {
              this.ruleDescription[name] = def[0];
              this.rules[name] = def[1];
          }
      }
      toString() {
          return Object.keys(this.ruleDescription)
              .map((x) => `_${x}_ â†’ ${this.ruleDescription[x]}`)
              .join('\n\n');
      }
      parse(rule, parser, url) {
          if (typeof parser === 'string') {
              // We're parsing some new source: create a parser
              parser = new Parser(this, parser, url !== null && url !== void 0 ? url : '');
          }
          // We have a parsing in progress. Return a result of
          // applying the rule to the current state of the parser
          if (!this.has(rule))
              throw new Error('Unexpected rule ' + rule);
          return this.rules[rule](parser);
      }
      has(rule) {
          return typeof this.rules[rule] === 'function';
      }
      get(rule) {
          return this.rules[rule];
      }
  }

  // eslint-disable-next-line prefer-const
  const grammar = new Grammar();
  // For debugging purposes, output an expression as a string
  function expressionToString(expr) {
      if (expr === undefined || expr === null)
          return '';
      const strValue = getStringValue(expr);
      if (strValue !== null)
          return strValue;
      const numValue = getNumberValue(expr);
      if (numValue !== null)
          return Number(numValue).toString();
      return expr.toString();
  }
  const JSON_ESCAPE_CHARS = {
      0x00: '\\u0000',
      0x01: '\\u0001',
      0x02: '\\u0002',
      0x03: '\\u0003',
      0x04: '\\u0004',
      0x05: '\\u0005',
      0x06: '\\u0006',
      0x07: '\\u0007',
      0x08: '\\b',
      0x09: '\\t',
      0x0a: '\\n',
      0x0b: '\\u000b',
      0x0c: '\\f',
      0x0d: '\\r',
      0x0e: '\\u000e',
      0x0f: '\\u000f',
      0x10: '\\u0010',
      0x11: '\\u0011',
      0x12: '\\u0012',
      0x13: '\\u0013',
      0x14: '\\u0014',
      0x15: '\\u0015',
      0x16: '\\u0016',
      0x17: '\\u0017',
      0x18: '\\u0018',
      0x19: '\\u0019',
      0x1a: '\\u001a',
      0x1b: '\\u001b',
      0x1c: '\\u001c',
      0x1d: '\\u001d',
      0x1e: '\\u001e',
      0x1f: '\\u001f',
      0x22: '\\"',
      0x2f: '\\/',
      0x5c: '\\\\',
  };
  /**
   * Escape a string according to the JSON string requirements
   */
  function escapeJsonString(s) {
      var _a;
      let result = '';
      for (const c of s)
          result += (_a = JSON_ESCAPE_CHARS[c.codePointAt(0)]) !== null && _a !== void 0 ? _a : c;
      return result;
  }
  /** Decorate an expression with a source origin
   * (offset range in the source code)
   */
  function exprOrigin(expr, offsets) {
      if (!Array.isArray(offsets))
          offsets = offsets.range;
      if (Array.isArray(expr))
          return { fn: expr, sourceOffsets: offsets };
      if (typeof expr === 'object')
          return { ...expr, sourceOffsets: offsets };
      if (typeof expr === 'number') {
          return { num: expr.toString(), sourceOffsets: offsets };
      }
      if (typeof expr === 'string' &&
          expr[0] === "'" &&
          expr[expr.length - 1] === "'") {
          return { str: expr.slice(1, -1), sourceOffsets: offsets };
      }
      return { sym: expr, sourceOffsets: offsets };
  }
  grammar.rule('whitespace', (parser) => parseWhitespace(parser));
  grammar.rule('pragma', either(['pragma-symbol', 'pragma-function']));
  grammar.rule('pragma-symbol', either([
      literal('#line'),
      literal('#column'),
      literal('#filename'),
      literal('#url'),
      literal('#date'),
      literal('#time'),
  ], (fn) => {
      var _a;
      if (fn.value === '#date') {
          const today = new Date();
          return (today.getFullYear() +
              '-' +
              ('00' + (1 + today.getMonth())).slice(-2) +
              '-' +
              ('00' + (1 + today.getDay())).slice(-2));
      }
      if (fn.value === '#time') {
          const today = new Date();
          return (('00' + today.getHours().toString()).slice(-2) +
              ':' +
              ('00' + today.getMinutes().toString()).slice(-2) +
              ':' +
              ('00' + today.getSeconds().toString()).slice(-2));
      }
      if (fn.value === '#url') {
          return (_a = fn.parser.url) !== null && _a !== void 0 ? _a : 'Nothing';
      }
      if (fn.value === '#filename') {
          if (!fn.parser.url)
              return 'Nothing';
          return fn.parser.url.substring(fn.parser.url.lastIndexOf('/') + 1);
      }
      if (fn.value === '#line') {
          const origin = new Origin(fn.parser.source, fn.parser.url);
          return origin.getLinecol(fn.parser.offset)[0];
      }
      if (fn.value === '#column') {
          const origin = new Origin(fn.parser.source, fn.parser.url);
          return origin.getLinecol(fn.parser.offset)[1];
      }
      // @todo: #time, #line, etc...
      return 'Nothing';
  }));
  grammar.rule('pragma-function', sequence([
      either([
          literal('#warning'),
          literal('#error'),
          literal('#env'),
          literal('#navigator'),
      ]),
      'function-call-argument-clause',
  ], (fn, args) => {
      var _a;
      if (fn.value === '#warning') {
          const message = mapArgs(args.value, (x) => expressionToString(x)).join(' ');
          console.log(message);
          return { str: message };
      }
      else if (fn.value === '#error') {
          const message = mapArgs(args.value, (x) => expressionToString(x)).join(' ');
          console.error(message);
          throw new FatalParsingError(message);
      }
      else if (fn.value === '#env') {
          if ('process' in globalThis && process.env) {
              return {
                  str: (_a = process.env[expressionToString(getArg(args.value, 1))]) !== null && _a !== void 0 ? _a : '',
              };
          }
      }
      else if (fn.value === '#navigator') {
          // eslint-disable-next-line no-restricted-globals
          if ('navigator' in globalThis) {
              // eslint-disable-next-line no-restricted-globals
              return { str: navigator[expressionToString(getArg(args.value, 1))] };
          }
      }
      return 'Nothing';
  }));
  grammar.rule('function-call-argument-clause', manySeparatedBetween('(', 'expression', ',', ')', (values) => {
      return ['List', ...values.map((x) => x.value)];
  }));
  grammar.rule('signed-number', '_numerical-constant_ | (\\[_sign_\\] (_binary-number_ | _hexadecimal-number_ | _decimal-number_)');
  grammar.rule('signed-number', (parser) => {
      const result = new Result(parser);
      let litResult = parseString(parser, 'NaN');
      if (litResult.isFailure)
          litResult = parseString(parser, '+Infinity');
      if (litResult.isFailure)
          litResult = parseString(parser, '-Infinity');
      if (litResult.isSuccess) {
          return result.success(exprOrigin({ num: litResult.value }, litResult));
      }
      // `Infinity` is equal to `+Infinity`.
      litResult = parseString(parser, 'Infinity');
      if (litResult.isSuccess) {
          return result.success(exprOrigin({ num: '+Infinity' }, litResult));
      }
      const numResult = parseSignedNumber(parser);
      if (numResult.isSuccess) {
          // Return a number expression
          // @todo: we could return a BaseForm() for hexadecimal and decimal
          return result.success(exprOrigin(numResult.value, numResult));
      }
      return numResult;
  });
  grammar.rule('symbol', '_verbatim-symbol_ | _inline-symbol_');
  grammar.rule('symbol', (parser) => {
      const result = new Result(parser);
      const res = parseIdentifier(parser);
      result.copyDiagnostics(res);
      result.end = res.end;
      if (res.isSuccess || res.isError) {
          result.success(exprOrigin(res.value, res));
      }
      return result;
  });
  grammar.rule('string', '_single-line-string_ | _multiline-string_ | _extended-string_');
  grammar.rule('string', (parser) => {
      let result = parseSingleLineString(parser, 'expression');
      if (result.isFailure)
          result = parseMultilineString(parser, 'expression');
      if (result.isFailure) {
          result = parseExtendedString(parser);
          if (result.isSuccess) {
              return result.success(exprOrigin({ str: result.value }, result));
          }
      }
      if (result.isFailure || result.isEmpty)
          return result;
      const values = [];
      let previousString;
      for (const value of result.value) {
          if (typeof value === 'string') {
              previousString = (previousString !== null && previousString !== void 0 ? previousString : '') + value;
          }
          else if (isStringObject(value)) {
              previousString = (previousString !== null && previousString !== void 0 ? previousString : '') + value.str;
          }
          else {
              if (typeof previousString === 'string') {
                  values.push(previousString);
                  previousString = undefined;
              }
              values.push(value);
          }
      }
      if (typeof previousString === 'string')
          values.push(previousString);
      let value;
      if (values.length === 1 && typeof values[0] === 'string') {
          // It's a simple, non-interpolated string
          value = exprOrigin({ str: escapeJsonString(values[0]) }, result);
      }
      else {
          // It's an interpolated string
          value = exprOrigin([
              'String',
              ...values.map((x) => {
                  return typeof x === 'string' ? { str: x } : x;
              }),
          ], result);
      }
      result.value = value;
      return result;
  });
  grammar.rule('primary', either([
      'pragma',
      'signed-number',
      'symbol',
      'string',
      'parenthesized-expression',
  ]));
  grammar.rule('expression', operatorSequence([
      ['NotElement', '!in', 160],
      ['Element', 'in', 240],
      ['LessEqual', '<=', 241],
      ['GreaterEqual', '>=', 242],
      ['Less', '<', 245],
      ['Greater', '>', 245],
      ['NotEqual', '!=', 255],
      ['Assign', '=', 258],
      ['Equal', '==', 260],
      ['Same', '===', 260],
      ['KeyValue', '->', 265],
      ['Add', '+', 275],
      ['Subtract', '-', 275],
      ['Multiply', '*', 390],
      ['Divide', '/', 660],
      ['Negate', '-', 665, 'prefix'],
      ['Power', '^', 720, 'left'],
      // ['Subscript', '_', 720, 'left'],
      ['Pipe', '|>', 790],
      ['BackPipe', '~>', 790],
      ['Or', '||', 800],
      ['And', '&&', 810],
      ['Not', '!', 820, 'prefix'],
  ], 'primary'));
  grammar.rule('parenthesized-expression', between('(', 'expression', ')'));
  // Top-level rule for the Cortex grammar
  grammar.rule('cortex', must(sequence([
      maybe('shebang'),
      some('expression', (...expressions) => {
          var _a;
          console.assert(expressions && expressions.length > 0);
          const exprs = expressions.filter((x) => !x.isEmpty && !x.isFailure);
          if (exprs.length === 0) {
              return exprOrigin('Nothing', expressions[0]);
          }
          if (exprs.length === 1) {
              return exprOrigin((_a = exprs[0].value) !== null && _a !== void 0 ? _a : 'Nothing', exprs[0]);
          }
          return exprOrigin(['Do', ...exprs.map((x) => x.value)], [exprs[0].start, exprs[exprs.length - 1].end]);
      }),
      must(eof()),
  ], (_shebang, expr, _eof) => { var _a; return exprOrigin((_a = expr.value) !== null && _a !== void 0 ? _a : 'Nothing', expr); })));
  /** Analyze the reported errors and combine them when possible */
  function analyzeErrors(errors) {
      const result = [...errors];
      // @todo: could combine a 'string-literal-closing-delimiter-expected'
      // followed by a 'string-literal-opening-delimiter-expected'
      return result;
  }
  function parseCortex(source, url) {
      const result = grammar.parse('cortex', source, url);
      // Yay!
      if (result.isSuccess)
          return [result.value, []];
      // Uh-oh.
      const origin = new Origin(source);
      if (result.isError) {
          // Something went wrong: 1 or more syntax errors
          return [
              result.value,
              analyzeErrors(result.diagnostics).map((x) => {
                  var _a;
                  return {
                      ...x,
                      // Convert from offset to line/col
                      origin: origin.signalOrigin((_a = x.range[2]) !== null && _a !== void 0 ? _a : x.range[1]),
                  };
              }),
          ];
      }
      // Should not happen
      if (result.isEmpty)
          return ['Nothing', []];
      if (result.isFailure) {
          // Should not happen (should get an error instead)
          return ['Nothing', []];
      }
      return ['Nothing', []];
  }

  //
  // Generic code formatter
  //
  // Based on "A New Approach to Optimal Code Formatting",
  // Phllip M. Yelland, Google.
  // https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/44667.pdf
  //
  // See also:
  //
  // 1998, Philip Wadler "A Prettier Printer"
  // https://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
  //
  // 1995, John Hughes. "The design of a pretty-printer library"
  // http://belle.sourceforge.net/doc/hughes95design.pdf
  //
  // 1980, Derek C. Oppen, "Prettyprinting"
  // https://www.cs.tufts.edu/~nr/cs257/archive/derek-oppen/prettyprinting.pdf
  class FormattingBlock {
      constructor(fmt) {
          this.fmt = fmt;
      }
  }
  class EmptyBlock extends FormattingBlock {
      constructor(fmt) {
          super(fmt);
      }
      debug() {
          return 'EmptyBlock';
      }
      serialize(_offset) {
          return '';
      }
      nextCol(offset) {
          return offset;
      }
      cost(_offset) {
          return 0;
      }
  }
  /**
   *
   *      |                 |        |
   *
   *      |    [--------]*  |        |
   *
   *      |    [------------|---]*   |
   *
   *      |    [------------|--------|---]*
   *
   *      |                 |        |
   *      0                          margin
   *                        soft-margin
   *
   */
  class TextBlock extends FormattingBlock {
      constructor(fmt, s) {
          super(fmt);
          this.s = s;
      }
      debug() {
          if (this.s === ' ')
              return '" "';
          return '"' + this.s + '"';
      }
      serialize(_offset) {
          return this.s;
      }
      nextCol(offset) {
          return offset + this.s.length;
      }
      cost(offset) {
          const next = this.nextCol(offset);
          if (next >= this.fmt.margin) {
              return ((next - this.fmt.margin) * this.fmt.cost.margin +
                  (this.fmt.margin - this.fmt.softMargin) * this.fmt.cost.softMargin);
          }
          if (next >= this.fmt.softMargin) {
              return (next - this.fmt.softMargin) * this.fmt.cost.softMargin;
          }
          return 0;
      }
  }
  /**
   * A block that places its elements in a single line
   *
   * 0    offset
   * |
   * |    [--------][-----------][------][----------]*
   * |
   */
  class LineBlock extends FormattingBlock {
      constructor(fmt, ...blocks) {
          super(fmt);
          this.blocks = blocks;
      }
      debug() {
          return 'Line(' + this.blocks.map((x) => x.debug()).join(', ') + ')';
      }
      serialize(offset) {
          const fragments = [];
          for (const block of this.blocks) {
              fragments.push(block.serialize(offset));
              offset = block.nextCol(offset);
          }
          return fragments.join('');
      }
      nextCol(offset) {
          return this.blocks.reduce((acc, val) => val.nextCol(acc), offset);
      }
      cost(offset) {
          let result = 0;
          for (const block of this.blocks) {
              result += block.cost(offset);
              offset = block.nextCol(offset);
          }
          return result;
      }
  }
  /**
   * A block that arranges its elements vertically, separated by line breaks.
   *
   *      0    offset
   *      |
   *      |    [---1----]
   *      |    [-----2------]
   *      |    [--3--]
   *      |    [----4----]
   *      |    *
   *      |
   */
  class StackBlock extends FormattingBlock {
      constructor(fmt, ...blocks) {
          super(fmt);
          this.blocks = blocks;
      }
      debug() {
          return 'Stack(' + this.blocks.map((x) => x.debug()).join(', ') + ')';
      }
      serialize(offset) {
          let result = '';
          let indent = '';
          for (const block of this.blocks) {
              result += indent + block.serialize(offset);
              if (!indent)
                  indent = this.fmt.linebreak() + this.fmt.indentChars(offset);
          }
          return result;
      }
      nextCol(offset) {
          return offset;
      }
      cost(offset) {
          return this.blocks.reduce((acc, val) => this.fmt.cost.linebreak + acc + val.cost(offset), 0);
      }
  }
  /**
   * A block that arranges its elements like a justified paragraph
   *
   *      |                            |
   *      |    [---1----][----2------] |
   *      |    [--3---][----4-----]    |
   *      |    [--5--][--6---][--7--]  |
   *      |    [---8----]*             |
   *      |                            |
   *
   */
  class WrapBlock extends FormattingBlock {
      constructor(fmt, ...blocks) {
          super(fmt);
          this.blocks = blocks;
      }
      debug() {
          return 'Wrap(' + this.blocks.map((x) => x.debug()).join(', ') + ')';
      }
      solution(offset) {
          const lines = [];
          let line = [];
          for (const block of this.blocks) {
              if (line.length === 0) {
                  // If nothing on the line yet, add this block
                  line.push(block);
              }
              else {
                  // At least one item on the line. Does this new item fit?
                  const lineBlock = new LineBlock(this.fmt, ...line, block);
                  if (lineBlock.nextCol(offset) <= this.fmt.margin) {
                      // It fits!
                      line.push(block);
                  }
                  else {
                      // Does not fit
                      lines.push(line);
                      line = [block];
                  }
              }
          }
          // Don't forget the last line
          if (line.length !== 0)
              lines.push(line);
          return new StackBlock(this.fmt, ...lines.map((x) => new LineBlock(this.fmt, ...x)));
      }
      serialize(offset) {
          return this.solution(offset).serialize(offset);
      }
      nextCol(offset) {
          return this.solution(offset).nextCol(offset);
      }
      cost(offset) {
          return this.solution(offset).cost(offset);
      }
  }
  // export class VerbatimBlock extends FormattingBlock {
  //   private block: FormattingBlock;
  //   constructor(fmt: Formatter, block: FormattingBlock) {
  //     super(fmt);
  //     this.block = block;
  //   }
  //   serialize(offset: number): string {
  //     return '';
  //   }
  //   nextCol(offset: number): number {
  //     return 0;
  //   }
  //   cost(offset: number): number {
  //     return 0;
  //   }
  // }
  class ChoiceBlock extends FormattingBlock {
      constructor(fmt, ...blocks) {
          super(fmt);
          this.blocks = blocks;
      }
      debug() {
          return ('Choice(\n  ' + this.blocks.map((x) => x.debug()).join('\n  ') + '\n)');
      }
      // Which block would be chosen if starting at column `offset`
      choice(offset) {
          let block;
          let minCost = Infinity;
          this.blocks.forEach((x) => {
              const cost = x.cost(offset);
              if (cost < minCost) {
                  minCost = cost;
                  block = x;
              }
          });
          return block;
      }
      serialize(offset) {
          return this.choice(offset).serialize(offset);
      }
      nextCol(offset) {
          return this.choice(offset).nextCol(offset);
      }
      cost(offset) {
          return Math.min(...this.blocks.map((x) => x.cost(offset)));
      }
  }
  class Formatter {
      constructor(options) {
          var _a;
          if ((options === null || options === void 0 ? void 0 : options.indentChar) === 'space') {
              options.indentChar = '\u0020';
          }
          else if ((options === null || options === void 0 ? void 0 : options.indentChar) === 'tab') {
              options.indentChar = '\t';
          }
          this.options = {
              cost: {
                  softMargin: 0.05,
                  margin: 100,
                  linebreak: 2,
                  commentLinebreak: 0.5,
                  flowLinebreak: 0.3,
                  callLinebreak: 0.5,
                  argLinebreak: 5,
                  ...((_a = options === null || options === void 0 ? void 0 : options.cost) !== null && _a !== void 0 ? _a : {}),
              },
              indentChar: '\u0020',
              indentCharWidth: 1,
              indentWidth: 2,
              margin: 80,
              softMargin: 50,
              aroundInfixOperator: '\u0020',
              aroundRelationalOperator: '\u0020',
              afterSeparator: '\u0020',
              ...(options !== null && options !== void 0 ? options : {}),
          };
      }
      get cost() {
          return this.options.cost;
      }
      get margin() {
          return this.options.margin;
      }
      get softMargin() {
          return this.options.softMargin;
      }
      indentChars(n = 1) {
          return (this.options.indentChar === 'tab' ? '\t' : ' ').repeat(n * this.options.indentWidth);
      }
      indentLength(n = 1) {
          return n * this.options.indentWidth * this.options.indentCharWidth;
      }
      linebreak(a, b) {
          if (!a && !b)
              return '\n';
          if (!b)
              return a + '\n';
          return a + '\n' + b;
      }
      countLinebreaks(s) {
          return s.split(/\r\n|\r|\n/).length;
      }
      normalizedBlocks(blocks) {
          return blocks
              .map((x) => (typeof x === 'string' ? new TextBlock(this, x) : x))
              .filter((x) => !(x instanceof EmptyBlock));
      }
      /** A binary or ternary operator: +, -, etc... */
      infixOperator(op) {
          return new TextBlock(this, this.options.aroundInfixOperator + op + this.options.aroundInfixOperator);
      }
      /** A relational operator: =, <=, etc.. */
      relationalOperator(op) {
          return new TextBlock(this, this.options.aroundRelationalOperator +
              op +
              this.options.aroundRelationalOperator);
      }
      separator(op) {
          return new TextBlock(this, op + this.options.afterSeparator);
      }
      fence(f) {
          return new TextBlock(this, f);
      }
      /** A single line of unbroken text */
      text(s) {
          if (!s || s.length === 0)
              return new EmptyBlock(this);
          return new TextBlock(this, s);
      }
      /** Horizontal juxtaposition of a list of blocks */
      line(...inBlocks) {
          const blocks = this.normalizedBlocks(inBlocks);
          // Consecutive text blocks can be merged
          const mergedBlocks = [];
          let previousText = '';
          for (const block of blocks) {
              if (block instanceof TextBlock) {
                  if (previousText) {
                      mergedBlocks.pop();
                      previousText = previousText + block.s;
                      mergedBlocks.push(new TextBlock(this, previousText));
                  }
                  else {
                      mergedBlocks.push(block);
                      previousText = block.s;
                  }
              }
              else {
                  previousText = '';
                  mergedBlocks.push(block);
              }
          }
          if (mergedBlocks.length === 1)
              return mergedBlocks[0];
          return new LineBlock(this, ...mergedBlocks);
      }
      /** A list of block stacked on top of one another */
      stack(...inBlocks) {
          const blocks = this.normalizedBlocks(inBlocks);
          if (blocks.length === 1)
              return blocks[0];
          return new StackBlock(this, ...blocks);
      }
      /** Packs its constituent layouts horizontally, inserting line breaks
       * between them so as to minimize the total cost of output, in a manner
       * analogous to the composition of words in paragraph.
       *
       * Output after line breaks begins at the starting column of the entire
       * block.
       * */
      wrap(...inBlocks) {
          const blocks = this.normalizedBlocks(inBlocks);
          if (blocks.length === 1)
              return blocks[0];
          return new WrapBlock(this, ...blocks);
      }
      /** Indent a block by `indent` units. The value of a unit is specified in the options */
      indent(block, indent = 1) {
          return new LineBlock(this, new TextBlock(this, this.indentChars(indent)), block);
      }
      choice(...inBlocks) {
          const blocks = this.normalizedBlocks(inBlocks);
          if (blocks.length === 1)
              return blocks[0];
          return new ChoiceBlock(this, ...blocks);
      }
      fencedBlock(open, block, close) {
          if (!block)
              return this.line(this.fence(open), this.fence(close));
          return this.fencedList(open, '', close, [block]);
      }
      fencedList(open, sep, close, blocks) {
          const openBlock = this.fence(open);
          const closeBlock = this.fence(close);
          if (blocks.length === 0)
              return this.line(openBlock, closeBlock);
          if (blocks.length === 1) {
              return this.line(openBlock, blocks[0], closeBlock);
          }
          // `sepBlocks` has all the elements followed by a separator
          const sepBlocks = blocks.map((block) => this.line(block, sep));
          // `inlineSepBlocks` has a separator between each element (but not after
          // the last one).
          const inlineSepBlocks = [...sepBlocks];
          inlineSepBlocks.pop();
          inlineSepBlocks.push(blocks[blocks.length - 1]);
          if (!open && !close) {
              return this.choice(this.line(...inlineSepBlocks), this.wrap(...sepBlocks));
          }
          return this.choice(this.line(openBlock, ...inlineSepBlocks, closeBlock), this.stack(openBlock, this.indent(this.stack(...sepBlocks)), closeBlock));
      }
      list(sep, blocks) {
          return this.fencedList('', sep, '', blocks);
      }
  }

  const RESERVED_WORDS = new Set([
      'abstract',
      'at',
      'and',
      'as',
      'assert',
      'await',
      'begin',
      'break',
      'case',
      'catch',
      'class',
      'const',
      'continue',
      'debugger',
      'default',
      'delete',
      'dynamic',
      'do',
      'each',
      'else',
      'end',
      'export',
      'extern',
      'finally',
      'for',
      'from',
      'function',
      'get',
      'global',
      'goto',
      'if',
      'in',
      'inline',
      'interface',
      'internal',
      'import',
      'label',
      'lazy',
      'local',
      'loop',
      'match',
      'module',
      'namespace',
      'native',
      'new',
      'not',
      'of',
      'on',
      'optional',
      'or',
      'package',
      'private',
      'protected',
      'protocol',
      'public',
      'repeat',
      'return',
      'self',
      'set',
      'static',
      'super',
      'switch',
      'this',
      'throw',
      'to',
      'try',
      'until',
      'using',
      'var',
      'warn',
      'when',
      'where',
      'while',
      'with',
      'xor',
      'yield', // Not in use
  ]);

  const NUMBER_FORMATTING_OPTIONS = {
      precision: 15,
      decimalMarker: '.',
      groupSeparator: '_',
      exponentProduct: '',
      beginExponentMarker: 'e',
      endExponentMarker: '',
      notation: 'auto',
      imaginaryNumber: 'i',
      truncationMarker: '',
      beginRepeatingDigits: '',
      endRepeatingDigits: '',
      positiveInfinity: '+Infinity',
      negativeInfinity: '-Infinity',
      notANumber: 'NaN',
  };
  /**
   * Serialize a MathJSON expression to Cortex.
   *
   * @param options.fancySymbols - If true, some operators are replaced
   * with an equivalent Unicode character, for example: `*` -> `Ã—`.
   *
   */
  function serializeCortex(expr, options) {
      // To provide automatic formatting of the result, a Formatter is used.
      // The result of the serialization is a series of `FormattingBlock`
      // representing various layout options. They are then combined and arranged
      // accounting for constraints such as a maximum width and other formatting
      // options)
      const fmt = new Formatter({
          ...((options === null || options === void 0 ? void 0 : options.fancySymbols)
              ? {
                  aroundInfixOperator: '\u205f',
                  aroundRelationalOperator: '\u2005',
                  afterSeparator: '\u2009', // Thin Space
              }
              : {}),
          ...options,
      });
      function serializeExpression(expr) {
          var _a, _b;
          if (expr === null)
              return new EmptyBlock(this);
          // Is this a string literal?
          const stringValue = getStringValue(expr);
          if (stringValue !== null)
              return serializeString(stringValue);
          const comment = serializeComment(expr);
          let body;
          const head = getFunctionHead(expr);
          if (head !== null) {
              body =
                  (_b = (_a = serializeFunction(expr)) !== null && _a !== void 0 ? _a : serializeOperator(expr)) !== null && _b !== void 0 ? _b : serializeGenericFunction(expr);
          }
          if (!body) {
              const symName = getSymbolName(expr);
              if (symName !== null) {
                  body = fmt.text(escapeSymbol(symName));
              }
          }
          if (!body) {
              if (typeof expr === 'number' || isNumberObject(expr)) {
                  body = fmt.text(serializeNumber(expr, NUMBER_FORMATTING_OPTIONS));
              }
          }
          if (!body) {
              const dict = getDictionary(expr);
              if (dict !== null) {
                  const keyValues = Object.keys(dict).map((key) => fmt.line(escapeString(key), fmt.relationalOperator('->'), serializeExpression(dict[key])));
                  if (keyValues.length === 0)
                      return fmt.line(fmt.fence('{'), fmt.relationalOperator('->'), fmt.fence('}'));
                  body = fmt.fencedList('{', fmt.separator(','), '}', keyValues);
              }
          }
          if (body) {
              if (comment instanceof EmptyBlock)
                  return body;
              return fmt.choice(fmt.line(comment, body), fmt.stack(comment, body));
          }
          return fmt.text();
      }
      function serializeString(s) {
          // @todo:
          // could be more clever: if `s` contains line feeds, use a `"""` string
          // Also, if string doesn't fit margin, wrap it
          return fmt.text(`"${escapeString(s)}"`);
      }
      function serializeComment(expr) {
          if (!(typeof expr === 'object'))
              return fmt.text();
          if ('comment' in expr) {
              if (expr.comment && expr.comment.length > 0) {
                  // @todo: could be more clever. Use /* */ or // depending on whether
                  // comment is multiline
                  return fmt.text(`/* ${expr.comment} */`);
              }
          }
          return fmt.text();
      }
      const OPERATORS = {
          NotElementOf: {
              symbol: '!in',
              fancySymbol: '\u2209',
              relational: true,
              precedence: 160,
          },
          ElementOf: {
              symbol: 'in',
              fancySymbol: '\u2208',
              relational: true,
              precedence: 240,
          },
          LessEqual: {
              symbol: '<=',
              relational: true,
              fancySymbol: '\u2A7d',
              precedence: 241,
          },
          GreaterEqual: {
              symbol: '>=',
              fancySymbol: '\u2A7e',
              relational: true,
              precedence: 242,
          },
          Less: { symbol: '<', relational: true, precedence: 245 },
          Greater: { symbol: '>', relational: true, precedence: 245 },
          NotEqual: {
              symbol: '!=',
              fancySymbol: '\u2260',
              relational: true,
              precedence: 255,
          },
          Assign: { symbol: '=', relational: true, precedence: 258 },
          Equal: { symbol: '==', relational: true, precedence: 260 },
          Same: {
              symbol: '===',
              fancySymbol: '\u2263',
              relational: true,
              precedence: 260,
          },
          KeyValue: {
              symbol: '->',
              fancySymbol: '\u2192',
              precedence: 265,
          },
          Add: { symbol: '+', precedence: 275 },
          Subtract: { symbol: '-', fancySymbol: '\u2212', precedence: 275 },
          Multiply: { symbol: '*', fancySymbol: '\u00d7', precedence: 390 },
          Divide: { symbol: '/', fancySymbol: '\u00f7', precedence: 660 },
          Negate: {
              symbol: '-',
              unary: true,
              fancySymbol: '\u2212',
              precedence: 665,
          },
          Power: { symbol: '^', precedence: 720 },
          Or: { symbol: '||', fancySymbol: '\u22c1', precedence: 800 },
          And: { symbol: '&&', fancySymbol: '\u22c0', precedence: 810 },
          Not: { symbol: '!', unary: true, fancySymbol: '\u00ac', precedence: 820 },
      };
      //
      // Functions with a custom serializer: BaseForm, String, List, Set
      //
      const FUNCTIONS = {
          //
          // BaseForm
          //
          BaseForm: (expr) => {
              var _a;
              const base = (_a = getNumberValue(getArg(expr, 2))) !== null && _a !== void 0 ? _a : 16;
              const arg1 = getArg(expr, 1);
              const value = getNumberValue(arg1);
              if (value === null ||
                  Number.isNaN(value) ||
                  !Number.isFinite(value) ||
                  !(base === 2 || base === 10 || base === 16)) {
                  return serializeGenericFunction(expr);
              }
              if (base === 2) {
                  // Special notation for base-2
                  return fmt.text('0b' + Number(value).toString(2));
              }
              if (base === 10) {
                  // Base-10 notation, nothing special
                  // @todo: we could do a wrap with a \ continuation character at the end
                  // of the line
                  return fmt.text(serializeNumber(arg1, NUMBER_FORMATTING_OPTIONS));
              }
              if (base === 16) {
                  if (!Number.isFinite(value)) {
                      return fmt.text(serializeNumber(arg1, NUMBER_FORMATTING_OPTIONS));
                  }
                  if (Number.isInteger(value)) {
                      // Integer to hex
                      return fmt.text('0x' + Number(value).toString(16));
                  }
                  // Floating point to hex
                  return fmt.text(serializeHexFloat(value));
              }
              return serializeGenericFunction(expr);
          },
          //
          // String
          //
          // Interpolated string, e.g. `["String", "'hello '", "name"]`
          String: (expr) => fmt.wrap('"', ...mapArgs(expr, (x) => {
              const sv = getStringValue(x);
              if (sv !== null)
                  return fmt.text(escapeString(sv));
              return fmt.fencedBlock('\\(', serializeExpression(x), ')');
          }), '"'),
          //
          // List
          //
          // Interpolated string, e.g. `["String", "'hello '", "name"]`
          List: (expr) => fmt.fencedList('{', fmt.separator(','), '}', mapArgs(expr, serializeExpression)),
          //
          // Set
          //
          // Interpolated string, e.g. `["String", "'hello '", "name"]`
          Set: (expr) => {
              if (getArgCount(expr) === 0)
                  return fmt.text('EmptySet');
              return fmt.fencedList('[', fmt.separator(','), ']', mapArgs(expr, serializeExpression));
          },
          // @todo: Dictionary, Do, If
      };
      function serializeFunction(expr) {
          var _a, _b;
          return (_b = (_a = FUNCTIONS[getFunctionName(expr)]) === null || _a === void 0 ? void 0 : _a.call(FUNCTIONS, expr)) !== null && _b !== void 0 ? _b : null;
      }
      function serializeGenericFunction(expr) {
          const head = getFunctionHead(expr);
          if (typeof head === 'string') {
              // It's a function application with a named function
              return fmt.line(escapeSymbol(head), fmt.fencedList('(', fmt.separator(','), ')', mapArgs(expr, serializeExpression)));
          }
          // A function application with a function expression.
          return fmt.line('Apply(', serializeExpression(head), fmt.separator(','), fmt.fencedList('[', fmt.separator(','), ']', mapArgs(expr, serializeExpression)), ')');
      }
      // @todo: 2x, 2(x+1)
      function serializeOperator(expr) {
          var _a;
          const head = getFunctionName(expr);
          if (!head)
              return null;
          const op = OPERATORS[head];
          if (!op)
              return null;
          const opSymbol = (options === null || options === void 0 ? void 0 : options.fancySymbols)
              ? (_a = op.fancySymbol) !== null && _a !== void 0 ? _a : op.symbol
              : op.symbol;
          if (op.unary) {
              if (getArgCount(expr) !== 1)
                  return null;
              const arg = getArg(expr, 1);
              const argHead = getFunctionName(arg);
              const argOp = OPERATORS[argHead];
              if (argOp && argOp.precedence < op.precedence) {
                  return fmt.line(opSymbol, '(', serializeExpression(arg), ')');
              }
              return fmt.line(opSymbol, serializeExpression(arg));
          }
          const operands = mapArgs(expr, (arg) => {
              const argHead = getFunctionName(arg);
              const argOp = OPERATORS[argHead];
              if (argOp && argOp.precedence < op.precedence) {
                  return fmt.line('(', serializeExpression(arg), ')');
              }
              return serializeExpression(arg);
          });
          if (!operands)
              return null;
          return fmt.list(op.relational
              ? fmt.relationalOperator(opSymbol)
              : fmt.infixOperator(opSymbol), operands);
      }
      // Main body of `serializeCortex()`
      return serializeExpression(expr).serialize(0);
  }
  function escapeInvisibleCharacter(code) {
      if (ESCAPED_CHARS.has(code))
          return ESCAPED_CHARS.get(code);
      if (isInvisible(code)) {
          if (code < 0x10000) {
              return `\\u${('0000' + code.toString(16)).slice(-4)}`;
          }
          return `\\u{${('000000000' + code.toString(16)).slice(-8)}}`;
      }
      return String.fromCodePoint(code);
  }
  // Replace the characters in a raw string with escaped characters (`"`, `/`,
  // some invisible characters, etc...)
  function escapeString(s) {
      let result = '';
      const graphemes = splitGraphemes(s);
      if (typeof graphemes === 'string') {
          for (const c of graphemes) {
              result += escapeInvisibleCharacter(c.codePointAt(0));
          }
      }
      else {
          for (const c of graphemes) {
              if (c.length === 1) {
                  result += escapeInvisibleCharacter(c.codePointAt(0));
              }
              else {
                  // @todo: we could check specifically for the emoji range, rather
                  // than anything outside the BMP.
                  // If the grapheme is a multi-code point sequence (e.g. a combined emoji)
                  // use the entire composed sequence, don't try to break it up
                  // (which would break some emojis)
                  result += c;
              }
          }
      }
      return result;
  }
  // Escape the name of a symbol.
  // Use a Verbatim Form when necessary
  function escapeSymbol(s) {
      // If it's a reserved word: it should be always be escaped
      if (RESERVED_WORDS.has(s))
          return `\`${s}\``;
      // Shortcut common case: all alphanumeric symbol => nothing to escape
      if (/^[a-zA-Z][a-zA-Z\d_]*$/.test(s))
          return s;
      // If starts with a digit: need verbatim
      const code = s.codePointAt(0);
      if (DIGITS.has(code))
          return `\`${escapeString(s)}\``;
      let needVerbatim = false;
      const graphemes = splitGraphemes(s);
      let i = 0;
      while (!needVerbatim && i < graphemes.length) {
          const c = graphemes[i].codePointAt(0);
          needVerbatim = ESCAPED_CHARS.has(c) || isInvisible(c) || isBreak(c);
          i += 1;
      }
      if (!needVerbatim)
          return s;
      return `\`${escapeString(s)}\``;
  }

  // This is the root of the package for the Cortex language
  const version = '0.4.2';

  exports.ComputeEngine = ComputeEngine;
  exports.ExpressionMap = ExpressionMap;
  exports.LatexSyntax = LatexSyntax;
  exports.count = count;
  exports.evaluate = evaluate;
  exports.format = format;
  exports.match = match;
  exports.parse = parse;
  exports.parseCortex = parseCortex;
  exports.serialize = serialize;
  exports.serializeCortex = serializeCortex;
  exports.substitute = substitute;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
