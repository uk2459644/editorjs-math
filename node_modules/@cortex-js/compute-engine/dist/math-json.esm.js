function stringToCodepoints(string) {
    const result = [];
    for (let i = 0; i < string.length; i++) {
        let code = string.charCodeAt(i);
        // if (code === 0x0d && string.charCodeAt(i + 1) === 0x0a) {
        //   code = 0x0a;
        //   i++;
        // }
        // if (code === 0x0d || code === 0x0c) code = 0x0a;
        // if (code === 0x00) code = 0xfffd;
        // Decode a surrogate pair into an astral codepoint.
        if (code >= 0xd800 && code <= 0xdbff) {
            const nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 0xdc00 && nextCode <= 0xdfff) {
                const lead = code - 0xd800;
                const trail = nextCode - 0xdc00;
                code = 2 ** 16 + lead * 2 ** 10 + trail;
                // N = ((H - 0xD800) * 0x400) + (L - 0xDC00) + 0x10000;
                i++;
            }
        }
        result.push(code);
    }
    return result;
}
const ZWJ = 0x200d; // Zero-width joiner
// const ZWSP = 0x200b; // Zero-width space
// Regional indicator: a pair of codepoints indicating some flags
const REGIONAL_INDICATOR = [0x1f1e6, 0x1f1ff];
function isEmojiCombinator(code) {
    // Zero-width joiner
    if (code === ZWJ)
        return true;
    // VS-15: text presentation, VS-16: Emoji presentation
    if (code === 0xfe0e || code === 0xfe0f)
        return true;
    // EMOJI_MODIFIER_FITZPATRICK_TYPE 1-6
    if (code >= 0x1f3fb && code <= 0x1f3fb + 5)
        return true;
    // Red hair..white hair
    if (code >= 0x1f9b0 && code <= 0x1f9b0 + 4)
        return true;
    // EMOJI_TAG
    if (code >= 0xe0020 && code <= 0xe0020 + 96)
        return true;
    return false;
}
function isRegionalIndicator(code) {
    return code >= REGIONAL_INDICATOR[0] && code <= REGIONAL_INDICATOR[1];
}
/**
 * Return a string or an array of graphemes.
 *
 * This includes:
 * - emoji with skin and hair modifiers
 * - emoji combination (for example "female pilot")
 * - text emoji with an emoji presentation style modifier
 *      - U+1F512 U+FE0E 🔒︎
 *      - U+1F512 U+FE0F 🔒️
 * - flags represented as two regional indicator codepoints
 * - flags represented as a flag emoji + zwj + an emoji tag
 * - other combinations (for example, rainbow flag)
 */
function splitGraphemes(string) {
    // If it's all ASCII, short-circuit the grapheme splitting...
    if (/^[\u0020-\u00FF]*$/.test(string))
        return string;
    const result = [];
    const codePoints = stringToCodepoints(string);
    let index = 0;
    while (index < codePoints.length) {
        const code = codePoints[index++];
        const next = codePoints[index];
        // Combine sequences
        if (next === ZWJ) {
            // Zero-width joiner sequences are:
            // ZWJ_SEQUENCE := (CHAR + ZWJ)+
            const baseIndex = index - 1;
            index += 2;
            while (codePoints[index] === ZWJ) {
                index += 2;
            }
            result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex + 1)));
        }
        else if (isEmojiCombinator(next)) {
            // Combine emoji sequences
            // See http://unicode.org/reports/tr51/#def_emoji_tag_sequence
            const baseIndex = index - 1; // The previous character is the 'base'
            while (isEmojiCombinator(codePoints[index])) {
                index += codePoints[index] === ZWJ ? 2 : 1;
            }
            result.push(String.fromCodePoint(...codePoints.slice(baseIndex, 2 * index - baseIndex - 1)));
        }
        else if (isRegionalIndicator(code)) {
            // Some (but not all) flags are represented by a sequence of two
            // "regional indicators" codepoints.
            index += 1;
            result.push(String.fromCodePoint(...codePoints.slice(index - 2, 2)));
        }
        else {
            result.push(String.fromCodePoint(code));
        }
    }
    return result;
}

/**
 * ## Reference
 * TeX source code:
 * {@link  http://tug.org/texlive/devsrc/Build/source/texk/web2c/tex.web | Tex.web}
 *
 */
/**
 * Given a LaTeX expression represented as a character string,
 * the Lexer class will scan and return Tokens for the lexical
 * units in the string.
 *
 * @param s A string of LaTeX
 */
class Tokenizer {
    constructor(s) {
        this.obeyspaces = false;
        this.s = splitGraphemes(s);
        this.pos = 0;
    }
    /**
     * @return True if we reached the end of the stream
     */
    end() {
        return this.pos >= this.s.length;
    }
    /**
     * Return the next char and advance
     */
    get() {
        return this.pos < this.s.length ? this.s[this.pos++] : '';
    }
    /**
     * Return the next char, but do not advance
     */
    peek() {
        return this.s[this.pos];
    }
    /**
     * Return the next substring matching regEx and advance.
     */
    match(regEx) {
        // this.s can either be a string, if it's made up only of ASCII chars
        // or an array of graphemes, if it's more complicated.
        let execResult;
        if (typeof this.s === 'string') {
            execResult = regEx.exec(this.s.slice(this.pos));
        }
        else {
            execResult = regEx.exec(this.s.slice(this.pos).join(''));
        }
        if (execResult === null || execResult === void 0 ? void 0 : execResult[0]) {
            this.pos += execResult[0].length;
            return execResult[0];
        }
        return null;
    }
    /**
     * Return the next token, or null.
     */
    next() {
        // If we've reached the end, exit
        if (this.end())
            return null;
        // Handle white space
        // In text mode, spaces are significant,
        // however they are coalesced unless \obeyspaces
        if (!this.obeyspaces && this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]+/)) {
            // Note that browsers are inconsistent in their definitions of the
            // `\s` metacharacter, so we use an explicit pattern instead.
            // - IE:          `[ \f\n\r\t\v]`
            // - Chrome:      `[ \f\n\r\t\v\u00A0]`
            // - Firefox:     `[ \f\n\r\t\v\u00A0\u2028\u2029]`
            // - \f \u000C: form feed (FORM FEED)
            // - \n \u000A: linefeed (LINE FEED)
            // - \r \u000D: carriage return
            // - \t \u0009: tab (CHARACTER TABULATION)
            // - \v \u000B: vertical tab (LINE TABULATION)
            // - \u00A0: NON-BREAKING SPACE
            // - \u2028: LINE SEPARATOR
            // - \u2029: PARAGRAPH SEPARATOR
            return '<space>';
        }
        else if (this.obeyspaces &&
            this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]/)) {
            // Don't coalesce when this.obeyspaces is true (different regex from above)
            return '<space>';
        }
        const next = this.get();
        // Is it a command?
        if (next === '\\') {
            if (!this.end()) {
                // A command is either a string of letters and asterisks...
                let command = this.match(/^[a-zA-Z*]+/);
                if (command) {
                    // Spaces after a 'control word' are ignored
                    // (but not after a 'control symbol' (single char)
                    this.match(/^[ \f\n\r\t\v\xA0\u2028\u2029]*/);
                }
                else {
                    // ... or a single non-letter character
                    command = this.get();
                    if (command === ' ') {
                        // The `\ ` command is equivalent to a single space
                        return '<space>';
                    }
                }
                return '\\' + command;
            }
        }
        else if (next === '{') {
            // This is a group start
            return '<{>';
        }
        else if (next === '}') {
            // This is a group end
            return '<}>';
        }
        else if (next === '^') {
            if (this.peek() === '^') {
                // It might be a ^^ command (inline hex character)
                this.get();
                // There can be zero to six carets with the same number of hex digits
                const hex = this.match(/^(\^(\^(\^(\^[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f])?[0-9a-f][0-9a-f]/);
                if (hex) {
                    return String.fromCodePoint(parseInt(hex.slice(hex.lastIndexOf('^') + 1), 16));
                }
            }
            return next;
        }
        else if (next === '#') {
            // This could be either a param token, or a literal # (used for
            // colorspecs, for example). A param token is a '#' followed by
            // - a digit 0-9 followed by a non-alpha, non-digit
            // - or '?'.
            // Otherwise, it's a literal '#'.
            if (!this.end()) {
                let isParam = false;
                if (/[0-9?]/.test(this.peek())) {
                    // Could be a param
                    isParam = true;
                    // Need to look ahead to the following char
                    if (this.pos + 1 < this.s.length) {
                        const after = this.s[this.pos + 1];
                        isParam = /[^0-9A-Za-z]/.test(after);
                    }
                }
                if (isParam) {
                    return '#' + this.get();
                }
                return '#';
            }
        }
        else if (next === '$') {
            // Mode switch
            if (this.peek() === '$') {
                // $$
                this.get();
                return '<$$>';
            }
            // $
            return '<$>';
        }
        return next;
    }
}
// Some primitive commands need to be handled in the expansion phase
// (the 'gullet')
function expand(lex, args) {
    var _a, _b, _c, _d;
    let result = [];
    let token = lex.next();
    if (token) {
        if (token === '\\relax') ;
        else if (token === '\\noexpand') {
            // Do not expand the next token
            token = lex.next();
            if (token) {
                result.push(token);
            }
        }
        else if (token === '\\obeyspaces') {
            lex.obeyspaces = true;
        }
        else if (token === '\\space' || token === '~') {
            // The `\space` command is equivalent to a single space
            // The ~ is an 'active character' (a single character macro)
            // that maps to <space>
            result.push('<space>');
        }
        else if (token === '\\bgroup') {
            // Begin group, synonym for opening brace
            result.push('<{>');
        }
        else if (token === '\\egroup') {
            // End group, synonym for closing brace
            result.push('<}>');
        }
        else if (token === '\\string') {
            // Turn the next token into a string
            token = lex.next();
            if (token) {
                if (token[0] === '\\') {
                    Array.from(token).forEach((x) => result.push(x === '\\' ? '\\backslash' : x));
                }
                else if (token === '<{>') {
                    result.push('\\{');
                }
                else if (token === '<space>') {
                    result.push('~');
                }
                else if (token === '<}>') {
                    result.push('\\}');
                }
            }
        }
        else if (token === '\\csname') {
            // Turn the next tokens, until `\endcsname`, into a command
            while (lex.peek() === '<space>') {
                lex.next();
            }
            let command = '';
            let done = false;
            let tokens = [];
            do {
                if (tokens.length === 0) {
                    // We're out of tokens to look at, get some more
                    if (/^#[0-9?]$/.test(lex.peek())) {
                        // Expand parameters (but not commands)
                        const param = lex.get().slice(1);
                        tokens = tokenize((_b = (_a = args === null || args === void 0 ? void 0 : args[param]) !== null && _a !== void 0 ? _a : args === null || args === void 0 ? void 0 : args['?']) !== null && _b !== void 0 ? _b : '\\placeholder{}', args);
                        token = tokens[0];
                    }
                    else {
                        token = lex.next();
                        tokens = token ? [token] : [];
                    }
                }
                done = tokens.length === 0;
                if (!done && token === '\\endcsname') {
                    done = true;
                    tokens.shift();
                }
                if (!done) {
                    done =
                        token === '<$>' ||
                            token === '<$$>' ||
                            token === '<{>' ||
                            token === '<}>' ||
                            (!!token && token.length > 1 && token[0] === '\\');
                }
                if (!done) {
                    command += tokens.shift();
                }
            } while (!done);
            if (command) {
                result.push('\\' + command);
            }
            result = result.concat(tokens);
        }
        else if (token === '\\endcsname') ;
        else if (token.length > 1 && token[0] === '#') {
            // It's a parameter to expand
            const param = token.slice(1);
            result = result.concat(tokenize((_d = (_c = args === null || args === void 0 ? void 0 : args[param]) !== null && _c !== void 0 ? _c : args === null || args === void 0 ? void 0 : args['?']) !== null && _d !== void 0 ? _d : '\\placeholder{}', args));
        }
        else {
            result.push(token);
        }
    }
    return result;
}
/**
 * Create Tokens from a stream of LaTeX
 *
 * @param s - A string of LaTeX. It can include comments (with the `%`
 * marker) and multiple lines.
 */
function tokenize(s, args) {
    // Merge multiple lines into one, and remove comments
    const lines = s.toString().split(/\r?\n/);
    let stream = '';
    let sep = '';
    for (const line of lines) {
        stream += sep;
        sep = ' ';
        // Remove everything after a % (comment marker)
        // (but \% should be preserved...)
        const m = line.match(/((?:\\%)|[^%])*/);
        if (m !== null)
            stream += m[0];
    }
    const tokenizer = new Tokenizer(stream);
    let result = [];
    do {
        result = result.concat(expand(tokenizer, args));
    } while (!tokenizer.end());
    return result;
}
function joinLatex(segments) {
    let sep = '';
    let result = '';
    for (const segment of segments) {
        if (segment) {
            if (/[a-zA-Z*]/.test(segment[0])) {
                // If the segment begins with a char that *could* be in a command
                // name... insert a separator (if one was needed for the previous segment)
                result += sep;
            }
            // If the segment ends in a command...
            if (/\\[a-zA-Z]+\*?$/.test(segment)) {
                // ... potentially add a space before the next segment
                sep = ' ';
            }
            else {
                sep = '';
            }
            result += segment;
        }
    }
    return result;
}
function tokensToString(tokens) {
    let flat = [];
    if (Array.isArray(tokens)) {
        for (const item of tokens) {
            if (Array.isArray(item)) {
                flat = [...flat, ...item];
            }
            else {
                flat.push(item);
            }
        }
    }
    else {
        flat = [tokens];
    }
    const result = joinLatex(flat.map((token) => {
        var _a;
        return ((_a = {
            '<space>': ' ',
            '<$$>': '$$',
            '<$>': '$',
            '<{>': '{',
            '<}>': '}',
        }[token]) !== null && _a !== void 0 ? _a : token);
    }));
    return result;
}

const DEFINITIONS_INEQUALITIES = [
    {
        name: 'NotLess',
        trigger: { infix: ['!', '<'] },
        associativity: 'right',
        precedence: 246,
    },
    {
        name: 'NotLess',
        trigger: { infix: '\\nless' },
        associativity: 'right',
        precedence: 246,
    },
    {
        name: 'Less',
        trigger: { infix: '<' },
        associativity: 'right',
        precedence: 245,
    },
    {
        name: 'Less',
        trigger: { infix: '\\lt' },
        associativity: 'right',
        precedence: 245,
    },
    {
        name: 'LessEqual',
        trigger: { infix: ['<', '='] },
        associativity: 'right',
        precedence: 241,
    },
    {
        name: 'LessEqual',
        trigger: { infix: '\\le' },
        associativity: 'right',
        precedence: 241,
    },
    {
        name: 'LessEqual',
        trigger: { infix: '\\leq' },
        associativity: 'right',
        precedence: 241,
    },
    {
        name: 'LessEqual',
        trigger: { infix: '\\leqslant' },
        associativity: 'right',
        precedence: 265, // Note different precendence than `<=` as per MathML
    },
    {
        name: 'LessNotEqual',
        trigger: { infix: '\\lneqq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotLessNotEqual',
        trigger: { infix: '\\nleqq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'LessOverEqual',
        trigger: { infix: '\\leqq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'GreaterOverEqual',
        trigger: { infix: '\\geqq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'Equal',
        trigger: { infix: '=' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'StarEqual',
        trigger: { infix: ['*', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'StarEqual',
        trigger: { infix: ['\\star', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'PlusEqual',
        trigger: { infix: ['+', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MinusEqual',
        trigger: { infix: ['-', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'SlashEqual',
        trigger: { infix: ['/', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'EqualEqual',
        trigger: { infix: ['=', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'EqualEqualEqual',
        trigger: { infix: ['=', '=', '='] },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'TildeFullEqual',
        trigger: { infix: '\\cong' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotTildeFullEqual',
        trigger: { infix: '\\ncong' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Assign',
        trigger: { infix: [':', '='] },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Assign',
        trigger: { infix: '\\coloneq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Approx',
        trigger: { infix: '\\approx' },
        associativity: 'right',
        precedence: 247,
    },
    {
        name: 'NotApprox',
        trigger: { infix: '\\approx' },
        associativity: 'right',
        precedence: 247,
    },
    {
        name: 'ApproxEqual',
        trigger: { infix: '\\approxeq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotApproxEqual',
        trigger: { infix: ['!', '\\approxeq'] },
        associativity: 'right',
        precedence: 250,
    },
    {
        name: 'NotEqual',
        trigger: { infix: '\\ne' },
        associativity: 'right',
        precedence: 255,
    },
    {
        name: 'Unequal',
        trigger: { infix: ['!', '='] },
        associativity: 'right',
        precedence: 260, // Note different precendence than \\ne per MathML
    },
    {
        name: 'GreaterEqual',
        trigger: { infix: '\\ge' },
        associativity: 'right',
        precedence: 242, // Note: different precendence than `>=` as per MathML
    },
    {
        name: 'GreaterEqual',
        trigger: { infix: '\\geq' },
        associativity: 'right',
        precedence: 242, // Note: different precendence than `>=` as per MathML
    },
    {
        name: 'GreaterEqual',
        trigger: { infix: ['>', '='] },
        associativity: 'right',
        precedence: 243,
    },
    {
        name: 'GreaterEqual',
        trigger: { infix: '\\geqslant' },
        associativity: 'right',
        precedence: 265, // Note: different precendence than `>=` as per MathML
    },
    {
        name: 'GreaterNotEqual',
        trigger: { infix: '\\gneqq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotGreaterNotEqual',
        trigger: { infix: '\\ngeqq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Greater',
        trigger: { infix: '>' },
        associativity: 'right',
        precedence: 245,
    },
    {
        name: 'Greater',
        trigger: { infix: '\\gt' },
        associativity: 'right',
        precedence: 245,
    },
    {
        name: 'NotGreater',
        trigger: { infix: '\\ngtr' },
        associativity: 'right',
        precedence: 244,
    },
    {
        name: 'NotGreater',
        trigger: { infix: ['!', '>'] },
        associativity: 'right',
        precedence: 244,
    },
    {
        name: 'RingEqual',
        trigger: { infix: '\\circeq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'TriangleEqual',
        trigger: { infix: '\\triangleq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'DotEqual',
        trigger: { infix: '\\doteq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'DotEqualDot',
        trigger: { infix: '\\doteqdot' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'FallingDotEqual',
        trigger: { infix: '\\fallingdotseq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'RisingDotEqual',
        trigger: { infix: '\\fallingdotseq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'QuestionEqual',
        trigger: { infix: '\\questeq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Equivalent',
        trigger: { infix: '\\equiv' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MuchLess',
        trigger: { infix: '\\ll' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'MuchGreater',
        trigger: { infix: '\\gg' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Precedes',
        trigger: { infix: '\\prec' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Succeeds',
        trigger: { infix: '\\succ' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'PrecedesEqual',
        trigger: { infix: '\\preccurlyeq' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'SucceedsEqual',
        trigger: { infix: '\\curlyeqprec' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotPrecedes',
        trigger: { infix: '\\nprec' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'NotSucceeds',
        trigger: { infix: '\\nsucc' },
        associativity: 'right',
        precedence: 260,
    },
    {
        name: 'Between',
        trigger: { infix: '\\between' },
        associativity: 'right',
        precedence: 265,
    },
];

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var decimal = {exports: {}};

(function (module) {
(function (globalScope) {


  /*
   *  decimal.js v10.2.1
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   */


  // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //


    // The maximum exponent magnitude.
    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.
  var EXP_LIMIT = 9e15,                      // 0 to 9e15

    // The limit on the value of `precision`, and on the value of the first argument to
    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.
    MAX_DIGITS = 1e9,                        // 0 to 1e9

    // Base conversion alphabet.
    NUMERALS = '0123456789abcdef',

    // The natural logarithm of 10 (1025 digits).
    LN10 = '2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058',

    // Pi (1025 digits).
    PI = '3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789',


    // The initial configuration properties of the Decimal constructor.
    DEFAULTS = {

      // These values must be integers within the stated ranges (inclusive).
      // Most of these values can be changed at run-time using the `Decimal.config` method.

      // The maximum number of significant digits of the result of a calculation or base conversion.
      // E.g. `Decimal.config({ precision: 20 });`
      precision: 20,                         // 1 to MAX_DIGITS

      // The rounding mode used when rounding to `precision`.
      //
      // ROUND_UP         0 Away from zero.
      // ROUND_DOWN       1 Towards zero.
      // ROUND_CEIL       2 Towards +Infinity.
      // ROUND_FLOOR      3 Towards -Infinity.
      // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
      // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
      // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
      // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
      // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
      //
      // E.g.
      // `Decimal.rounding = 4;`
      // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
      rounding: 4,                           // 0 to 8

      // The modulo mode used when calculating the modulus: a mod n.
      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
      // The remainder (r) is calculated as: r = a - n * q.
      //
      // UP         0 The remainder is positive if the dividend is negative, else is negative.
      // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
      // FLOOR      3 The remainder has the same sign as the divisor (Python %).
      // HALF_EVEN  6 The IEEE 754 remainder function.
      // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
      //
      // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
      // division (9) are commonly used for the modulus operation. The other rounding modes can also
      // be used, but they may not give useful results.
      modulo: 1,                             // 0 to 9

      // The exponent value at and beneath which `toString` returns exponential notation.
      // JavaScript numbers: -7
      toExpNeg: -7,                          // 0 to -EXP_LIMIT

      // The exponent value at and above which `toString` returns exponential notation.
      // JavaScript numbers: 21
      toExpPos:  21,                         // 0 to EXP_LIMIT

      // The minimum exponent value, beneath which underflow to zero occurs.
      // JavaScript numbers: -324  (5e-324)
      minE: -EXP_LIMIT,                      // -1 to -EXP_LIMIT

      // The maximum exponent value, above which overflow to Infinity occurs.
      // JavaScript numbers: 308  (1.7976931348623157e+308)
      maxE: EXP_LIMIT,                       // 1 to EXP_LIMIT

      // Whether to use cryptographically-secure random number generation, if available.
      crypto: false                          // true/false
    },


  // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //


    Decimal, inexact, noConflict, quadrant,
    external = true,

    decimalError = '[DecimalError] ',
    invalidArgument = decimalError + 'Invalid argument: ',
    precisionLimitExceeded = decimalError + 'Precision limit exceeded',
    cryptoUnavailable = decimalError + 'crypto unavailable',

    mathfloor = Math.floor,
    mathpow = Math.pow,

    isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i,
    isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i,
    isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i,
    isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i,

    BASE = 1e7,
    LOG_BASE = 7,
    MAX_SAFE_INTEGER = 9007199254740991,

    LN10_PRECISION = LN10.length - 1,
    PI_PRECISION = PI.length - 1,

    // Decimal.prototype object
    P = { name: '[object Decimal]' };


  // Decimal prototype methods


  /*
   *  absoluteValue             abs
   *  ceil
   *  comparedTo                cmp
   *  cosine                    cos
   *  cubeRoot                  cbrt
   *  decimalPlaces             dp
   *  dividedBy                 div
   *  dividedToIntegerBy        divToInt
   *  equals                    eq
   *  floor
   *  greaterThan               gt
   *  greaterThanOrEqualTo      gte
   *  hyperbolicCosine          cosh
   *  hyperbolicSine            sinh
   *  hyperbolicTangent         tanh
   *  inverseCosine             acos
   *  inverseHyperbolicCosine   acosh
   *  inverseHyperbolicSine     asinh
   *  inverseHyperbolicTangent  atanh
   *  inverseSine               asin
   *  inverseTangent            atan
   *  isFinite
   *  isInteger                 isInt
   *  isNaN
   *  isNegative                isNeg
   *  isPositive                isPos
   *  isZero
   *  lessThan                  lt
   *  lessThanOrEqualTo         lte
   *  logarithm                 log
   *  [maximum]                 [max]
   *  [minimum]                 [min]
   *  minus                     sub
   *  modulo                    mod
   *  naturalExponential        exp
   *  naturalLogarithm          ln
   *  negated                   neg
   *  plus                      add
   *  precision                 sd
   *  round
   *  sine                      sin
   *  squareRoot                sqrt
   *  tangent                   tan
   *  times                     mul
   *  toBinary
   *  toDecimalPlaces           toDP
   *  toExponential
   *  toFixed
   *  toFraction
   *  toHexadecimal             toHex
   *  toNearest
   *  toNumber
   *  toOctal
   *  toPower                   pow
   *  toPrecision
   *  toSignificantDigits       toSD
   *  toString
   *  truncated                 trunc
   *  valueOf                   toJSON
   */


  /*
   * Return a new Decimal whose value is the absolute value of this Decimal.
   *
   */
  P.absoluteValue = P.abs = function () {
    var x = new this.constructor(this);
    if (x.s < 0) x.s = 1;
    return finalise(x);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of positive Infinity.
   *
   */
  P.ceil = function () {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };


  /*
   * Return
   *   1    if the value of this Decimal is greater than the value of `y`,
   *  -1    if the value of this Decimal is less than the value of `y`,
   *   0    if they have the same value,
   *   NaN  if the value of either Decimal is NaN.
   *
   */
  P.comparedTo = P.cmp = function (y) {
    var i, j, xdL, ydL,
      x = this,
      xd = x.d,
      yd = (y = new x.constructor(y)).d,
      xs = x.s,
      ys = y.s;

    // Either NaN or ±Infinity?
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }

    // Either zero?
    if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;

    // Signs differ?
    if (xs !== ys) return xs;

    // Compare exponents.
    if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;

    xdL = xd.length;
    ydL = yd.length;

    // Compare digit by digit.
    for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
      if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
    }

    // Compare lengths.
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };


  /*
   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * cos(0)         = 1
   * cos(-0)        = 1
   * cos(Infinity)  = NaN
   * cos(-Infinity) = NaN
   * cos(NaN)       = NaN
   *
   */
  P.cosine = P.cos = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.d) return new Ctor(NaN);

    // cos(0) = cos(-0) = 1
    if (!x.d[0]) return new Ctor(1);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };


  /*
   *
   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   *  cbrt(0)  =  0
   *  cbrt(-0) = -0
   *  cbrt(1)  =  1
   *  cbrt(-1) = -1
   *  cbrt(N)  =  N
   *  cbrt(-I) = -I
   *  cbrt(I)  =  I
   *
   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))
   *
   */
  P.cubeRoot = P.cbrt = function () {
    var e, m, n, r, rep, s, sd, t, t3, t3plusx,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);
    external = false;

    // Initial estimate.
    s = x.s * mathpow(x.s * x, 1 / 3);

     // Math.cbrt underflow/overflow?
     // Pass x to Math.pow as integer, then adjust the exponent of the result.
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e = x.e;

      // Adjust n exponent so it is a multiple of 3 away from x exponent.
      if (s = (e - n.length + 1) % 3) n += (s == 1 || s == -2 ? '0' : '00');
      s = mathpow(n, 1 / 3);

      // Rarely, e may be one less than the result exponent value.
      e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Halley's method.
    // TODO? Compare Newton's method.
    for (;;) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999
        // , i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return the number of decimal places of the value of this Decimal.
   *
   */
  P.decimalPlaces = P.dp = function () {
    var w,
      d = this.d,
      n = NaN;

    if (d) {
      w = d.length - 1;
      n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;

      // Subtract the number of trailing zeros of the last word.
      w = d[w];
      if (w) for (; w % 10 == 0; w /= 10) n--;
      if (n < 0) n = 0;
    }

    return n;
  };


  /*
   *  n / 0 = I
   *  n / N = N
   *  n / I = 0
   *  0 / n = 0
   *  0 / 0 = N
   *  0 / N = N
   *  0 / I = 0
   *  N / n = N
   *  N / 0 = N
   *  N / N = N
   *  N / I = N
   *  I / n = I
   *  I / 0 = I
   *  I / N = N
   *  I / I = N
   *
   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedBy = P.div = function (y) {
    return divide(this, new this.constructor(y));
  };


  /*
   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal
   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.dividedToIntegerBy = P.divToInt = function (y) {
    var x = this,
      Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };


  /*
   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.
   *
   */
  P.equals = P.eq = function (y) {
    return this.cmp(y) === 0;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the
   * direction of negative Infinity.
   *
   */
  P.floor = function () {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };


  /*
   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return
   * false.
   *
   */
  P.greaterThan = P.gt = function (y) {
    return this.cmp(y) > 0;
  };


  /*
   * Return true if the value of this Decimal is greater than or equal to the value of `y`,
   * otherwise return false.
   *
   */
  P.greaterThanOrEqualTo = P.gte = function (y) {
    var k = this.cmp(y);
    return k == 1 || k === 0;
  };


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [1, Infinity]
   *
   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...
   *
   * cosh(0)         = 1
   * cosh(-0)        = 1
   * cosh(Infinity)  = Infinity
   * cosh(-Infinity) = Infinity
   * cosh(NaN)       = NaN
   *
   *  x        time taken (ms)   result
   * 1000      9                 9.8503555700852349694e+433
   * 10000     25                4.4034091128314607936e+4342
   * 100000    171               1.4033316802130615897e+43429
   * 1000000   3817              1.5166076984010437725e+434294
   * 10000000  abandoned after 2 minute wait
   *
   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))
   *
   */
  P.hyperbolicCosine = P.cosh = function () {
    var k, n, pr, rm, len,
      x = this,
      Ctor = x.constructor,
      one = new Ctor(1);

    if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero()) return one;

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1
    // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))

    // Estimate the optimum number of times to use the argument reduction.
    // TODO? Estimation reused from cosine() and may not be optimal here.
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = '2.3283064365386962890625e-10';
    }

    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);

    // Reverse argument reduction
    var cosh2_x,
      i = k,
      d8 = new Ctor(8);
    for (; i--;) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }

    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...
   *
   * sinh(0)         = 0
   * sinh(-0)        = -0
   * sinh(Infinity)  = Infinity
   * sinh(-Infinity) = -Infinity
   * sinh(NaN)       = NaN
   *
   * x        time taken (ms)
   * 10       2 ms
   * 100      5 ms
   * 1000     14 ms
   * 10000    82 ms
   * 100000   886 ms            1.4033316802130615897e+43429
   * 200000   2613 ms
   * 300000   5407 ms
   * 400000   8824 ms
   * 500000   13026 ms          8.7080643612718084129e+217146
   * 1000000  48543 ms
   *
   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))
   *
   */
  P.hyperbolicSine = P.sinh = function () {
    var k, pr, rm, len,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;

    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {

      // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))
      // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))
      // 3 multiplications and 1 addition

      // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))
      // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))
      // 4 multiplications and 2 additions

      // Estimate the optimum number of times to use the argument reduction.
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;

      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);

      // Reverse argument reduction
      var sinh2_x,
        d5 = new Ctor(5),
        d16 = new Ctor(16),
        d20 = new Ctor(20);
      for (; k--;) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * tanh(x) = sinh(x) / cosh(x)
   *
   * tanh(0)         = 0
   * tanh(-0)        = -0
   * tanh(Infinity)  = 1
   * tanh(-Infinity) = -1
   * tanh(NaN)       = NaN
   *
   */
  P.hyperbolicTangent = P.tanh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(x.s);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;

    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };


  /*
   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of
   * this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [0, pi]
   *
   * acos(x) = pi/2 - asin(x)
   *
   * acos(0)       = pi/2
   * acos(-0)      = pi/2
   * acos(1)       = 0
   * acos(-1)      = pi
   * acos(1/2)     = pi/3
   * acos(-1/2)    = 2*pi/3
   * acos(|x| > 1) = NaN
   * acos(NaN)     = NaN
   *
   */
  P.inverseCosine = P.acos = function () {
    var halfPi,
      x = this,
      Ctor = x.constructor,
      k = x.abs().cmp(1),
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (k !== -1) {
      return k === 0
        // |x| is 1
        ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0)
        // |x| > 1 or x is NaN
        : new Ctor(NaN);
    }

    if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);

    // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return halfPi.minus(x);
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the
   * value of this Decimal.
   *
   * Domain: [1, Infinity]
   * Range: [0, Infinity]
   *
   * acosh(x) = ln(x + sqrt(x^2 - 1))
   *
   * acosh(x < 1)     = NaN
   * acosh(NaN)       = NaN
   * acosh(Infinity)  = Infinity
   * acosh(-Infinity) = NaN
   * acosh(0)         = NaN
   * acosh(-0)        = NaN
   * acosh(1)         = 0
   * acosh(-1)        = NaN
   *
   */
  P.inverseHyperbolicCosine = P.acosh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).minus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * asinh(x) = ln(x + sqrt(x^2 + 1))
   *
   * asinh(NaN)       = NaN
   * asinh(Infinity)  = Infinity
   * asinh(-Infinity) = -Infinity
   * asinh(0)         = 0
   * asinh(-0)        = -0
   *
   */
  P.inverseHyperbolicSine = P.asinh = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite() || x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;

    x = x.times(x).plus(1).sqrt().plus(x);

    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.ln();
  };


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the
   * value of this Decimal.
   *
   * Domain: [-1, 1]
   * Range: [-Infinity, Infinity]
   *
   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))
   *
   * atanh(|x| > 1)   = NaN
   * atanh(NaN)       = NaN
   * atanh(Infinity)  = NaN
   * atanh(-Infinity) = NaN
   * atanh(0)         = 0
   * atanh(-0)        = -0
   * atanh(1)         = Infinity
   * atanh(-1)        = -Infinity
   *
   */
  P.inverseHyperbolicTangent = P.atanh = function () {
    var pr, rm, wpr, xsd,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();

    if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);

    Ctor.precision = wpr = xsd - x.e;

    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);

    Ctor.precision = pr + 4;
    Ctor.rounding = 1;

    x = x.ln();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(0.5);
  };


  /*
   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this
   * Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))
   *
   * asin(0)       = 0
   * asin(-0)      = -0
   * asin(1/2)     = pi/6
   * asin(-1/2)    = -pi/6
   * asin(1)       = pi/2
   * asin(-1)      = -pi/2
   * asin(|x| > 1) = NaN
   * asin(NaN)     = NaN
   *
   * TODO? Compare performance of Taylor series.
   *
   */
  P.inverseSine = P.asin = function () {
    var halfPi, k,
      pr, rm,
      x = this,
      Ctor = x.constructor;

    if (x.isZero()) return new Ctor(x);

    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (k !== -1) {

      // |x| is 1
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }

      // |x| > 1 or x is NaN
      return new Ctor(NaN);
    }

    // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6

    Ctor.precision = pr + 6;
    Ctor.rounding = 1;

    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return x.times(2);
  };


  /*
   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value
   * of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi/2, pi/2]
   *
   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
   *
   * atan(0)         = 0
   * atan(-0)        = -0
   * atan(1)         = pi/4
   * atan(-1)        = -pi/4
   * atan(Infinity)  = pi/2
   * atan(-Infinity) = -pi/2
   * atan(NaN)       = NaN
   *
   */
  P.inverseTangent = P.atan = function () {
    var i, j, k, n, px, t, r, wpr, x2,
      x = this,
      Ctor = x.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding;

    if (!x.isFinite()) {
      if (!x.s) return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }

    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;

    // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);

    // Argument reduction
    // Ensure |x| < 0.42
    // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))

    k = Math.min(28, wpr / LOG_BASE + 2 | 0);

    for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));

    external = false;

    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;

    // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...
    for (; i !== -1;) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));

      px = px.times(x2);
      r = t.plus(px.div(n += 2));

      if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--;);
    }

    if (k) r = r.times(2 << (k - 1));

    external = true;

    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };


  /*
   * Return true if the value of this Decimal is a finite number, otherwise return false.
   *
   */
  P.isFinite = function () {
    return !!this.d;
  };


  /*
   * Return true if the value of this Decimal is an integer, otherwise return false.
   *
   */
  P.isInteger = P.isInt = function () {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };


  /*
   * Return true if the value of this Decimal is NaN, otherwise return false.
   *
   */
  P.isNaN = function () {
    return !this.s;
  };


  /*
   * Return true if the value of this Decimal is negative, otherwise return false.
   *
   */
  P.isNegative = P.isNeg = function () {
    return this.s < 0;
  };


  /*
   * Return true if the value of this Decimal is positive, otherwise return false.
   *
   */
  P.isPositive = P.isPos = function () {
    return this.s > 0;
  };


  /*
   * Return true if the value of this Decimal is 0 or -0, otherwise return false.
   *
   */
  P.isZero = function () {
    return !!this.d && this.d[0] === 0;
  };


  /*
   * Return true if the value of this Decimal is less than `y`, otherwise return false.
   *
   */
  P.lessThan = P.lt = function (y) {
    return this.cmp(y) < 0;
  };


  /*
   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.
   *
   */
  P.lessThanOrEqualTo = P.lte = function (y) {
    return this.cmp(y) < 1;
  };


  /*
   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * If no base is specified, return log[10](arg).
   *
   * log[base](arg) = ln(arg) / ln(base)
   *
   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'
   * otherwise:
   *
   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen
   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error
   * between the result and the correctly rounded result will be one ulp (unit in the last place).
   *
   * log[-b](a)       = NaN
   * log[0](a)        = NaN
   * log[1](a)        = NaN
   * log[NaN](a)      = NaN
   * log[Infinity](a) = NaN
   * log[b](0)        = -Infinity
   * log[b](-0)       = -Infinity
   * log[b](-a)       = NaN
   * log[b](1)        = 0
   * log[b](Infinity) = Infinity
   * log[b](NaN)      = NaN
   *
   * [base] {number|string|Decimal} The base of the logarithm.
   *
   */
  P.logarithm = P.log = function (base) {
    var isBase10, d, denominator, k, inf, num, sd, r,
      arg = this,
      Ctor = arg.constructor,
      pr = Ctor.precision,
      rm = Ctor.rounding,
      guard = 5;

    // Default base is 10.
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;

      // Return NaN if base is negative, or non-finite, or is 0 or 1.
      if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);

      isBase10 = base.eq(10);
    }

    d = arg.d;

    // Is arg negative, non-finite, 0 or 1?
    if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
    }

    // The result will have a non-terminating decimal expansion if base is 10 and arg is not an
    // integer power of 10.
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0;) k /= 10;
        inf = k !== 1;
      }
    }

    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);

    // The result will have 5 rounding digits.
    r = divide(num, denominator, sd, 1);

    // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,
    // calculate 10 further digits.
    //
    // If the result is known to have an infinite decimal expansion, repeat this until it is clear
    // that the result is above or below the boundary. Otherwise, if after calculating the 10
    // further digits, the last 14 are nines, round up and assume the result is exact.
    // Also assume the result is exact if the last 14 are zero.
    //
    // Example of a result that will be incorrectly rounded:
    // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...
    // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it
    // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so
    // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal
    // place is still 2.6.
    if (checkRoundingDigits(r.d, k = pr, rm)) {

      do {
        sd += 10;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);

        if (!inf) {

          // Check for 14 nines from the 2nd rounding digit, as the first may be 4.
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }

          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }

    external = true;

    return finalise(r, pr, rm);
  };


  /*
   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.max = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'lt');
  };
   */


  /*
   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.
   *
   * arguments {number|string|Decimal}
   *
  P.min = function () {
    Array.prototype.push.call(arguments, this);
    return maxOrMin(this.constructor, arguments, 'gt');
  };
   */


  /*
   *  n - 0 = n
   *  n - N = N
   *  n - I = -I
   *  0 - n = -n
   *  0 - 0 = 0
   *  0 - N = N
   *  0 - I = -I
   *  N - n = N
   *  N - 0 = N
   *  N - N = N
   *  N - I = N
   *  I - n = I
   *  I - 0 = I
   *  I - N = N
   *  I - I = N
   *
   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.minus = P.sub = function (y) {
    var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return y negated if x is finite and y is ±Infinity.
      else if (x.d) y.s = -y.s;

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with different signs.
      // Return NaN if both are ±Infinity with the same sign.
      else y = new Ctor(y.d || x.s !== y.s ? x : NaN);

      return y;
    }

    // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.plus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return y negated if x is zero and y is non-zero.
      if (yd[0]) y.s = -y.s;

      // Return x if y is zero and x is non-zero.
      else if (xd[0]) y = new Ctor(x);

      // Return zero if both are zero.
      // From IEEE 754 (2008) 6.3: 0 - 0 = -0 - -0 = -0 when rounding to -Infinity.
      else return new Ctor(rm === 3 ? -0 : 0);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    e = mathfloor(y.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);

    xd = xd.slice();
    k = xe - e;

    // If base 1e7 exponents differ...
    if (k) {
      xLTy = k < 0;

      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e = xe;
        len = xd.length;
      }

      // Numbers with massively different exponents would result in a very high number of
      // zeros needing to be prepended, but this can be avoided while still ensuring correct
      // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.
      i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;

      if (k > i) {
        k = i;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents.
      d.reverse();
      for (i = k; i--;) d.push(0);
      d.reverse();

    // Base 1e7 exponents equal.
    } else {

      // Check digits to determine which is the bigger number.

      i = xd.length;
      len = yd.length;
      xLTy = i < len;
      if (xLTy) len = i;

      for (i = 0; i < len; i++) {
        if (xd[i] != yd[i]) {
          xLTy = xd[i] < yd[i];
          break;
        }
      }

      k = 0;
    }

    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y.s = -y.s;
    }

    len = xd.length;

    // Append zeros to `xd` if shorter.
    // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.
    for (i = yd.length - len; i > 0; --i) xd[len++] = 0;

    // Subtract yd from xd.
    for (i = yd.length; i > k;) {

      if (xd[--i] < yd[i]) {
        for (j = i; j && xd[--j] === 0;) xd[j] = BASE - 1;
        --xd[j];
        xd[i] += BASE;
      }

      xd[i] -= yd[i];
    }

    // Remove trailing zeros.
    for (; xd[--len] === 0;) xd.pop();

    // Remove leading zeros and adjust exponent accordingly.
    for (; xd[0] === 0; xd.shift()) --e;

    // Zero?
    if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   *   n % 0 =  N
   *   n % N =  N
   *   n % I =  n
   *   0 % n =  0
   *  -0 % n = -0
   *   0 % 0 =  N
   *   0 % N =  N
   *   0 % I =  0
   *   N % n =  N
   *   N % 0 =  N
   *   N % N =  N
   *   N % I =  N
   *   I % n =  N
   *   I % 0 =  N
   *   I % N =  N
   *   I % I =  N
   *
   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * The result depends on the modulo mode.
   *
   */
  P.modulo = P.mod = function (y) {
    var q,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.
    if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);

    // Return x if y is ±Infinity or x is ±0.
    if (!y.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }

    // Prevent rounding of intermediate calculations.
    external = false;

    if (Ctor.modulo == 9) {

      // Euclidian division: q = sign(y) * floor(x / abs(y))
      // result = x - q * y    where  0 <= result < abs(y)
      q = divide(x, y.abs(), 0, 3, 1);
      q.s *= y.s;
    } else {
      q = divide(x, y, 0, Ctor.modulo, 1);
    }

    q = q.times(y);

    external = true;

    return x.minus(q);
  };


  /*
   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,
   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.naturalExponential = P.exp = function () {
    return naturalExponential(this);
  };


  /*
   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   */
  P.naturalLogarithm = P.ln = function () {
    return naturalLogarithm(this);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by
   * -1.
   *
   */
  P.negated = P.neg = function () {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };


  /*
   *  n + 0 = n
   *  n + N = N
   *  n + I = I
   *  0 + n = n
   *  0 + 0 = 0
   *  0 + N = N
   *  0 + I = I
   *  N + n = N
   *  N + 0 = N
   *  N + N = N
   *  N + I = N
   *  I + n = I
   *  I + 0 = I
   *  I + N = N
   *  I + I = I
   *
   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   */
  P.plus = P.add = function (y) {
    var carry, d, e, i, k, len, pr, rm, xd, yd,
      x = this,
      Ctor = x.constructor;

    y = new Ctor(y);

    // If either is not finite...
    if (!x.d || !y.d) {

      // Return NaN if either is NaN.
      if (!x.s || !y.s) y = new Ctor(NaN);

      // Return x if y is finite and x is ±Infinity.
      // Return x if both are ±Infinity with the same sign.
      // Return NaN if both are ±Infinity with different signs.
      // Return y if x is finite and y is ±Infinity.
      else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);

      return y;
    }

     // If signs differ...
    if (x.s != y.s) {
      y.s = -y.s;
      return x.minus(y);
    }

    xd = x.d;
    yd = y.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;

    // If either is zero...
    if (!xd[0] || !yd[0]) {

      // Return x if y is zero.
      // Return y if y is non-zero.
      if (!yd[0]) y = new Ctor(x);

      return external ? finalise(y, pr, rm) : y;
    }

    // x and y are finite, non-zero numbers with the same sign.

    // Calculate base 1e7 exponents.
    k = mathfloor(x.e / LOG_BASE);
    e = mathfloor(y.e / LOG_BASE);

    xd = xd.slice();
    i = k - e;

    // If base 1e7 exponents differ...
    if (i) {

      if (i < 0) {
        d = xd;
        i = -i;
        len = yd.length;
      } else {
        d = yd;
        e = k;
        len = xd.length;
      }

      // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;

      if (i > len) {
        i = len;
        d.length = 1;
      }

      // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.
      d.reverse();
      for (; i--;) d.push(0);
      d.reverse();
    }

    len = xd.length;
    i = yd.length;

    // If yd is longer than xd, swap xd and yd so xd points to the longer array.
    if (len - i < 0) {
      i = len;
      d = yd;
      yd = xd;
      xd = d;
    }

    // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.
    for (carry = 0; i;) {
      carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
      xd[i] %= BASE;
    }

    if (carry) {
      xd.unshift(carry);
      ++e;
    }

    // Remove trailing zeros.
    // No need to check for zero, as +x + +y != 0 && -x + -y != 0
    for (len = xd.length; xd[--len] == 0;) xd.pop();

    y.d = xd;
    y.e = getBase10Exponent(xd, e);

    return external ? finalise(y, pr, rm) : y;
  };


  /*
   * Return the number of significant digits of the value of this Decimal.
   *
   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.
   *
   */
  P.precision = P.sd = function (z) {
    var k,
      x = this;

    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);

    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k) k = x.e + 1;
    } else {
      k = NaN;
    }

    return k;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using
   * rounding mode `rounding`.
   *
   */
  P.round = function () {
    var x = this,
      Ctor = x.constructor;

    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };


  /*
   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-1, 1]
   *
   * sin(x) = x - x^3/3! + x^5/5! - ...
   *
   * sin(0)         = 0
   * sin(-0)        = -0
   * sin(Infinity)  = NaN
   * sin(-Infinity) = NaN
   * sin(NaN)       = NaN
   *
   */
  P.sine = P.sin = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;

    x = sine(Ctor, toLessThanHalfPi(Ctor, x));

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };


  /*
   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   *  sqrt(-n) =  N
   *  sqrt(N)  =  N
   *  sqrt(-I) =  N
   *  sqrt(I)  =  I
   *  sqrt(0)  =  0
   *  sqrt(-0) = -0
   *
   */
  P.squareRoot = P.sqrt = function () {
    var m, n, sd, r, rep, t,
      x = this,
      d = x.d,
      e = x.e,
      s = x.s,
      Ctor = x.constructor;

    // Negative/NaN/Infinity/zero?
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }

    external = false;

    // Initial estimate.
    s = Math.sqrt(+x);

    // Math.sqrt underflow/overflow?
    // Pass x to Math.sqrt as integer, then adjust the exponent of the result.
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);

      if ((n.length + e) % 2 == 0) n += '0';
      s = Math.sqrt(n);
      e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);

      if (s == 1 / 0) {
        n = '5e' + e;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf('e') + 1) + e;
      }

      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }

    sd = (e = Ctor.precision) + 3;

    // Newton-Raphson iteration.
    for (;;) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);

      // TODO? Replace with for-loop and checkRoundingDigits.
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);

        // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or
        // 4999, i.e. approaching a rounding boundary, continue the iteration.
        if (n == '9999' || !rep && n == '4999') {

          // On the first iteration only, check to see if rounding up gives the exact result as the
          // nines may infinitely repeat.
          if (!rep) {
            finalise(t, e + 1, 0);

            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }

          sd += 4;
          rep = 1;
        } else {

          // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.
          // If not, then there are further digits and m will be truthy.
          if (!+n || !+n.slice(1) && n.charAt(0) == '5') {

            // Truncate to the first rounding digit.
            finalise(r, e + 1, 1);
            m = !r.times(r).eq(x);
          }

          break;
        }
      }
    }

    external = true;

    return finalise(r, e, Ctor.rounding, m);
  };


  /*
   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-Infinity, Infinity]
   *
   * tan(0)         = 0
   * tan(-0)        = -0
   * tan(Infinity)  = NaN
   * tan(-Infinity) = NaN
   * tan(NaN)       = NaN
   *
   */
  P.tangent = P.tan = function () {
    var pr, rm,
      x = this,
      Ctor = x.constructor;

    if (!x.isFinite()) return new Ctor(NaN);
    if (x.isZero()) return new Ctor(x);

    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;

    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);

    Ctor.precision = pr;
    Ctor.rounding = rm;

    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };


  /*
   *  n * 0 = 0
   *  n * N = N
   *  n * I = I
   *  0 * n = 0
   *  0 * 0 = 0
   *  0 * N = N
   *  0 * I = N
   *  N * n = N
   *  N * 0 = N
   *  N * N = N
   *  N * I = N
   *  I * n = I
   *  I * 0 = N
   *  I * N = N
   *  I * I = I
   *
   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   */
  P.times = P.mul = function (y) {
    var carry, e, i, k, r, rL, t, xdL, ydL,
      x = this,
      Ctor = x.constructor,
      xd = x.d,
      yd = (y = new Ctor(y)).d;

    y.s *= x.s;

     // If either is NaN, ±Infinity or ±0...
    if (!xd || !xd[0] || !yd || !yd[0]) {

      return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd

        // Return NaN if either is NaN.
        // Return NaN if x is ±0 and y is ±Infinity, or y is ±0 and x is ±Infinity.
        ? NaN

        // Return ±Infinity if either is ±Infinity.
        // Return ±0 if either is ±0.
        : !xd || !yd ? y.s / 0 : y.s * 0);
    }

    e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;

    // Ensure xd points to the longer array.
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }

    // Initialise the result array with zeros.
    r = [];
    rL = xdL + ydL;
    for (i = rL; i--;) r.push(0);

    // Multiply!
    for (i = ydL; --i >= 0;) {
      carry = 0;
      for (k = xdL + i; k > i;) {
        t = r[k] + yd[i] * xd[k - i - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }

      r[k] = (r[k] + carry) % BASE | 0;
    }

    // Remove trailing zeros.
    for (; !r[--rL];) r.pop();

    if (carry) ++e;
    else r.shift();

    y.d = r;
    y.e = getBase10Exponent(r, e);

    return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
  };


  /*
   * Return a string representing the value of this Decimal in base 2, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toBinary = function (sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`
   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.
   *
   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toDecimalPlaces = P.toDP = function (dp, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);
    if (dp === void 0) return x;

    checkInt32(dp, 0, MAX_DIGITS);

    if (rm === void 0) rm = Ctor.rounding;
    else checkInt32(rm, 0, 8);

    return finalise(x, dp + x.e + 1, rm);
  };


  /*
   * Return a string representing the value of this Decimal in exponential notation rounded to
   * `dp` fixed decimal places using rounding mode `rounding`.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toExponential = function (dp, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a string representing the value of this Decimal in normal (fixed-point) notation to
   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is
   * omitted.
   *
   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.
   *
   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
   * (-0).toFixed(3) is '0.000'.
   * (-0.5).toFixed(0) is '-0'.
   *
   */
  P.toFixed = function (dp, rm) {
    var str, y,
      x = this,
      Ctor = x.constructor;

    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      y = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y, false, dp + y.e + 1);
    }

    // To determine whether to add the minus sign look at the value before it was rounded,
    // i.e. look at `x` rather than `y`.
    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return an array representing the value of this Decimal as a simple fraction with an integer
   * numerator and an integer denominator.
   *
   * The denominator will be a positive non-zero value less than or equal to the specified maximum
   * denominator. If a maximum denominator is not specified, the denominator will be the lowest
   * value necessary to represent the number exactly.
   *
   * [maxD] {number|string|Decimal} Maximum denominator. Integer >= 1 and < Infinity.
   *
   */
  P.toFraction = function (maxD) {
    var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r,
      x = this,
      xd = x.d,
      Ctor = x.constructor;

    if (!xd) return new Ctor(x);

    n1 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);

    d = new Ctor(d1);
    e = d.e = getPrecision(xd) - x.e - 1;
    k = e % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);

    if (maxD == null) {

      // d is 10**e, the minimum max-denominator needed.
      maxD = e > 0 ? d : n1;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
      maxD = n.gt(d) ? (e > 0 ? d : n1) : n;
    }

    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e = xd.length * LOG_BASE * 2;

    for (;;)  {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1) break;
      d0 = d1;
      d1 = d2;
      d2 = n1;
      n1 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }

    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n1));
    d0 = d0.plus(d2.times(d1));
    n0.s = n1.s = x.s;

    // Determine which fraction is closer to x, n0/d0 or n1/d1?
    r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1
        ? [n1, d1] : [n0, d0];

    Ctor.precision = pr;
    external = true;

    return r;
  };


  /*
   * Return a string representing the value of this Decimal in base 16, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toHexadecimal = P.toHex = function (sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };


  /*
   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding
   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.
   *
   * The return value will always have the same sign as this Decimal, unless either this Decimal
   * or `y` is NaN, in which case the return value will be also be NaN.
   *
   * The return value is not affected by the value of `precision`.
   *
   * y {number|string|Decimal} The magnitude to round to a multiple of.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toNearest() rounding mode not an integer: {rm}'
   * 'toNearest() rounding mode out of range: {rm}'
   *
   */
  P.toNearest = function (y, rm) {
    var x = this,
      Ctor = x.constructor;

    x = new Ctor(x);

    if (y == null) {

      // If x is not finite, return x.
      if (!x.d) return x;

      y = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y = new Ctor(y);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }

      // If x is not finite, return x if y is not NaN, else NaN.
      if (!x.d) return y.s ? x : y;

      // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.
      if (!y.d) {
        if (y.s) y.s = x.s;
        return y;
      }
    }

    // If y is not zero, calculate the nearest multiple of y to x.
    if (y.d[0]) {
      external = false;
      x = divide(x, y, 0, rm, 1).times(y);
      external = true;
      finalise(x);

    // If y is zero, return zero with the sign of x.
    } else {
      y.s = x.s;
      x = y;
    }

    return x;
  };


  /*
   * Return the value of this Decimal converted to a number primitive.
   * Zero keeps its sign.
   *
   */
  P.toNumber = function () {
    return +this;
  };


  /*
   * Return a string representing the value of this Decimal in base 8, round to `sd` significant
   * digits using rounding mode `rm`.
   *
   * If the optional `sd` argument is present then return binary exponential notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toOctal = function (sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded
   * to `precision` significant digits using rounding mode `rounding`.
   *
   * ECMAScript compliant.
   *
   *   pow(x, NaN)                           = NaN
   *   pow(x, ±0)                            = 1

   *   pow(NaN, non-zero)                    = NaN
   *   pow(abs(x) > 1, +Infinity)            = +Infinity
   *   pow(abs(x) > 1, -Infinity)            = +0
   *   pow(abs(x) == 1, ±Infinity)           = NaN
   *   pow(abs(x) < 1, +Infinity)            = +0
   *   pow(abs(x) < 1, -Infinity)            = +Infinity
   *   pow(+Infinity, y > 0)                 = +Infinity
   *   pow(+Infinity, y < 0)                 = +0
   *   pow(-Infinity, odd integer > 0)       = -Infinity
   *   pow(-Infinity, even integer > 0)      = +Infinity
   *   pow(-Infinity, odd integer < 0)       = -0
   *   pow(-Infinity, even integer < 0)      = +0
   *   pow(+0, y > 0)                        = +0
   *   pow(+0, y < 0)                        = +Infinity
   *   pow(-0, odd integer > 0)              = -0
   *   pow(-0, even integer > 0)             = +0
   *   pow(-0, odd integer < 0)              = -Infinity
   *   pow(-0, even integer < 0)             = +Infinity
   *   pow(finite x < 0, finite non-integer) = NaN
   *
   * For non-integer or very large exponents pow(x, y) is calculated using
   *
   *   x^y = exp(y*ln(x))
   *
   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the
   * probability of an incorrectly rounded result
   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14
   * i.e. 1 in 250,000,000,000,000
   *
   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).
   *
   * y {number|string|Decimal} The power to which to raise this Decimal.
   *
   */
  P.toPower = P.pow = function (y) {
    var e, k, pr, r, rm, s,
      x = this,
      Ctor = x.constructor,
      yn = +(y = new Ctor(y));

    // Either ±Infinity, NaN or ±0?
    if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));

    x = new Ctor(x);

    if (x.eq(1)) return x;

    pr = Ctor.precision;
    rm = Ctor.rounding;

    if (y.eq(1)) return finalise(x, pr, rm);

    // y exponent
    e = mathfloor(y.e / LOG_BASE);

    // If y is a small integer use the 'exponentiation by squaring' algorithm.
    if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }

    s = x.s;

    // if x is negative
    if (s < 0) {

      // if y is not an integer
      if (e < y.d.length - 1) return new Ctor(NaN);

      // Result is positive if x is negative and the last digit of integer y is even.
      if ((y.d[e] & 1) == 0) s = 1;

      // if x.eq(-1)
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }

    // Estimate result exponent.
    // x^y = 10^e,  where e = y * log10(x)
    // log10(x) = log10(x_significand) + x_exponent
    // log10(x_significand) = ln(x_significand) / ln(10)
    k = mathpow(+x, yn);
    e = k == 0 || !isFinite(k)
      ? mathfloor(yn * (Math.log('0.' + digitsToString(x.d)) / Math.LN10 + x.e + 1))
      : new Ctor(k + '').e;

    // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.

    // Overflow/underflow?
    if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);

    external = false;
    Ctor.rounding = x.s = 1;

    // Estimate the extra guard digits needed to ensure five correct rounding digits from
    // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):
    // new Decimal(2.32456).pow('2087987436534566.46411')
    // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815
    k = Math.min(12, (e + '').length);

    // r = x^y = exp(y*ln(x))
    r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);

    // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)
    if (r.d) {

      // Truncate to the required precision plus five rounding digits.
      r = finalise(r, pr + 5, 1);

      // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate
      // the result.
      if (checkRoundingDigits(r.d, pr, rm)) {
        e = pr + 10;

        // Truncate to the increased precision plus five rounding digits.
        r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);

        // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }

    r.s = s;
    external = true;
    Ctor.rounding = rm;

    return finalise(r, pr, rm);
  };


  /*
   * Return a string representing the value of this Decimal rounded to `sd` significant digits
   * using rounding mode `rounding`.
   *
   * Return exponential notation if `sd` is less than the number of digits necessary to represent
   * the integer part of the value in normal notation.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   */
  P.toPrecision = function (sd, rm) {
    var str,
      x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);

      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`
   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if
   * omitted.
   *
   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.
   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.
   *
   * 'toSD() digits out of range: {sd}'
   * 'toSD() digits not an integer: {sd}'
   * 'toSD() rounding mode not an integer: {rm}'
   * 'toSD() rounding mode out of range: {rm}'
   *
   */
  P.toSignificantDigits = P.toSD = function (sd, rm) {
    var x = this,
      Ctor = x.constructor;

    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);

      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    }

    return finalise(new Ctor(x), sd, rm);
  };


  /*
   * Return a string representing the value of this Decimal.
   *
   * Return exponential notation if this Decimal has a positive exponent equal to or greater than
   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.
   *
   */
  P.toString = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() && !x.isZero() ? '-' + str : str;
  };


  /*
   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.
   *
   */
  P.truncated = P.trunc = function () {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };


  /*
   * Return a string representing the value of this Decimal.
   * Unlike `toString`, negative zero will include the minus sign.
   *
   */
  P.valueOf = P.toJSON = function () {
    var x = this,
      Ctor = x.constructor,
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);

    return x.isNeg() ? '-' + str : str;
  };


  /*
  // Add aliases to match BigDecimal method names.
  // P.add = P.plus;
  P.subtract = P.minus;
  P.multiply = P.times;
  P.divide = P.div;
  P.remainder = P.mod;
  P.compareTo = P.cmp;
  P.negate = P.neg;
   */


  // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.


  /*
   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,
   *                           finiteToString, naturalExponential, naturalLogarithm
   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,
   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random
   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm
   *  convertBase              toStringBinary, parseOther
   *  cos                      P.cos
   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,
   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,
   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,
   *                           taylorSeries, atan2, parseOther
   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,
   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,
   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,
   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,
   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,
   *                           P.truncated, divide, getLn10, getPi, naturalExponential,
   *                           naturalLogarithm, ceil, floor, round, trunc
   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,
   *                           toStringBinary
   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther
   *  getLn10                  P.logarithm, naturalLogarithm
   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2
   *  getPrecision             P.precision, P.toFraction
   *  getZeroString            digitsToString, finiteToString
   *  intPow                   P.toPower, parseOther
   *  isOdd                    toLessThanHalfPi
   *  maxOrMin                 max, min
   *  naturalExponential       P.naturalExponential, P.toPower
   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,
   *                           P.toPower, naturalExponential
   *  nonFiniteToString        finiteToString, toStringBinary
   *  parseDecimal             Decimal
   *  parseOther               Decimal
   *  sin                      P.sin
   *  taylorSeries             P.cosh, P.sinh, cos, sin
   *  toLessThanHalfPi         P.cos, P.sin
   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal
   *  truncate                 intPow
   *
   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,
   *                           naturalLogarithm, config, parseOther, random, Decimal
   */


  function digitsToString(d) {
    var i, k, ws,
      indexOfLastWord = d.length - 1,
      str = '',
      w = d[0];

    if (indexOfLastWord > 0) {
      str += w;
      for (i = 1; i < indexOfLastWord; i++) {
        ws = d[i] + '';
        k = LOG_BASE - ws.length;
        if (k) str += getZeroString(k);
        str += ws;
      }

      w = d[i];
      ws = w + '';
      k = LOG_BASE - ws.length;
      if (k) str += getZeroString(k);
    } else if (w === 0) {
      return '0';
    }

    // Remove trailing zeros of last w.
    for (; w % 10 === 0;) w /= 10;

    return str + w;
  }


  function checkInt32(i, min, max) {
    if (i !== ~~i || i < min || i > max) {
      throw Error(invalidArgument + i);
    }
  }


  /*
   * Check 5 rounding digits if `repeating` is null, 4 otherwise.
   * `repeating == null` if caller is `log` or `pow`,
   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.
   */
  function checkRoundingDigits(d, i, rm, repeating) {
    var di, k, r, rd;

    // Get the length of the first word of the array d.
    for (k = d[0]; k >= 10; k /= 10) --i;

    // Is the rounding digit in the first word of d?
    if (--i < 0) {
      i += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i + 1) / LOG_BASE);
      i %= LOG_BASE;
    }

    // i is the index (0 - 6) of the rounding digit.
    // E.g. if within the word 3487563 the first rounding digit is 5,
    // then i = 4, k = 1000, rd = 3487563 % 1000 = 563
    k = mathpow(10, LOG_BASE - i);
    rd = d[di] % k | 0;

    if (repeating == null) {
      if (i < 3) {
        if (i == 0) rd = rd / 100 | 0;
        else if (i == 1) rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) &&
          (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 ||
            (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i < 4) {
        if (i == 0) rd = rd / 1000 | 0;
        else if (i == 1) rd = rd / 100 | 0;
        else if (i == 2) rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k ||
        (!repeating && rm > 3) && rd + 1 == k / 2) &&
          (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;
      }
    }

    return r;
  }


  // Convert string of `baseIn` to an array of numbers of `baseOut`.
  // Eg. convertBase('255', 10, 16) returns [15, 15].
  // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].
  function convertBase(str, baseIn, baseOut) {
    var j,
      arr = [0],
      arrL,
      i = 0,
      strL = str.length;

    for (; i < strL;) {
      for (arrL = arr.length; arrL--;) arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0) arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }

    return arr.reverse();
  }


  /*
   * cos(x) = 1 - x^2/2! + x^4/4! - ...
   * |x| < pi/2
   *
   */
  function cosine(Ctor, x) {
    var k, y,
      len = x.d.length;

    // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1
    // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1

    // Estimate the optimum number of times to use the argument reduction.
    if (len < 32) {
      k = Math.ceil(len / 3);
      y = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y = '2.3283064365386962890625e-10';
    }

    Ctor.precision += k;

    x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));

    // Reverse argument reduction
    for (var i = k; i--;) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }

    Ctor.precision -= k;

    return x;
  }


  /*
   * Perform division in the specified base.
   */
  var divide = (function () {

    // Assumes non-zero x and k, and hence non-zero result.
    function multiplyInteger(x, k, base) {
      var temp,
        carry = 0,
        i = x.length;

      for (x = x.slice(); i--;) {
        temp = x[i] * k + carry;
        x[i] = temp % base | 0;
        carry = temp / base | 0;
      }

      if (carry) x.unshift(carry);

      return x;
    }

    function compare(a, b, aL, bL) {
      var i, r;

      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i = r = 0; i < aL; i++) {
          if (a[i] != b[i]) {
            r = a[i] > b[i] ? 1 : -1;
            break;
          }
        }
      }

      return r;
    }

    function subtract(a, b, aL, base) {
      var i = 0;

      // Subtract b from a.
      for (; aL--;) {
        a[aL] -= i;
        i = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i * base + a[aL] - b[aL];
      }

      // Remove leading zeros.
      for (; !a[0] && a.length > 1;) a.shift();
    }

    return function (x, y, pr, rm, dp, base) {
      var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0,
        yL, yz,
        Ctor = x.constructor,
        sign = x.s == y.s ? 1 : -1,
        xd = x.d,
        yd = y.d;

      // Either NaN, Infinity or 0?
      if (!xd || !xd[0] || !yd || !yd[0]) {

        return new Ctor(// Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN :

          // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);
      }

      if (base) {
        logBase = 1;
        e = x.e - y.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
      }

      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign);
      qd = q.d = [];

      // Result exponent may be one less than e.
      // The digit array of a Decimal from toStringBinary may have trailing zeros.
      for (i = 0; yd[i] == (xd[i] || 0); i++);

      if (yd[i] > (xd[i] || 0)) e--;

      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y.e) + 1;
      } else {
        sd = pr;
      }

      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {

        // Convert precision in number of base 10 digits to base 1e7 digits.
        sd = sd / logBase + 2 | 0;
        i = 0;

        // divisor < 1e7
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;

          // k is the carry.
          for (; (i < xL || k) && sd--; i++) {
            t = k * base + (xd[i] || 0);
            qd[i] = t / yd | 0;
            k = t % yd | 0;
          }

          more = k || i < xL;

        // divisor >= 1e7
        } else {

          // Normalise xd and yd so highest order digit of yd is >= base/2
          k = base / (yd[0] + 1) | 0;

          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }

          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;

          // Add zeros to make remainder as long as divisor.
          for (; remL < yL;) rem[remL++] = 0;

          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];

          if (yd[1] >= base / 2) ++yd0;

          do {
            k = 0;

            // Compare divisor and remainder.
            cmp = compare(yd, rem, yL, remL);

            // If divisor < remainder.
            if (cmp < 0) {

              // Calculate trial digit, k.
              rem0 = rem[0];
              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);

              // k will be how many times the divisor goes into the current remainder.
              k = rem0 / yd0 | 0;

              //  Algorithm:
              //  1. product = divisor * trial digit (k)
              //  2. if product > remainder: product -= divisor, k--
              //  3. remainder -= product
              //  4. if product was < remainder at 2:
              //    5. compare new remainder and divisor
              //    6. If remainder > divisor: remainder -= divisor, k++

              if (k > 1) {
                if (k >= base) k = base - 1;

                // product = divisor * trial digit.
                prod = multiplyInteger(yd, k, base);
                prodL = prod.length;
                remL = rem.length;

                // Compare product and remainder.
                cmp = compare(prod, rem, prodL, remL);

                // product > remainder.
                if (cmp == 1) {
                  k--;

                  // Subtract divisor from product.
                  subtract(prod, yL < prodL ? yz : yd, prodL, base);
                }
              } else {

                // cmp is -1.
                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1
                // to avoid it. If k is 1 there is a need to compare yd and rem again below.
                if (k == 0) cmp = k = 1;
                prod = yd.slice();
              }

              prodL = prod.length;
              if (prodL < remL) prod.unshift(0);

              // Subtract product from remainder.
              subtract(rem, prod, remL, base);

              // If product was < previous remainder.
              if (cmp == -1) {
                remL = rem.length;

                // Compare divisor and new remainder.
                cmp = compare(yd, rem, yL, remL);

                // If divisor < new remainder, subtract divisor from remainder.
                if (cmp < 1) {
                  k++;

                  // Subtract divisor from remainder.
                  subtract(rem, yL < remL ? yz : yd, remL, base);
                }
              }

              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }    // if cmp === 1, k will be 0

            // Add the next digit, k, to the result array.
            qd[i++] = k;

            // Update the remainder.
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }

          } while ((xi++ < xL || rem[0] !== void 0) && sd--);

          more = rem[0] !== void 0;
        }

        // Leading zero?
        if (!qd[0]) qd.shift();
      }

      // logBase is 1 when divide is being used for base conversion.
      if (logBase == 1) {
        q.e = e;
        inexact = more;
      } else {

        // To calculate q.e, first get the number of digits of qd[0].
        for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
        q.e = i + e * logBase - 1;

        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }

      return q;
    };
  })();


  /*
   * Round `x` to `sd` significant digits using rounding mode `rm`.
   * Check for over/under-flow.
   */
   function finalise(x, sd, rm, isTruncated) {
    var digits, i, j, k, rd, roundUp, w, xd, xdi,
      Ctor = x.constructor;

    // Don't round if sd is null or undefined.
    out: if (sd != null) {
      xd = x.d;

      // Infinity/NaN.
      if (!xd) return x;

      // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.
      // w: the word of xd containing rd, a base 1e7 number.
      // xdi: the index of w within xd.
      // digits: the number of digits of w.
      // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if
      // they had leading zeros)
      // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).

      // Get the length of the first word of the digits array xd.
      for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
      i = sd - digits;

      // Is the rounding digit in the first word of xd?
      if (i < 0) {
        i += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];

        // Get the rounding digit at index j of w.
        rd = w / mathpow(10, digits - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {

            // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.
            for (; k++ <= xdi;) xd.push(0);
            w = rd = 0;
            digits = 1;
            i %= LOG_BASE;
            j = i - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];

          // Get the number of digits of w.
          for (digits = 1; k >= 10; k /= 10) digits++;

          // Get the index of rd within w.
          i %= LOG_BASE;

          // Get the index of rd within w, adjusted for leading zeros.
          // The number of leading zeros of w is given by LOG_BASE - digits.
          j = i - LOG_BASE + digits;

          // Get the rounding digit at index j of w.
          rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
        }
      }

      // Are there any non-zero digits after the rounding digit?
      isTruncated = isTruncated || sd < 0 ||
        xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));

      // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right
      // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression
      // will give 714.

      roundUp = rm < 4
        ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))
        : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 &&

          // Check whether the digit to the left of the rounding digit is odd.
          ((i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10) & 1 ||
            rm == (x.s < 0 ? 8 : 7));

      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {

          // Convert sd to decimal places.
          sd -= x.e + 1;

          // 1, 0.1, 0.01, 0.001, 0.0001 etc.
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {

          // Zero.
          xd[0] = x.e = 0;
        }

        return x;
      }

      // Remove excess digits.
      if (i == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i);

        // E.g. 56700 becomes 56000 if 7 is the rounding digit.
        // j > 0 means i > number of leading zeros of w.
        xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
      }

      if (roundUp) {
        for (;;) {

          // Is the digit to be rounded up in the first word of xd?
          if (xdi == 0) {

            // i will be the length of xd[0] before k is added.
            for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10) k++;

            // if i != k the length has increased.
            if (i != k) {
              x.e++;
              if (xd[0] == BASE) xd[0] = 1;
            }

            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE) break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }

      // Remove trailing zeros.
      for (i = xd.length; xd[--i] === 0;) xd.pop();
    }

    if (external) {

      // Overflow?
      if (x.e > Ctor.maxE) {

        // Infinity.
        x.d = null;
        x.e = NaN;

      // Underflow?
      } else if (x.e < Ctor.minE) {

        // Zero.
        x.e = 0;
        x.d = [0];
        // Ctor.underflow = true;
      } // else Ctor.underflow = false;
    }

    return x;
  }


  function finiteToString(x, isExp, sd) {
    if (!x.isFinite()) return nonFiniteToString(x);
    var k,
      e = x.e,
      str = digitsToString(x.d),
      len = str.length;

    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + '.' + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + '.' + str.slice(1);
      }

      str = str + (x.e < 0 ? 'e' : 'e+') + x.e;
    } else if (e < 0) {
      str = '0.' + getZeroString(-e - 1) + str;
      if (sd && (k = sd - len) > 0) str += getZeroString(k);
    } else if (e >= len) {
      str += getZeroString(e + 1 - len);
      if (sd && (k = sd - e - 1) > 0) str = str + '.' + getZeroString(k);
    } else {
      if ((k = e + 1) < len) str = str.slice(0, k) + '.' + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e + 1 === len) str += '.';
        str += getZeroString(k);
      }
    }

    return str;
  }


  // Calculate the base 10 exponent from the base 1e7 exponent.
  function getBase10Exponent(digits, e) {
    var w = digits[0];

    // Add the number of digits of the first word of the digits array.
    for ( e *= LOG_BASE; w >= 10; w /= 10) e++;
    return e;
  }


  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {

      // Reset global state in case the exception is caught.
      external = true;
      if (pr) Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }


  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }


  function getPrecision(digits) {
    var w = digits.length - 1,
      len = w * LOG_BASE + 1;

    w = digits[w];

    // If non-zero...
    if (w) {

      // Subtract the number of trailing zeros of the last word.
      for (; w % 10 == 0; w /= 10) len--;

      // Add the number of digits of the first word.
      for (w = digits[0]; w >= 10; w /= 10) len++;
    }

    return len;
  }


  function getZeroString(k) {
    var zs = '';
    for (; k--;) zs += '0';
    return zs;
  }


  /*
   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an
   * integer of type number.
   *
   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.
   *
   */
  function intPow(Ctor, x, n, pr) {
    var isTruncated,
      r = new Ctor(1),

      // Max n of 9007199254740991 takes 53 loop iterations.
      // Maximum digits array length; leaves [28, 34] guard digits.
      k = Math.ceil(pr / LOG_BASE + 4);

    external = false;

    for (;;) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k)) isTruncated = true;
      }

      n = mathfloor(n / 2);
      if (n === 0) {

        // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0) ++r.d[n];
        break;
      }

      x = x.times(x);
      truncate(x.d, k);
    }

    external = true;

    return r;
  }


  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }


  /*
   * Handle `max` and `min`. `ltgt` is 'lt' or 'gt'.
   */
  function maxOrMin(Ctor, args, ltgt) {
    var y,
      x = new Ctor(args[0]),
      i = 0;

    for (; ++i < args.length;) {
      y = new Ctor(args[i]);
      if (!y.s) {
        x = y;
        break;
      } else if (x[ltgt](y)) {
        x = y;
      }
    }

    return x;
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant
   * digits.
   *
   * Taylor/Maclaurin series.
   *
   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...
   *
   * Argument reduction:
   *   Repeat x = x / 32, k += 5, until |x| < 0.1
   *   exp(x) = exp(x / 2^k)^(2^k)
   *
   * Previously, the argument was initially reduced by
   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)
   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was
   * found to be slower than just dividing repeatedly by 32 as above.
   *
   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000
   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000
   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)
   *
   *  exp(Infinity)  = Infinity
   *  exp(-Infinity) = 0
   *  exp(NaN)       = NaN
   *  exp(±0)        = 1
   *
   *  exp(x) is non-terminating for any finite, non-zero x.
   *
   *  The result will always be correctly rounded.
   *
   */
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow, sum, t, wpr,
      rep = 0,
      i = 0,
      k = 0,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // 0/NaN/Infinity?
    if (!x.d || !x.d[0] || x.e > 17) {

      return new Ctor(x.d
        ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0
        : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    t = new Ctor(0.03125);

    // while abs(x) >= 0.1
    while (x.e > -2) {

      // x = x / 2^5
      x = x.times(t);
      k += 5;
    }

    // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision
    // necessary to ensure the first 4 rounding digits are correct.
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow = sum = new Ctor(1);
    Ctor.precision = wpr;

    for (;;) {
      pow = finalise(pow.times(x), wpr, 1);
      denominator = denominator.times(++i);
      t = sum.plus(divide(pow, denominator, wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        j = k;
        while (j--) sum = finalise(sum.times(sum), wpr, 1);

        // Check to see if the first 4 rounding digits are [49]999.
        // If so, repeat the summation with a higher precision, otherwise
        // e.g. with precision: 18, rounding: 1
        // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {

          if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow = t = new Ctor(1);
            i = 0;
            rep++;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
    }
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant
   * digits.
   *
   *  ln(-n)        = NaN
   *  ln(0)         = -Infinity
   *  ln(-0)        = -Infinity
   *  ln(1)         = 0
   *  ln(Infinity)  = Infinity
   *  ln(-Infinity) = NaN
   *  ln(NaN)       = NaN
   *
   *  ln(n) (n != 1) is non-terminating.
   *
   */
  function naturalLogarithm(y, sd) {
    var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2,
      n = 1,
      guard = 10,
      x = y,
      xd = x.d,
      Ctor = x.constructor,
      rm = Ctor.rounding,
      pr = Ctor.precision;

    // Is x negative or Infinity, NaN, 0 or 1?
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }

    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }

    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);

    if (Math.abs(e = x.e) < 1.5e15) {

      // Argument reduction.
      // The series converges faster the closer the argument is to 1, so using
      // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b
      // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,
      // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can
      // later be divided by this number, then separate out the power of 10 using
      // ln(a*10^b) = ln(a) + b*ln(10).

      // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).
      //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {
      // max n is 6 (gives 0.7 - 1.3)
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }

      e = x.e;

      if (c0 > 1) {
        x = new Ctor('0.' + c);
        e++;
      } else {
        x = new Ctor(c0 + '.' + c.slice(1));
      }
    } else {

      // The argument reduction method above may result in overflow if the argument y is a massive
      // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this
      // function using ln(x*10^e) = ln(x) + e*ln(10).
      t = getLn10(Ctor, wpr + 2, pr).times(e + '');
      x = naturalLogarithm(new Ctor(c0 + '.' + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;

      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }

    // x1 is x reduced to a value near 1.
    x1 = x;

    // Taylor series.
    // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)
    // where x = (y - 1)/(y + 1)    (|x| < 1)
    sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;

    for (;;) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));

      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
        sum = sum.times(2);

        // Reverse the argument reduction. Check that e is not 0 because, besides preventing an
        // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.
        if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ''));
        sum = divide(sum, new Ctor(n), wpr, 1);

        // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has
        // been repeated previously) and the first 4 rounding digits 9999?
        // If so, restart the summation with a higher precision, otherwise
        // e.g. with precision: 12, rounding: 1
        // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.
        // `wpr - guard` is the index of first rounding digit.
        if (sd == null) {
          if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum;
        }
      }

      sum = t;
      denominator += 2;
    }
  }


  // ±Infinity, NaN.
  function nonFiniteToString(x) {
    // Unsigned.
    return String(x.s * x.s / 0);
  }


  /*
   * Parse the value of a new Decimal `x` from string `str`.
   */
  function parseDecimal(x, str) {
    var e, i, len;

    // Decimal point?
    if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');

    // Exponential form?
    if ((i = str.search(/e/i)) > 0) {

      // Determine exponent.
      if (e < 0) e = i;
      e += +str.slice(i + 1);
      str = str.substring(0, i);
    } else if (e < 0) {

      // Integer.
      e = str.length;
    }

    // Determine leading zeros.
    for (i = 0; str.charCodeAt(i) === 48; i++);

    // Determine trailing zeros.
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len);
    str = str.slice(i, len);

    if (str) {
      len -= i;
      x.e = e = e - i - 1;
      x.d = [];

      // Transform base

      // e is the base 10 exponent.
      // i is where to slice str to get the first word of the digits array.
      i = (e + 1) % LOG_BASE;
      if (e < 0) i += LOG_BASE;

      if (i < len) {
        if (i) x.d.push(+str.slice(0, i));
        for (len -= LOG_BASE; i < len;) x.d.push(+str.slice(i, i += LOG_BASE));
        str = str.slice(i);
        i = LOG_BASE - str.length;
      } else {
        i -= len;
      }

      for (; i--;) str += '0';
      x.d.push(+str);

      if (external) {

        // Overflow?
        if (x.e > x.constructor.maxE) {

          // Infinity.
          x.d = null;
          x.e = NaN;

        // Underflow?
        } else if (x.e < x.constructor.minE) {

          // Zero.
          x.e = 0;
          x.d = [0];
          // x.constructor.underflow = true;
        } // else x.constructor.underflow = false;
      }
    } else {

      // Zero.
      x.e = 0;
      x.d = [0];
    }

    return x;
  }


  /*
   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.
   */
  function parseOther(x, str) {
    var base, Ctor, divisor, i, isFloat, len, p, xd, xe;

    if (str === 'Infinity' || str === 'NaN') {
      if (!+str) x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }

    if (isHex.test(str))  {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str))  {
      base = 2;
    } else if (isOctal.test(str))  {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }

    // Is there a binary exponent part?
    i = str.search(/p/i);

    if (i > 0) {
      p = +str.slice(i + 1);
      str = str.substring(2, i);
    } else {
      str = str.slice(2);
    }

    // Convert `str` as an integer then divide the result by `base` raised to a power such that the
    // fraction part will be restored.
    i = str.indexOf('.');
    isFloat = i >= 0;
    Ctor = x.constructor;

    if (isFloat) {
      str = str.replace('.', '');
      len = str.length;
      i = len - i;

      // log[10](16) = 1.2041... , log[10](88) = 1.9444....
      divisor = intPow(Ctor, new Ctor(base), i, i * 2);
    }

    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;

    // Remove trailing zeros.
    for (i = xe; xd[i] === 0; --i) xd.pop();
    if (i < 0) return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;

    // At what precision to perform the division to ensure exact conversion?
    // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)
    // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412
    // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.
    // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount
    // Therefore using 4 * the number of digits of str will always be enough.
    if (isFloat) x = divide(x, divisor, len * 4);

    // Multiply by the binary exponent part if present.
    if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;

    return x;
  }


  /*
   * sin(x) = x - x^3/3! + x^5/5! - ...
   * |x| < pi/2
   *
   */
  function sine(Ctor, x) {
    var k,
      len = x.d.length;

    if (len < 3) return taylorSeries(Ctor, 2, x, x);

    // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)
    // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)
    // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))

    // Estimate the optimum number of times to use the argument reduction.
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;

    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);

    // Reverse argument reduction
    var sin2_x,
      d5 = new Ctor(5),
      d16 = new Ctor(16),
      d20 = new Ctor(20);
    for (; k--;) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }

    return x;
  }


  // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.
  function taylorSeries(Ctor, n, x, y, isHyperbolic) {
    var j, t, u, x2,
      pr = Ctor.precision,
      k = Math.ceil(pr / LOG_BASE);

    external = false;
    x2 = x.times(x);
    u = new Ctor(y);

    for (;;) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y.plus(t) : y.minus(t);
      y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y);

      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--;);
        if (j == -1) break;
      }

      j = u;
      u = y;
      y = t;
      t = j;
    }

    external = true;
    t.d.length = k + 1;

    return t;
  }


  // Exponent e must be positive and non-zero.
  function tinyPow(b, e) {
    var n = b;
    while (--e) n *= b;
    return n;
  }


  // Return the absolute value of `x` reduced to less than or equal to half pi.
  function toLessThanHalfPi(Ctor, x) {
    var t,
      isNeg = x.s < 0,
      pi = getPi(Ctor, Ctor.precision, 1),
      halfPi = pi.times(0.5);

    x = x.abs();

    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }

    t = x.divToInt(pi);

    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi));

      // 0 <= x < pi
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? (isNeg ? 2 : 3) : (isNeg ? 4 : 1);
        return x;
      }

      quadrant = isOdd(t) ? (isNeg ? 1 : 4) : (isNeg ? 3 : 2);
    }

    return x.minus(pi).abs();
  }


  /*
   * Return the value of Decimal `x` as a string in base `baseOut`.
   *
   * If the optional `sd` argument is present include a binary exponent suffix.
   */
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e, i, k, len, roundUp, str, xd, y,
      Ctor = x.constructor,
      isExp = sd !== void 0;

    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0) rm = Ctor.rounding;
      else checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }

    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i = str.indexOf('.');

      // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:
      // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))
      // minBinaryExponent = floor(decimalExponent * log[2](10))
      // log[2](10) = 3.321928094887362347870319429489390175864

      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }

      // Convert the number as an integer then divide the result by its base raised to a power such
      // that the fraction part will be restored.

      // Non-integer.
      if (i >= 0) {
        str = str.replace('.', '');
        y = new Ctor(1);
        y.e = str.length - i;
        y.d = convertBase(finiteToString(y), 10, base);
        y.e = y.d.length;
      }

      xd = convertBase(str, 10, base);
      e = len = xd.length;

      // Remove trailing zeros.
      for (; xd[--len] == 0;) xd.pop();

      if (!xd[0]) {
        str = isExp ? '0p+0' : '0';
      } else {
        if (i < 0) {
          e--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e;
          x = divide(x, y, sd, rm, 0, base);
          xd = x.d;
          e = x.e;
          roundUp = inexact;
        }

        // The rounding digit, i.e. the digit after the digit that may be rounded up.
        i = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;

        roundUp = rm < 4
          ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2))
          : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 ||
            rm === (x.s < 0 ? 8 : 7));

        xd.length = sd;

        if (roundUp) {

          // Rounding up may mean the previous digit has to be rounded up and so on.
          for (; ++xd[--sd] > base - 1;) {
            xd[sd] = 0;
            if (!sd) {
              ++e;
              xd.unshift(1);
            }
          }
        }

        // Determine trailing zeros.
        for (len = xd.length; !xd[len - 1]; --len);

        // E.g. [4, 11, 15] becomes 4bf.
        for (i = 0, str = ''; i < len; i++) str += NUMERALS.charAt(xd[i]);

        // Add binary exponent suffix?
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i = baseOut == 16 ? 4 : 3;
              for (--len; len % i; len++) str += '0';
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len);

              // xd[0] will always be be 1
              for (i = 1, str = '1.'; i < len; i++) str += NUMERALS.charAt(xd[i]);
            } else {
              str = str.charAt(0) + '.' + str.slice(1);
            }
          }

          str =  str + (e < 0 ? 'p' : 'p+') + e;
        } else if (e < 0) {
          for (; ++e;) str = '0' + str;
          str = '0.' + str;
        } else {
          if (++e > len) for (e -= len; e-- ;) str += '0';
          else if (e < len) str = str.slice(0, e) + '.' + str.slice(e);
        }
      }

      str = (baseOut == 16 ? '0x' : baseOut == 2 ? '0b' : baseOut == 8 ? '0o' : '') + str;
    }

    return x.s < 0 ? '-' + str : str;
  }


  // Does not strip trailing zeros.
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }


  // Decimal methods


  /*
   *  abs
   *  acos
   *  acosh
   *  add
   *  asin
   *  asinh
   *  atan
   *  atanh
   *  atan2
   *  cbrt
   *  ceil
   *  clone
   *  config
   *  cos
   *  cosh
   *  div
   *  exp
   *  floor
   *  hypot
   *  ln
   *  log
   *  log2
   *  log10
   *  max
   *  min
   *  mod
   *  mul
   *  pow
   *  random
   *  round
   *  set
   *  sign
   *  sin
   *  sinh
   *  sqrt
   *  sub
   *  tan
   *  tanh
   *  trunc
   */


  /*
   * Return a new Decimal whose value is the absolute value of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function abs(x) {
    return new this(x).abs();
  }


  /*
   * Return a new Decimal whose value is the arccosine in radians of `x`.
   *
   * x {number|string|Decimal}
   *
   */
  function acos(x) {
    return new this(x).acos();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function acosh(x) {
    return new this(x).acosh();
  }


  /*
   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function add(x, y) {
    return new this(x).plus(y);
  }


  /*
   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function asin(x) {
    return new this(x).asin();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function asinh(x) {
    return new this(x).asinh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function atan(x) {
    return new this(x).atan();
  }


  /*
   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to
   * `precision` significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function atanh(x) {
    return new this(x).atanh();
  }


  /*
   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi
   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * Domain: [-Infinity, Infinity]
   * Range: [-pi, pi]
   *
   * y {number|string|Decimal} The y-coordinate.
   * x {number|string|Decimal} The x-coordinate.
   *
   * atan2(±0, -0)               = ±pi
   * atan2(±0, +0)               = ±0
   * atan2(±0, -x)               = ±pi for x > 0
   * atan2(±0, x)                = ±0 for x > 0
   * atan2(-y, ±0)               = -pi/2 for y > 0
   * atan2(y, ±0)                = pi/2 for y > 0
   * atan2(±y, -Infinity)        = ±pi for finite y > 0
   * atan2(±y, +Infinity)        = ±0 for finite y > 0
   * atan2(±Infinity, x)         = ±pi/2 for finite x
   * atan2(±Infinity, -Infinity) = ±3*pi/4
   * atan2(±Infinity, +Infinity) = ±pi/4
   * atan2(NaN, x) = NaN
   * atan2(y, NaN) = NaN
   *
   */
  function atan2(y, x) {
    y = new this(y);
    x = new this(x);
    var r,
      pr = this.precision,
      rm = this.rounding,
      wpr = pr + 4;

    // Either NaN
    if (!y.s || !x.s) {
      r = new this(NaN);

    // Both ±Infinity
    } else if (!y.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y.s;

    // x is ±Infinity or y is ±0
    } else if (!x.d || y.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y.s;

    // y is ±Infinity or x is ±0
    } else if (!y.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y.s;

    // Both non-zero and finite
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y, x, wpr, 1));
    }

    return r;
  }


  /*
   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function cbrt(x) {
    return new this(x).cbrt();
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.
   *
   * x {number|string|Decimal}
   *
   */
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }


  /*
   * Configure global settings for a Decimal constructor.
   *
   * `obj` is an object with one or more of the following properties,
   *
   *   precision  {number}
   *   rounding   {number}
   *   toExpNeg   {number}
   *   toExpPos   {number}
   *   maxE       {number}
   *   minE       {number}
   *   modulo     {number}
   *   crypto     {boolean|number}
   *   defaults   {true}
   *
   * E.g. Decimal.config({ precision: 20, rounding: 4 })
   *
   */
  function config(obj) {
    if (!obj || typeof obj !== 'object') throw Error(decimalError + 'Object expected');
    var i, p, v,
      useDefaults = obj.defaults === true,
      ps = [
        'precision', 1, MAX_DIGITS,
        'rounding', 0, 8,
        'toExpNeg', -EXP_LIMIT, 0,
        'toExpPos', 0, EXP_LIMIT,
        'maxE', 0, EXP_LIMIT,
        'minE', -EXP_LIMIT, 0,
        'modulo', 0, 9
      ];

    for (i = 0; i < ps.length; i += 3) {
      if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
        else throw Error(invalidArgument + p + ': ' + v);
      }
    }

    if (p = 'crypto', useDefaults) this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != 'undefined' && crypto &&
            (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ': ' + v);
      }
    }

    return this;
  }


  /*
   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cos(x) {
    return new this(x).cos();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function cosh(x) {
    return new this(x).cosh();
  }


  /*
   * Create and return a Decimal constructor with the same configuration properties as this Decimal
   * constructor.
   *
   */
  function clone(obj) {
    var i, p, ps;

    /*
     * The Decimal constructor and exported function.
     * Return a new Decimal instance.
     *
     * v {number|string|Decimal} A numeric value.
     *
     */
    function Decimal(v) {
      var e, i, t,
        x = this;

      // Decimal called without new.
      if (!(x instanceof Decimal)) return new Decimal(v);

      // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor
      // which points to Object.
      x.constructor = Decimal;

      // Duplicate.
      if (v instanceof Decimal) {
        x.s = v.s;

        if (external) {
          if (!v.d || v.e > Decimal.maxE) {

            // Infinity.
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal.minE) {

            // Zero.
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }

        return;
      }

      t = typeof v;

      if (t === 'number') {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }

        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }

        // Fast path for small integers.
        if (v === ~~v && v < 1e7) {
          for (e = 0, i = v; i >= 10; i /= 10) e++;

          if (external) {
            if (e > Decimal.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e < Decimal.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e;
              x.d = [v];
            }
          } else {
            x.e = e;
            x.d = [v];
          }

          return;

        // Infinity, NaN.
        } else if (v * 0 !== 0) {
          if (!v) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }

        return parseDecimal(x, v.toString());

      } else if (t !== 'string') {
        throw Error(invalidArgument + v);
      }

      // Minus sign?
      if ((i = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        // Plus sign?
        if (i === 43) v = v.slice(1);
        x.s = 1;
      }

      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }

    Decimal.prototype = P;

    Decimal.ROUND_UP = 0;
    Decimal.ROUND_DOWN = 1;
    Decimal.ROUND_CEIL = 2;
    Decimal.ROUND_FLOOR = 3;
    Decimal.ROUND_HALF_UP = 4;
    Decimal.ROUND_HALF_DOWN = 5;
    Decimal.ROUND_HALF_EVEN = 6;
    Decimal.ROUND_HALF_CEIL = 7;
    Decimal.ROUND_HALF_FLOOR = 8;
    Decimal.EUCLID = 9;

    Decimal.config = Decimal.set = config;
    Decimal.clone = clone;
    Decimal.isDecimal = isDecimalInstance;

    Decimal.abs = abs;
    Decimal.acos = acos;
    Decimal.acosh = acosh;        // ES6
    Decimal.add = add;
    Decimal.asin = asin;
    Decimal.asinh = asinh;        // ES6
    Decimal.atan = atan;
    Decimal.atanh = atanh;        // ES6
    Decimal.atan2 = atan2;
    Decimal.cbrt = cbrt;          // ES6
    Decimal.ceil = ceil;
    Decimal.cos = cos;
    Decimal.cosh = cosh;          // ES6
    Decimal.div = div;
    Decimal.exp = exp;
    Decimal.floor = floor;
    Decimal.hypot = hypot;        // ES6
    Decimal.ln = ln;
    Decimal.log = log;
    Decimal.log10 = log10;        // ES6
    Decimal.log2 = log2;          // ES6
    Decimal.max = max;
    Decimal.min = min;
    Decimal.mod = mod;
    Decimal.mul = mul;
    Decimal.pow = pow;
    Decimal.random = random;
    Decimal.round = round;
    Decimal.sign = sign;          // ES6
    Decimal.sin = sin;
    Decimal.sinh = sinh;          // ES6
    Decimal.sqrt = sqrt;
    Decimal.sub = sub;
    Decimal.tan = tan;
    Decimal.tanh = tanh;          // ES6
    Decimal.trunc = trunc;        // ES6

    if (obj === void 0) obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ['precision', 'rounding', 'toExpNeg', 'toExpPos', 'maxE', 'minE', 'modulo', 'crypto'];
        for (i = 0; i < ps.length;) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
      }
    }

    Decimal.config(obj);

    return Decimal;
  }


  /*
   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function div(x, y) {
    return new this(x).div(y);
  }


  /*
   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The power to which to raise the base of the natural log.
   *
   */
  function exp(x) {
    return new this(x).exp();
  }


  /*
   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.
   *
   * x {number|string|Decimal}
   *
   */
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }


  /*
   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,
   * rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)
   *
   * arguments {number|string|Decimal}
   *
   */
  function hypot() {
    var i, n,
      t = new this(0);

    external = false;

    for (i = 0; i < arguments.length;) {
      n = new this(arguments[i++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }

    external = true;

    return t.sqrt();
  }


  /*
   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),
   * otherwise return false.
   *
   */
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.name === '[object Decimal]' || false;
  }


  /*
   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function ln(x) {
    return new this(x).ln();
  }


  /*
   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base
   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.
   *
   * log[y](x)
   *
   * x {number|string|Decimal} The argument of the logarithm.
   * y {number|string|Decimal} The base of the logarithm.
   *
   */
  function log(x, y) {
    return new this(x).log(y);
  }


  /*
   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log2(x) {
    return new this(x).log(2);
  }


  /*
   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function log10(x) {
    return new this(x).log(10);
  }


  /*
   * Return a new Decimal whose value is the maximum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function max() {
    return maxOrMin(this, arguments, 'lt');
  }


  /*
   * Return a new Decimal whose value is the minimum of the arguments.
   *
   * arguments {number|string|Decimal}
   *
   */
  function min() {
    return maxOrMin(this, arguments, 'gt');
  }


  /*
   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mod(x, y) {
    return new this(x).mod(y);
  }


  /*
   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function mul(x, y) {
    return new this(x).mul(y);
  }


  /*
   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} The base.
   * y {number|string|Decimal} The exponent.
   *
   */
  function pow(x, y) {
    return new this(x).pow(y);
  }


  /*
   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with
   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros
   * are produced).
   *
   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.
   *
   */
  function random(sd) {
    var d, e, k, n,
      i = 0,
      r = new this(1),
      rd = [];

    if (sd === void 0) sd = this.precision;
    else checkInt32(sd, 1, MAX_DIGITS);

    k = Math.ceil(sd / LOG_BASE);

    if (!this.crypto) {
      for (; i < k;) rd[i++] = Math.random() * 1e7 | 0;

    // Browsers supporting crypto.getRandomValues.
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));

      for (; i < k;) {
        n = d[i];

        // 0 <= n < 4294967296
        // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).
        if (n >= 4.29e9) {
          d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {

          // 0 <= n <= 4289999999
          // 0 <= (n % 1e7) <= 9999999
          rd[i++] = n % 1e7;
        }
      }

    // Node.js supporting crypto.randomBytes.
    } else if (crypto.randomBytes) {

      // buffer
      d = crypto.randomBytes(k *= 4);

      for (; i < k;) {

        // 0 <= n < 2147483648
        n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);

        // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).
        if (n >= 2.14e9) {
          crypto.randomBytes(4).copy(d, i);
        } else {

          // 0 <= n <= 2139999999
          // 0 <= (n % 1e7) <= 9999999
          rd.push(n % 1e7);
          i += 4;
        }
      }

      i = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }

    k = rd[--i];
    sd %= LOG_BASE;

    // Convert trailing digits to zeros according to sd.
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i] = (k / n | 0) * n;
    }

    // Remove trailing words which are zero.
    for (; rd[i] === 0; i--) rd.pop();

    // Zero?
    if (i < 0) {
      e = 0;
      rd = [0];
    } else {
      e = -1;

      // Remove leading words which are zero and adjust exponent accordingly.
      for (; rd[0] === 0; e -= LOG_BASE) rd.shift();

      // Count the digits of the first word of rd to determine leading zeros.
      for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;

      // Adjust the exponent for leading zeros of the first word of rd.
      if (k < LOG_BASE) e -= LOG_BASE - k;
    }

    r.e = e;
    r.d = rd;

    return r;
  }


  /*
   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.
   *
   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).
   *
   * x {number|string|Decimal}
   *
   */
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }


  /*
   * Return
   *   1    if x > 0,
   *  -1    if x < 0,
   *   0    if x is 0,
   *  -0    if x is -0,
   *   NaN  otherwise
   *
   * x {number|string|Decimal}
   *
   */
  function sign(x) {
    x = new this(x);
    return x.d ? (x.d[0] ? x.s : 0 * x.s) : x.s || NaN;
  }


  /*
   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sin(x) {
    return new this(x).sin();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function sinh(x) {
    return new this(x).sinh();
  }


  /*
   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   *
   */
  function sqrt(x) {
    return new this(x).sqrt();
  }


  /*
   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits
   * using rounding mode `rounding`.
   *
   * x {number|string|Decimal}
   * y {number|string|Decimal}
   *
   */
  function sub(x, y) {
    return new this(x).sub(y);
  }


  /*
   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant
   * digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tan(x) {
    return new this(x).tan();
  }


  /*
   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`
   * significant digits using rounding mode `rounding`.
   *
   * x {number|string|Decimal} A value in radians.
   *
   */
  function tanh(x) {
    return new this(x).tanh();
  }


  /*
   * Return a new Decimal whose value is `x` truncated to an integer.
   *
   * x {number|string|Decimal}
   *
   */
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }


  // Create and configure initial Decimal constructor.
  Decimal = clone(DEFAULTS);

  Decimal['default'] = Decimal.Decimal = Decimal;

  // Create the internal constants from their string values.
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);


  // Export.


  // AMD.
  if (module.exports) {
    if (typeof Symbol == 'function' && typeof Symbol.iterator == 'symbol') {
      P[Symbol.for('nodejs.util.inspect.custom')] = P.toString;
      P[Symbol.toStringTag] = 'Decimal';
    }

    module.exports = Decimal;

  // Browser.
  } else {
    if (!globalScope) {
      globalScope = typeof self != 'undefined' && self && self.self == self ? self : window;
    }

    noConflict = globalScope.Decimal;
    Decimal.noConflict = function () {
      globalScope.Decimal = noConflict;
      return Decimal;
    };

    globalScope.Decimal = Decimal;
  }
})(commonjsGlobal);
}(decimal));

var complex = {exports: {}};

/**
 * @license Complex.js v2.0.13 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/

(function (module, exports) {
/**
 *
 * This class allows the manipulation of complex numbers.
 * You can pass a complex number in different formats. Either as object, double, string or two integer parameters.
 *
 * Object form
 * { re: <real>, im: <imaginary> }
 * { arg: <angle>, abs: <radius> }
 * { phi: <angle>, r: <radius> }
 *
 * Array / Vector form
 * [ real, imaginary ]
 *
 * Double form
 * 99.3 - Single double value
 *
 * String form
 * '23.1337' - Simple real number
 * '15+3i' - a simple complex number
 * '3-i' - a simple complex number
 *
 * Example:
 *
 * var c = new Complex('99.3+8i');
 * c.mul({r: 3, i: 9}).div(4.9).sub(3, 2);
 *
 */

(function(root) {

  var cosh = function(x) {
    return (Math.exp(x) + Math.exp(-x)) * 0.5;
  };

  var sinh = function(x) {
    return (Math.exp(x) - Math.exp(-x)) * 0.5;
  };

  /**
   * Calculates cos(x) - 1 using Taylor series if x is small.
   *
   * @param {number} x
   * @returns {number} cos(x) - 1
   */

  var cosm1 = function(x) {
    var limit = Math.PI/4;
    if (x < -limit || x > limit) {
      return (Math.cos(x) - 1.0);
    }

    var xx = x * x;
    return xx *
      (-0.5 + xx *
        (1/24 + xx *
          (-1/720 + xx *
            (1/40320 + xx *
              (-1/3628800 + xx *
                (1/4790014600 + xx *
                  (-1/87178291200 + xx *
                    (1/20922789888000)
                  )
                )
              )
            )
          )
        )
      )
  };

  var hypot = function(x, y) {

    var a = Math.abs(x);
    var b = Math.abs(y);

    if (a < 3000 && b < 3000) {
      return Math.sqrt(a * a + b * b);
    }

    if (a < b) {
      a = b;
      b = x / y;
    } else {
      b = y / x;
    }
    return a * Math.sqrt(1 + b * b);
  };

  var parser_exit = function() {
    throw SyntaxError('Invalid Param');
  };

  /**
   * Calculates log(sqrt(a^2+b^2)) in a way to avoid overflows
   *
   * @param {number} a
   * @param {number} b
   * @returns {number}
   */
  function logHypot(a, b) {

    var _a = Math.abs(a);
    var _b = Math.abs(b);

    if (a === 0) {
      return Math.log(_b);
    }

    if (b === 0) {
      return Math.log(_a);
    }

    if (_a < 3000 && _b < 3000) {
      return Math.log(a * a + b * b) * 0.5;
    }

    /* I got 4 ideas to compute this property without overflow:
     *
     * Testing 1000000 times with random samples for a,b ∈ [1, 1000000000] against a big decimal library to get an error estimate
     *
     * 1. Only eliminate the square root: (OVERALL ERROR: 3.9122483030951116e-11)

     Math.log(a * a + b * b) / 2

     *
     *
     * 2. Try to use the non-overflowing pythagoras: (OVERALL ERROR: 8.889760039210159e-10)

     var fn = function(a, b) {
     a = Math.abs(a);
     b = Math.abs(b);
     var t = Math.min(a, b);
     a = Math.max(a, b);
     t = t / a;

     return Math.log(a) + Math.log(1 + t * t) / 2;
     };

     * 3. Abuse the identity cos(atan(y/x) = x / sqrt(x^2+y^2): (OVERALL ERROR: 3.4780178737037204e-10)

     Math.log(a / Math.cos(Math.atan2(b, a)))

     * 4. Use 3. and apply log rules: (OVERALL ERROR: 1.2014087502620896e-9)

     Math.log(a) - Math.log(Math.cos(Math.atan2(b, a)))

     */

    return Math.log(a / Math.cos(Math.atan2(b, a)));
  }

  var parse = function(a, b) {

    var z = {'re': 0, 'im': 0};

    if (a === undefined || a === null) {
      z['re'] =
              z['im'] = 0;
    } else if (b !== undefined) {
      z['re'] = a;
      z['im'] = b;
    } else
      switch (typeof a) {

        case 'object':

          if ('im' in a && 're' in a) {
            z['re'] = a['re'];
            z['im'] = a['im'];
          } else if ('abs' in a && 'arg' in a) {
            if (!Number.isFinite(a['abs']) && Number.isFinite(a['arg'])) {
              return Complex['INFINITY'];
            }
            z['re'] = a['abs'] * Math.cos(a['arg']);
            z['im'] = a['abs'] * Math.sin(a['arg']);
          } else if ('r' in a && 'phi' in a) {
            if (!Number.isFinite(a['r']) && Number.isFinite(a['phi'])) {
              return Complex['INFINITY'];
            }
            z['re'] = a['r'] * Math.cos(a['phi']);
            z['im'] = a['r'] * Math.sin(a['phi']);
          } else if (a.length === 2) { // Quick array check
            z['re'] = a[0];
            z['im'] = a[1];
          } else {
            parser_exit();
          }
          break;

        case 'string':

          z['im'] = /* void */
                  z['re'] = 0;

          var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
          var plus = 1;
          var minus = 0;

          if (tokens === null) {
            parser_exit();
          }

          for (var i = 0; i < tokens.length; i++) {

            var c = tokens[i];

            if (c === ' ' || c === '\t' || c === '\n') ; else if (c === '+') {
              plus++;
            } else if (c === '-') {
              minus++;
            } else if (c === 'i' || c === 'I') {

              if (plus + minus === 0) {
                parser_exit();
              }

              if (tokens[i + 1] !== ' ' && !isNaN(tokens[i + 1])) {
                z['im'] += parseFloat((minus % 2 ? '-' : '') + tokens[i + 1]);
                i++;
              } else {
                z['im'] += parseFloat((minus % 2 ? '-' : '') + '1');
              }
              plus = minus = 0;

            } else {

              if (plus + minus === 0 || isNaN(c)) {
                parser_exit();
              }

              if (tokens[i + 1] === 'i' || tokens[i + 1] === 'I') {
                z['im'] += parseFloat((minus % 2 ? '-' : '') + c);
                i++;
              } else {
                z['re'] += parseFloat((minus % 2 ? '-' : '') + c);
              }
              plus = minus = 0;
            }
          }

          // Still something on the stack
          if (plus + minus > 0) {
            parser_exit();
          }
          break;

        case 'number':
          z['im'] = 0;
          z['re'] = a;
          break;

        default:
          parser_exit();
      }

    if (isNaN(z['re']) || isNaN(z['im'])) ;

    return z;
  };

  /**
   * @constructor
   * @returns {Complex}
   */
  function Complex(a, b) {

    if (!(this instanceof Complex)) {
      return new Complex(a, b);
    }

    var z = parse(a, b);

    this['re'] = z['re'];
    this['im'] = z['im'];
  }

  Complex.prototype = {

    're': 0,
    'im': 0,

    /**
     * Calculates the sign of a complex number, which is a normalized complex
     *
     * @returns {Complex}
     */
    'sign': function() {

      var abs = this['abs']();

      return new Complex(
              this['re'] / abs,
              this['im'] / abs);
    },

    /**
     * Adds two complex numbers
     *
     * @returns {Complex}
     */
    'add': function(a, b) {

      var z = new Complex(a, b);

      // Infinity + Infinity = NaN
      if (this['isInfinite']() && z['isInfinite']()) {
        return Complex['NAN'];
      }

      // Infinity + z = Infinity { where z != Infinity }
      if (this['isInfinite']() || z['isInfinite']()) {
        return Complex['INFINITY'];
      }

      return new Complex(
              this['re'] + z['re'],
              this['im'] + z['im']);
    },

    /**
     * Subtracts two complex numbers
     *
     * @returns {Complex}
     */
    'sub': function(a, b) {

      var z = new Complex(a, b);

      // Infinity - Infinity = NaN
      if (this['isInfinite']() && z['isInfinite']()) {
        return Complex['NAN'];
      }

      // Infinity - z = Infinity { where z != Infinity }
      if (this['isInfinite']() || z['isInfinite']()) {
        return Complex['INFINITY'];
      }

      return new Complex(
              this['re'] - z['re'],
              this['im'] - z['im']);
    },

    /**
     * Multiplies two complex numbers
     *
     * @returns {Complex}
     */
    'mul': function(a, b) {

      var z = new Complex(a, b);

      // Infinity * 0 = NaN
      if ((this['isInfinite']() && z['isZero']()) || (this['isZero']() && z['isInfinite']())) {
        return Complex['NAN'];
      }

      // Infinity * z = Infinity { where z != 0 }
      if (this['isInfinite']() || z['isInfinite']()) {
        return Complex['INFINITY'];
      }

      // Short circuit for real values
      if (z['im'] === 0 && this['im'] === 0) {
        return new Complex(this['re'] * z['re'], 0);
      }

      return new Complex(
              this['re'] * z['re'] - this['im'] * z['im'],
              this['re'] * z['im'] + this['im'] * z['re']);
    },

    /**
     * Divides two complex numbers
     *
     * @returns {Complex}
     */
    'div': function(a, b) {

      var z = new Complex(a, b);

      // 0 / 0 = NaN and Infinity / Infinity = NaN
      if ((this['isZero']() && z['isZero']()) || (this['isInfinite']() && z['isInfinite']())) {
        return Complex['NAN'];
      }

      // Infinity / 0 = Infinity
      if (this['isInfinite']() || z['isZero']()) {
        return Complex['INFINITY'];
      }

      // 0 / Infinity = 0
      if (this['isZero']() || z['isInfinite']()) {
        return Complex['ZERO'];
      }

      a = this['re'];
      b = this['im'];

      var c = z['re'];
      var d = z['im'];
      var t, x;

      if (0 === d) {
        // Divisor is real
        return new Complex(a / c, b / c);
      }

      if (Math.abs(c) < Math.abs(d)) {

        x = c / d;
        t = c * x + d;

        return new Complex(
                (a * x + b) / t,
                (b * x - a) / t);

      } else {

        x = d / c;
        t = d * x + c;

        return new Complex(
                (a + b * x) / t,
                (b - a * x) / t);
      }
    },

    /**
     * Calculate the power of two complex numbers
     *
     * @returns {Complex}
     */
    'pow': function(a, b) {

      var z = new Complex(a, b);

      a = this['re'];
      b = this['im'];

      if (z['isZero']()) {
        return Complex['ONE'];
      }

      // If the exponent is real
      if (z['im'] === 0) {

        if (b === 0 && a > 0) {

          return new Complex(Math.pow(a, z['re']), 0);

        } else if (a === 0) { // If base is fully imaginary

          switch ((z['re'] % 4 + 4) % 4) {
            case 0:
              return new Complex(Math.pow(b, z['re']), 0);
            case 1:
              return new Complex(0, Math.pow(b, z['re']));
            case 2:
              return new Complex(-Math.pow(b, z['re']), 0);
            case 3:
              return new Complex(0, -Math.pow(b, z['re']));
          }
        }
      }

      /* I couldn't find a good formula, so here is a derivation and optimization
       *
       * z_1^z_2 = (a + bi)^(c + di)
       *         = exp((c + di) * log(a + bi)
       *         = pow(a^2 + b^2, (c + di) / 2) * exp(i(c + di)atan2(b, a))
       * =>...
       * Re = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * cos(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       * Im = (pow(a^2 + b^2, c / 2) * exp(-d * atan2(b, a))) * sin(d * log(a^2 + b^2) / 2 + c * atan2(b, a))
       *
       * =>...
       * Re = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * cos(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       * Im = exp(c * log(sqrt(a^2 + b^2)) - d * atan2(b, a)) * sin(d * log(sqrt(a^2 + b^2)) + c * atan2(b, a))
       *
       * =>
       * Re = exp(c * logsq2 - d * arg(z_1)) * cos(d * logsq2 + c * arg(z_1))
       * Im = exp(c * logsq2 - d * arg(z_1)) * sin(d * logsq2 + c * arg(z_1))
       *
       */

      if (a === 0 && b === 0 && z['re'] > 0 && z['im'] >= 0) {
        return Complex['ZERO'];
      }

      var arg = Math.atan2(b, a);
      var loh = logHypot(a, b);

      a = Math.exp(z['re'] * loh - z['im'] * arg);
      b = z['im'] * loh + z['re'] * arg;
      return new Complex(
              a * Math.cos(b),
              a * Math.sin(b));
    },

    /**
     * Calculate the complex square root
     *
     * @returns {Complex}
     */
    'sqrt': function() {

      var a = this['re'];
      var b = this['im'];
      var r = this['abs']();

      var re, im;

      if (a >= 0) {

        if (b === 0) {
          return new Complex(Math.sqrt(a), 0);
        }

        re = 0.5 * Math.sqrt(2.0 * (r + a));
      } else {
        re = Math.abs(b) / Math.sqrt(2 * (r - a));
      }

      if (a <= 0) {
        im = 0.5 * Math.sqrt(2.0 * (r - a));
      } else {
        im = Math.abs(b) / Math.sqrt(2 * (r + a));
      }

      return new Complex(re, b < 0 ? -im : im);
    },

    /**
     * Calculate the complex exponent
     *
     * @returns {Complex}
     */
    'exp': function() {

      var tmp = Math.exp(this['re']);

      if (this['im'] === 0) ;
      return new Complex(
              tmp * Math.cos(this['im']),
              tmp * Math.sin(this['im']));
    },

    /**
     * Calculate the complex exponent and subtracts one.
     *
     * This may be more accurate than `Complex(x).exp().sub(1)` if
     * `x` is small.
     *
     * @returns {Complex}
     */
    'expm1': function() {

      /**
       * exp(a + i*b) - 1
       = exp(a) * (cos(b) + j*sin(b)) - 1
       = expm1(a)*cos(b) + cosm1(b) + j*exp(a)*sin(b)
       */

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              Math.expm1(a) * Math.cos(b) + cosm1(b),
              Math.exp(a) * Math.sin(b));
    },

    /**
     * Calculate the natural log
     *
     * @returns {Complex}
     */
    'log': function() {

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              logHypot(a, b),
              Math.atan2(b, a));
    },

    /**
     * Calculate the magnitude of the complex number
     *
     * @returns {number}
     */
    'abs': function() {

      return hypot(this['re'], this['im']);
    },

    /**
     * Calculate the angle of the complex number
     *
     * @returns {number}
     */
    'arg': function() {

      return Math.atan2(this['im'], this['re']);
    },

    /**
     * Calculate the sine of the complex number
     *
     * @returns {Complex}
     */
    'sin': function() {

      // sin(c) = (e^b - e^(-b)) / (2i)

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              Math.sin(a) * cosh(b),
              Math.cos(a) * sinh(b));
    },

    /**
     * Calculate the cosine
     *
     * @returns {Complex}
     */
    'cos': function() {

      // cos(z) = (e^b + e^(-b)) / 2

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              Math.cos(a) * cosh(b),
              -Math.sin(a) * sinh(b));
    },

    /**
     * Calculate the tangent
     *
     * @returns {Complex}
     */
    'tan': function() {

      // tan(c) = (e^(ci) - e^(-ci)) / (i(e^(ci) + e^(-ci)))

      var a = 2 * this['re'];
      var b = 2 * this['im'];
      var d = Math.cos(a) + cosh(b);

      return new Complex(
              Math.sin(a) / d,
              sinh(b) / d);
    },

    /**
     * Calculate the cotangent
     *
     * @returns {Complex}
     */
    'cot': function() {

      // cot(c) = i(e^(ci) + e^(-ci)) / (e^(ci) - e^(-ci))

      var a = 2 * this['re'];
      var b = 2 * this['im'];
      var d = Math.cos(a) - cosh(b);

      return new Complex(
              -Math.sin(a) / d,
              sinh(b) / d);
    },

    /**
     * Calculate the secant
     *
     * @returns {Complex}
     */
    'sec': function() {

      // sec(c) = 2 / (e^(ci) + e^(-ci))

      var a = this['re'];
      var b = this['im'];
      var d = 0.5 * cosh(2 * b) + 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.cos(a) * cosh(b) / d,
              Math.sin(a) * sinh(b) / d);
    },

    /**
     * Calculate the cosecans
     *
     * @returns {Complex}
     */
    'csc': function() {

      // csc(c) = 2i / (e^(ci) - e^(-ci))

      var a = this['re'];
      var b = this['im'];
      var d = 0.5 * cosh(2 * b) - 0.5 * Math.cos(2 * a);

      return new Complex(
              Math.sin(a) * cosh(b) / d,
              -Math.cos(a) * sinh(b) / d);
    },

    /**
     * Calculate the complex arcus sinus
     *
     * @returns {Complex}
     */
    'asin': function() {

      // asin(c) = -i * log(ci + sqrt(1 - c^2))

      var a = this['re'];
      var b = this['im'];

      var t1 = new Complex(
              b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1['re'] - b,
              t1['im'] + a)['log']();

      return new Complex(t2['im'], -t2['re']);
    },

    /**
     * Calculate the complex arcus cosinus
     *
     * @returns {Complex}
     */
    'acos': function() {

      // acos(c) = i * log(c - i * sqrt(1 - c^2))

      var a = this['re'];
      var b = this['im'];

      var t1 = new Complex(
              b * b - a * a + 1,
              -2 * a * b)['sqrt']();

      var t2 = new Complex(
              t1['re'] - b,
              t1['im'] + a)['log']();

      return new Complex(Math.PI / 2 - t2['im'], t2['re']);
    },

    /**
     * Calculate the complex arcus tangent
     *
     * @returns {Complex}
     */
    'atan': function() {

      // atan(c) = i / 2 log((i + x) / (i - x))

      var a = this['re'];
      var b = this['im'];

      if (a === 0) {

        if (b === 1) {
          return new Complex(0, Infinity);
        }

        if (b === -1) {
          return new Complex(0, -Infinity);
        }
      }

      var d = a * a + (1.0 - b) * (1.0 - b);

      var t1 = new Complex(
              (1 - b * b - a * a) / d,
              -2 * a / d).log();

      return new Complex(-0.5 * t1['im'], 0.5 * t1['re']);
    },

    /**
     * Calculate the complex arcus cotangent
     *
     * @returns {Complex}
     */
    'acot': function() {

      // acot(c) = i / 2 log((c - i) / (c + i))

      var a = this['re'];
      var b = this['im'];

      if (b === 0) {
        return new Complex(Math.atan2(1, a), 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).atan()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).atan();
    },

    /**
     * Calculate the complex arcus secant
     *
     * @returns {Complex}
     */
    'asec': function() {

      // asec(c) = -i * log(1 / c + sqrt(1 - i / c^2))

      var a = this['re'];
      var b = this['im'];

      if (a === 0 && b === 0) {
        return new Complex(0, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).acos()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).acos();
    },

    /**
     * Calculate the complex arcus cosecans
     *
     * @returns {Complex}
     */
    'acsc': function() {

      // acsc(c) = -i * log(i / c + sqrt(1 - 1 / c^2))

      var a = this['re'];
      var b = this['im'];

      if (a === 0 && b === 0) {
        return new Complex(Math.PI / 2, Infinity);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).asin()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).asin();
    },

    /**
     * Calculate the complex sinh
     *
     * @returns {Complex}
     */
    'sinh': function() {

      // sinh(c) = (e^c - e^-c) / 2

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              sinh(a) * Math.cos(b),
              cosh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex cosh
     *
     * @returns {Complex}
     */
    'cosh': function() {

      // cosh(c) = (e^c + e^-c) / 2

      var a = this['re'];
      var b = this['im'];

      return new Complex(
              cosh(a) * Math.cos(b),
              sinh(a) * Math.sin(b));
    },

    /**
     * Calculate the complex tanh
     *
     * @returns {Complex}
     */
    'tanh': function() {

      // tanh(c) = (e^c - e^-c) / (e^c + e^-c)

      var a = 2 * this['re'];
      var b = 2 * this['im'];
      var d = cosh(a) + Math.cos(b);

      return new Complex(
              sinh(a) / d,
              Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    'coth': function() {

      // coth(c) = (e^c + e^-c) / (e^c - e^-c)

      var a = 2 * this['re'];
      var b = 2 * this['im'];
      var d = cosh(a) - Math.cos(b);

      return new Complex(
              sinh(a) / d,
              -Math.sin(b) / d);
    },

    /**
     * Calculate the complex coth
     *
     * @returns {Complex}
     */
    'csch': function() {

      // csch(c) = 2 / (e^c - e^-c)

      var a = this['re'];
      var b = this['im'];
      var d = Math.cos(2 * b) - cosh(2 * a);

      return new Complex(
              -2 * sinh(a) * Math.cos(b) / d,
              2 * cosh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex sech
     *
     * @returns {Complex}
     */
    'sech': function() {

      // sech(c) = 2 / (e^c + e^-c)

      var a = this['re'];
      var b = this['im'];
      var d = Math.cos(2 * b) + cosh(2 * a);

      return new Complex(
              2 * cosh(a) * Math.cos(b) / d,
              -2 * sinh(a) * Math.sin(b) / d);
    },

    /**
     * Calculate the complex asinh
     *
     * @returns {Complex}
     */
    'asinh': function() {

      // asinh(c) = log(c + sqrt(c^2 + 1))

      var tmp = this['im'];
      this['im'] = -this['re'];
      this['re'] = tmp;
      var res = this['asin']();

      this['re'] = -this['im'];
      this['im'] = tmp;
      tmp = res['re'];

      res['re'] = -res['im'];
      res['im'] = tmp;
      return res;
    },

    /**
     * Calculate the complex acosh
     *
     * @returns {Complex}
     */
    'acosh': function() {

      // acosh(c) = log(c + sqrt(c^2 - 1))

      var res = this['acos']();
      if (res['im'] <= 0) {
        var tmp = res['re'];
        res['re'] = -res['im'];
        res['im'] = tmp;
      } else {
        var tmp = res['im'];
        res['im'] = -res['re'];
        res['re'] = tmp;
      }
      return res;
    },

    /**
     * Calculate the complex atanh
     *
     * @returns {Complex}
     */
    'atanh': function() {

      // atanh(c) = log((1+c) / (1-c)) / 2

      var a = this['re'];
      var b = this['im'];

      var noIM = a > 1 && b === 0;
      var oneMinus = 1 - a;
      var onePlus = 1 + a;
      var d = oneMinus * oneMinus + b * b;

      var x = (d !== 0)
              ? new Complex(
                      (onePlus * oneMinus - b * b) / d,
                      (b * oneMinus + onePlus * b) / d)
              : new Complex(
                      (a !== -1) ? (a / 0) : 0,
                      (b !== 0) ? (b / 0) : 0);

      var temp = x['re'];
      x['re'] = logHypot(x['re'], x['im']) / 2;
      x['im'] = Math.atan2(x['im'], temp) / 2;
      if (noIM) {
        x['im'] = -x['im'];
      }
      return x;
    },

    /**
     * Calculate the complex acoth
     *
     * @returns {Complex}
     */
    'acoth': function() {

      // acoth(c) = log((c+1) / (c-1)) / 2

      var a = this['re'];
      var b = this['im'];

      if (a === 0 && b === 0) {
        return new Complex(0, Math.PI / 2);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).atanh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).atanh();
    },

    /**
     * Calculate the complex acsch
     *
     * @returns {Complex}
     */
    'acsch': function() {

      // acsch(c) = log((1+sqrt(1+c^2))/c)

      var a = this['re'];
      var b = this['im'];

      if (b === 0) {

        return new Complex(
                (a !== 0)
                ? Math.log(a + Math.sqrt(a * a + 1))
                : Infinity, 0);
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).asinh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).asinh();
    },

    /**
     * Calculate the complex asech
     *
     * @returns {Complex}
     */
    'asech': function() {

      // asech(c) = log((1+sqrt(1-c^2))/c)

      var a = this['re'];
      var b = this['im'];

      if (this['isZero']()) {
        return Complex['INFINITY'];
      }

      var d = a * a + b * b;
      return (d !== 0)
              ? new Complex(
                      a / d,
                      -b / d).acosh()
              : new Complex(
                      (a !== 0) ? a / 0 : 0,
                      (b !== 0) ? -b / 0 : 0).acosh();
    },

    /**
     * Calculate the complex inverse 1/z
     *
     * @returns {Complex}
     */
    'inverse': function() {

      // 1 / 0 = Infinity and 1 / Infinity = 0
      if (this['isZero']()) {
        return Complex['INFINITY'];
      }

      if (this['isInfinite']()) {
        return Complex['ZERO'];
      }

      var a = this['re'];
      var b = this['im'];

      var d = a * a + b * b;

      return new Complex(a / d, -b / d);
    },

    /**
     * Returns the complex conjugate
     *
     * @returns {Complex}
     */
    'conjugate': function() {

      return new Complex(this['re'], -this['im']);
    },

    /**
     * Gets the negated complex number
     *
     * @returns {Complex}
     */
    'neg': function() {

      return new Complex(-this['re'], -this['im']);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    'ceil': function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.ceil(this['re'] * places) / places,
              Math.ceil(this['im'] * places) / places);
    },

    /**
     * Floors the actual complex number
     *
     * @returns {Complex}
     */
    'floor': function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.floor(this['re'] * places) / places,
              Math.floor(this['im'] * places) / places);
    },

    /**
     * Ceils the actual complex number
     *
     * @returns {Complex}
     */
    'round': function(places) {

      places = Math.pow(10, places || 0);

      return new Complex(
              Math.round(this['re'] * places) / places,
              Math.round(this['im'] * places) / places);
    },

    /**
     * Compares two complex numbers
     *
     * **Note:** new Complex(Infinity).equals(Infinity) === false
     *
     * @returns {boolean}
     */
    'equals': function(a, b) {

      var z = new Complex(a, b);

      return Math.abs(z['re'] - this['re']) <= Complex['EPSILON'] &&
              Math.abs(z['im'] - this['im']) <= Complex['EPSILON'];
    },

    /**
     * Clones the actual object
     *
     * @returns {Complex}
     */
    'clone': function() {

      return new Complex(this['re'], this['im']);
    },

    /**
     * Gets a string of the actual complex number
     *
     * @returns {string}
     */
    'toString': function() {

      var a = this['re'];
      var b = this['im'];
      var ret = "";

      if (this['isNaN']()) {
        return 'NaN';
      }

      if (this['isInfinite']()) {
        return 'Infinity';
      }

      if (Math.abs(a) < Complex['EPSILON']) {
        a = 0;
      }

      if (Math.abs(b) < Complex['EPSILON']) {
        b = 0;
      }

      // If is real number
      if (b === 0) {
        return ret + a;
      }

      if (a !== 0) {
        ret+= a;
        ret+= " ";
        if (b < 0) {
          b = -b;
          ret+= "-";
        } else {
          ret+= "+";
        }
        ret+= " ";
      } else if (b < 0) {
        b = -b;
        ret+= "-";
      }

      if (1 !== b) { // b is the absolute imaginary part
        ret+= b;
      }
      return ret + "i";
    },

    /**
     * Returns the actual number as a vector
     *
     * @returns {Array}
     */
    'toVector': function() {

      return [this['re'], this['im']];
    },

    /**
     * Returns the actual real value of the current object
     *
     * @returns {number|null}
     */
    'valueOf': function() {

      if (this['im'] === 0) {
        return this['re'];
      }
      return null;
    },

    /**
     * Determines whether a complex number is not on the Riemann sphere.
     *
     * @returns {boolean}
     */
    'isNaN': function() {
      return isNaN(this['re']) || isNaN(this['im']);
    },

    /**
     * Determines whether or not a complex number is at the zero pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    'isZero': function() {
      return this['im'] === 0 && this['re'] === 0;
    },

    /**
     * Determines whether a complex number is not at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    'isFinite': function() {
      return isFinite(this['re']) && isFinite(this['im']);
    },

    /**
     * Determines whether or not a complex number is at the infinity pole of the
     * Riemann sphere.
     *
     * @returns {boolean}
     */
    'isInfinite': function() {
      return !(this['isNaN']() || this['isFinite']());
    }
  };

  Complex['ZERO'] = new Complex(0, 0);
  Complex['ONE'] = new Complex(1, 0);
  Complex['I'] = new Complex(0, 1);
  Complex['PI'] = new Complex(Math.PI, 0);
  Complex['E'] = new Complex(Math.E, 0);
  Complex['INFINITY'] = new Complex(Infinity, Infinity);
  Complex['NAN'] = new Complex(NaN, NaN);
  Complex['EPSILON'] = 1e-15;

  {
    Object.defineProperty(Complex, "__esModule", {'value': true});
    Complex['default'] = Complex;
    Complex['Complex'] = Complex;
    module['exports'] = Complex;
  }

})();
}(complex));

const DECIMAL_ZERO = new decimal.exports.Decimal(0);
const DECIMAL_ONE = new decimal.exports.Decimal(1);
const DECIMAL_MINUS_ONE = new decimal.exports.Decimal(-1);
const DECIMAL_NAN = new decimal.exports.Decimal(NaN);
const DECIMAL_POS_INFINITY = new decimal.exports.Decimal(+Infinity);
const DECIMAL_NEG_INFINITY = new decimal.exports.Decimal(-Infinity);
function factorial$1(n) {
    if (typeof n === 'number')
        n = new decimal.exports.Decimal(n);
    if (!n.isInteger() || n.isNegative())
        return DECIMAL_NAN;
    if (n.lessThan(10)) {
        return new decimal.exports.Decimal([1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800][n.toNumber()]);
    }
    if (n.gt(Number.MAX_SAFE_INTEGER)) {
        let val = DECIMAL_ONE;
        let i = new decimal.exports.Decimal(2);
        while (i.lessThan(n)) {
            val = val.mul(i);
            i = i.add(1);
        }
        return val;
    }
    if (n.modulo(2).eq(1)) {
        return n.times(factorial$1(n.minus(1)));
    }
    let loop = n.toNumber();
    let sum = n.toNumber();
    let val = n;
    while (loop > 2) {
        loop -= 2;
        sum += loop;
        val = val.mul(sum);
    }
    return val;
}
const gammaG$1 = 7;
const p$1 = [
    0.99999999999980993, 676.5203681218851, -1259.1392167224028,
    771.32342877765313, -176.61502916214059, 12.507343278686905,
    -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
].map((x) => new decimal.exports.Decimal(x));
const gammaGLn$1 = new decimal.exports.Decimal(607).div(128);
const gammaPLn$1 = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5,
].map((x) => new decimal.exports.Decimal(x));
// Spouge approximation (suitable for large arguments)
function lngamma$1(z) {
    if (typeof z === 'number')
        z = new decimal.exports.Decimal(z);
    if (z.isNegative())
        return DECIMAL_NAN;
    let x = gammaPLn$1[0];
    for (let i = gammaPLn$1.length - 1; i > 0; --i) {
        x = x.add(gammaPLn$1[i].div(z.add(i)));
    }
    const t = z.add(gammaGLn$1).add(0.5);
    return decimal.exports.Decimal.acos(-1)
        .mul(2)
        .log()
        .mul(0.5)
        .add(t.log().mul(z.add(0.5)).minus(t).add(x.log()).minus(z.log()));
}
// From https://github.com/substack/gamma.js/blob/master/index.js
function gamma$2(z) {
    if (typeof z === 'number')
        z = new decimal.exports.Decimal(z);
    if (z.lessThan(0.5)) {
        const pi = decimal.exports.Decimal.acos(-1);
        return pi.div(pi
            .mul(z)
            .sin()
            .mul(gamma$2(decimal.exports.Decimal.sub(1, z))));
    }
    else if (z.greaterThan(100)) {
        return lngamma$1(z).exp();
    }
    else {
        z = z.sub(1);
        let x = p$1[0];
        for (let i = 1; i < gammaG$1 + 2; i++) {
            x = x.add(p$1[i].div(z.add(i)));
        }
        const t = z.add(gammaG$1).add(0.5);
        return decimal.exports.Decimal.acos(-1)
            .times(2)
            .sqrt()
            .mul(x.mul(t.neg().exp()).mul(decimal.exports.Decimal.pow(t, z.add(0.5))));
    }
}

function gcd(a, b) {
    //https://github.com/Yaffle/bigint-gcd/blob/main/gcd.js
    if (!Number.isInteger(a) || !Number.isInteger(b))
        return NaN;
    while (b !== 0)
        [a, b] = [b, a % b];
    return a < 0 ? -a : a;
}
function factorial(n) {
    if (!Number.isInteger(n) || n < 0)
        return NaN;
    let val = 1;
    for (let i = 2; i <= n; i++)
        val = val * i;
    return val;
}
const gammaG = 7;
const p = [
    0.99999999999980993, 676.5203681218851, -1259.1392167224028,
    771.32342877765313, -176.61502916214059, 12.507343278686905,
    -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7,
];
const gammaGLn = 607 / 128;
const gammaPLn = [
    0.99999999999999709182, 57.156235665862923517, -59.597960355475491248,
    14.136097974741747174, -0.49191381609762019978, 0.33994649984811888699e-4,
    0.46523628927048575665e-4, -0.98374475304879564677e-4,
    0.15808870322491248884e-3, -0.21026444172410488319e-3,
    0.2174396181152126432e-3, -0.16431810653676389022e-3,
    0.84418223983852743293e-4, -0.2619083840158140867e-4,
    0.36899182659531622704e-5,
];
// Spouge approximation (suitable for large arguments)
function lngamma(z) {
    if (z < 0)
        return NaN;
    let x = gammaPLn[0];
    for (let i = gammaPLn.length - 1; i > 0; --i)
        x += gammaPLn[i] / (z + i);
    const t = z + gammaGLn + 0.5;
    return (0.5 * Math.log(2 * Math.PI) +
        (z + 0.5) * Math.log(t) -
        t +
        Math.log(x) -
        Math.log(z));
}
// From https://github.com/substack/gamma.js/blob/master/index.js
function gamma$1(z) {
    if (z < 0.5) {
        return Math.PI / (Math.sin(Math.PI * z) * gamma$1(1 - z));
    }
    else if (z > 100) {
        return Math.exp(lngamma(z));
    }
    else {
        z -= 1;
        let x = p[0];
        for (let i = 1; i < gammaG + 2; i++) {
            x += p[i] / (z + i);
        }
        const t = z + gammaG + 0.5;
        return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
    }
}

/**
 * These constants are the 'primitive' functions and constants that are used
 * for some basic manipulations such as parsing, and transforming to canonical
 * form.
 *
 */
const PARENTHESES = 'Parentheses';
const LATEX_TOKENS = 'LatexTokens';
const LIST = 'List';
const MISSING = 'Missing';
const NOTHING = 'Nothing';
const SEQUENCE = 'Sequence';
const SEQUENCE2 = 'Sequence2';
const ADD = 'Add';
const DERIVATIVE = 'Derivative';
const DIVIDE = 'Divide';
const INVERSE_FUNCTION = 'InverseFunction';
const MULTIPLY = 'Multiply';
const NEGATE = 'Negate';
const POWER = 'Power';
const PRIME = 'Prime';
const ROOT = 'Root';
const SQRT = 'Sqrt';
const SUBTRACT = 'Subtract';
const COMPLEX_INFINITY = 'ComplexInfinity';
const PI = 'Pi';
const EXPONENTIAL_E = 'ExponentialE';
const IMAGINARY_UNIT = 'ImaginaryUnit';
function isNumberObject(expr) {
    return expr !== null && typeof expr === 'object' && 'num' in expr;
}
function isSymbolObject(expr) {
    return expr !== null && typeof expr === 'object' && 'sym' in expr;
}
function isFunctionObject(expr) {
    return expr !== null && typeof expr === 'object' && 'fn' in expr;
}
function getNumberValue(expr) {
    if (typeof expr === 'number')
        return expr;
    if (expr === null)
        return null;
    if (isNumberObject(expr)) {
        if (expr.num.endsWith('d') || expr.num.endsWith('n'))
            return null;
        return parseFloat(expr.num);
    }
    const symbol = getSymbolName(expr);
    if (symbol === null)
        return null;
    if (symbol === 'NaN')
        return NaN;
    if (symbol === '+Infinity')
        return Infinity;
    if (symbol === '-Infinity')
        return -Infinity;
    if (getFunctionName(expr) === 'Complex') {
        if (getNumberValue(getArg(expr, 2)) === 0) {
            return getNumberValue(getArg(expr, 1));
        }
    }
    return null;
}
/** Only return non-null if the expression is a Complex number.
 * Return null if it's a number, or a symbol (other than  `ImaginaryUnit` or
 * `ComplexInfinity`)
 *
 */
function getComplexValue(expr) {
    if (expr === null)
        return null;
    if (expr instanceof complex.exports.Complex)
        return expr;
    const symbol = getSymbolName(expr);
    if (symbol !== null) {
        if (symbol === 'ComplexInfinity')
            return complex.exports.Complex.INFINITY;
        if (symbol === IMAGINARY_UNIT)
            return complex.exports.Complex.I;
    }
    const name = getFunctionName(expr);
    if (name === 'Complex') {
        const re1 = getNumberValue(getArg(expr, 1));
        const im1 = getNumberValue(getArg(expr, 2));
        if (re1 === null || im1 === null)
            return null;
        return new complex.exports.Complex(re1, im1);
    }
    let im = getImaginaryValue(expr);
    if (im !== null)
        return new complex.exports.Complex(0, im);
    if (name === 'Add' && getArgCount(expr) === 2) {
        let re = getNumberValue(getArg(expr, 1));
        if (re !== null) {
            im = getImaginaryValue(getArg(expr, 2));
        }
        else {
            im = getImaginaryValue(getArg(expr, 1));
            if (im !== null) {
                re = getNumberValue(getArg(expr, 2));
            }
        }
        if (re !== null && im !== null)
            return new complex.exports.Complex(re, im);
    }
    if (name === 'Subtract') {
        const re = getNumberValue(getArg(expr, 1));
        const arg2 = getArg(expr, 2);
        if (re !== null) {
            if (getSymbolName(arg2) === IMAGINARY_UNIT) {
                return new complex.exports.Complex(re, -1);
            }
            if (getFunctionName(arg2) === 'Multiply' &&
                getArg(arg2, 2) === IMAGINARY_UNIT) {
                const im = getNumberValue(getArg(arg2, 1));
                if (im !== null)
                    return new complex.exports.Complex(re, -im);
            }
        }
    }
    if (name === 'Multiply' && getArgCount(expr) === 2) {
        let factor = null;
        if (getSymbolName(getArg(expr, 2)) === IMAGINARY_UNIT) {
            factor = getNumberValue(getArg(expr, 2));
        }
        else if (getSymbolName(getArg(expr, 1)) === IMAGINARY_UNIT) {
            factor = getNumberValue(getArg(expr, 1));
        }
        if (factor !== null && Number.isInteger(factor)) {
            if (factor === 0)
                return complex.exports.Complex.ZERO;
            if (factor === 1)
                return complex.exports.Complex.ONE;
            if (factor === -1)
                return complex.exports.Complex.ONE.neg();
            return new complex.exports.Complex(0, factor);
        }
    }
    if (name === 'Negate') {
        const c = getComplexValue(getArg(expr, 1));
        if (c !== null)
            return c.neg();
    }
    return null;
}
/**
 * Return a multiple of the imaginary unit, e.g.
 * - 'ImaginaryUnit'
 * - ['Negate', 'ImaginaryUnit']
 * - ['Multiply', 5, 'ImaginaryUnit']
 * - ['Multiply', 'ImaginaryUnit', 5]
 */
function getImaginaryValue(expr) {
    if (getSymbolName(expr) === 'ImaginaryUnit')
        return 1;
    let val = null;
    const name = getFunctionName(expr);
    if (name === 'Multiply' && getArgCount(expr) === 2) {
        if (getSymbolName(getArg(expr, 1)) === 'ImaginaryUnit') {
            val = getNumberValue(getArg(expr, 2));
        }
        else if (getSymbolName(getArg(expr, 2)) === 'ImaginaryUnit') {
            val = getNumberValue(getArg(expr, 1));
        }
    }
    else if (name === 'Negate' && getArgCount(expr) === 1) {
        if (getSymbolName(getArg(expr, 1)) === 'ImaginaryUnit') {
            val = -1;
        }
    }
    return val === 0 ? null : val;
}
function getDecimalValue(expr) {
    var _a, _b;
    if (expr instanceof decimal.exports.Decimal)
        return expr;
    const symbol = getSymbolName(expr);
    if (symbol !== null) {
        if (symbol === 'NaN')
            return DECIMAL_NAN;
        if (symbol === '+Infinity')
            return DECIMAL_POS_INFINITY;
        if (symbol === '-Infinity')
            return DECIMAL_NEG_INFINITY;
    }
    if (isNumberObject(expr)) {
        if (expr.num.endsWith('d') || expr.num.endsWith('n')) {
            return new decimal.exports.Decimal(expr.num.slice(0, -1));
        }
        return new decimal.exports.Decimal((_a = getNumberValue(expr)) !== null && _a !== void 0 ? _a : NaN);
    }
    if (expr !== null && expr instanceof complex.exports.Complex) {
        const c = expr;
        if (c.im === 0)
            return new decimal.exports.Decimal(c.re);
        return null;
    }
    if (getFunctionName(expr) === 'Complex') {
        if (getNumberValue(getArg(expr, 2)) === 0) {
            return new decimal.exports.Decimal((_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : NaN);
        }
    }
    return null;
}
/**  If expr is a string literal, return it.
 *
 * A string literal is a JSON string that begins and ends with
 * **U+0027 APOSTROPHE** : **`'`** or an object literal with a `str` key.
 */
function getStringValue(expr) {
    if (expr === null)
        return null;
    if (typeof expr === 'object' && 'str' in expr)
        return expr.str;
    if (typeof expr !== 'string')
        return null;
    if (expr.length < 2)
        return null;
    if (expr[0] !== "'" || expr[expr.length - 1] !== "'")
        return null;
    return expr.substring(1, expr.length - 1);
}
/**
 * Return a rational (numer over denom) representation of the expression,
 * if possible, `[null, null]` otherwise.
 *
 * The expression can be:
 * - Some symbols: "ThreeQuarte", "Half"...
 * - ["Power", d, -1]
 * - ["Power", n, 1]
 * - ["Divide", n, d]
 *
 * The denominator is always > 0.
 */
function getRationalValue(expr) {
    var _a, _b, _c, _d, _e, _f;
    const symbol = getSymbolName(expr);
    if (symbol === 'ThreeQuarter')
        return [3, 4];
    if (symbol === 'TwoThird')
        return [2, 3];
    if (symbol === 'Half')
        return [1, 2];
    if (symbol === 'Third')
        return [1, 3];
    if (symbol === 'Quarter')
        return [1, 4];
    if (isAtomic(expr))
        return [null, null];
    const head = getFunctionName(expr);
    if (!head)
        return [null, null];
    let numer = null;
    let denom = null;
    if (head === POWER) {
        const exponent = getNumberValue(getArg(expr, 2));
        if (exponent === 1) {
            numer = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : null;
            denom = 1;
        }
        else if (exponent === -1) {
            numer = 1;
            denom = (_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : null;
        }
    }
    if (head === DIVIDE) {
        numer = (_c = getNumberValue(getArg(expr, 1))) !== null && _c !== void 0 ? _c : null;
        denom = (_d = getNumberValue(getArg(expr, 2))) !== null && _d !== void 0 ? _d : null;
    }
    if (head === MULTIPLY &&
        getFunctionName(getArg(expr, 2)) === POWER &&
        getNumberValue(getArg(getArg(expr, 2), 2)) === -1) {
        numer = (_e = getNumberValue(getArg(expr, 1))) !== null && _e !== void 0 ? _e : null;
        denom = (_f = getNumberValue(getArg(getArg(expr, 2), 1))) !== null && _f !== void 0 ? _f : null;
    }
    if (numer === null || denom === null)
        return [null, null];
    if (Number.isInteger(numer) && Number.isInteger(denom)) {
        return [numer, denom];
    }
    return [null, null];
}
/** True if the expression is of the form \frac{n}{m} where n and m are both integers
 *
 * Note this detects fewer patterns than `getRationalValue()`, but it is
 * intended to detect rational numbers used with invisible plus, i.e. `1\frac{1}{2}`
 *
 */
function isRationalNumber(expr) {
    var _a, _b;
    const symbol = getSymbolName(expr);
    if (symbol !== null &&
        ['ThreeQuarter', 'TwoThird', 'Half', 'Third', 'Quarter'].includes(symbol)) {
        return true;
    }
    if (getFunctionName(expr) !== DIVIDE)
        return false;
    const numer = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : NaN;
    const denom = (_b = getNumberValue(getArg(expr, 2))) !== null && _b !== void 0 ? _b : NaN;
    return Number.isInteger(numer) && Number.isInteger(denom);
}
/**
 * The head of a function can be a string or an expression.
 *
 * Return `null` if the expression is not a function.
 *
 * Examples:
 * * `["Negate", 5]`  -> `"Negate"`
 * * `[["Prime", "f"], "x"]` -> `["Prime", "f"]`
 */
function getFunctionHead(expr) {
    if (expr === null)
        return null;
    if (Array.isArray(expr))
        return expr[0];
    if (isFunctionObject(expr))
        return expr.fn[0];
    return null;
}
/**
 * True if the expression is a number, a symbol or a string
 * (i.e. not a function and not a dictionary)
 */
function isAtomic(expr) {
    return (expr === null ||
        (!Array.isArray(expr) &&
            (typeof expr !== 'object' || !('fn' in expr || 'dic' in expr))));
}
function getFunctionName(expr) {
    if (expr === null)
        return '';
    const head = getFunctionHead(expr);
    if (typeof head === 'string')
        return head;
    return '';
}
function getSymbolName(expr) {
    if (expr === null)
        return null;
    if (typeof expr === 'string') {
        if (expr.length >= 2 && expr[0] === "'" && expr[expr.length - 1] === "'") {
            // It's a string literal, not a symbol
            return null;
        }
        return expr;
    }
    if (isSymbolObject(expr))
        return expr.sym;
    return null;
}
/**
 * Return all the elements but the first one, i.e. the arguments of a
 * function.
 */
function getTail(expr) {
    if (Array.isArray(expr)) {
        return expr.slice(1);
    }
    if (isFunctionObject(expr)) {
        return expr.fn.slice(1);
    }
    return [];
}
function applyRecursively(expr, fn) {
    const head = getFunctionHead(expr);
    if (head !== null) {
        return [fn(head), ...getTail(expr).map(fn)];
    }
    const dict = getDictionary(expr);
    if (dict !== null) {
        const keys = Object.keys(dict);
        const result = {};
        for (const key of keys)
            result[key] = fn(dict[key]);
        return { dict: result };
    }
    return fn(expr);
}
/**
 * Apply a function to the arguments of a function and return an array of T
 */
function mapArgs(expr, fn) {
    let args = null;
    if (Array.isArray(expr))
        args = expr;
    if (isFunctionObject(expr))
        args = expr.fn;
    if (args === null)
        return [];
    let i = 1;
    const result = [];
    while (i < args.length) {
        result.push(fn(args[i]));
        i += 1;
    }
    return result;
}
function getArg(expr, n) {
    var _a, _b;
    if (expr === null)
        return null;
    if (Array.isArray(expr))
        return (_a = expr[n]) !== null && _a !== void 0 ? _a : null;
    if (isFunctionObject(expr))
        return (_b = expr.fn[n]) !== null && _b !== void 0 ? _b : null;
    return null;
}
function getArgCount(expr) {
    if (Array.isArray(expr)) {
        return Math.max(0, expr.length - 1);
    }
    if (isFunctionObject(expr)) {
        return Math.max(0, expr.fn.length - 1);
    }
    return 0;
}
function getDictionary(expr) {
    if (typeof expr === 'object' && 'dict' in expr)
        return expr.dict;
    return null;
}

const DEFINITIONS_OTHERS = [
    {
        name: 'Overscript',
        trigger: { infix: '\\overset' },
        precedence: 700, // @todo: not in MathML
    },
    {
        name: 'Underscript',
        trigger: { infix: '\\underset' },
        precedence: 700, // @todo: not in MathML
    },
    {
        name: 'Increment',
        trigger: { postfix: ['+', '+'] },
        precedence: 880,
    },
    {
        name: 'Decrement',
        trigger: { postfix: ['-', '-'] },
        precedence: 880,
    },
    {
        name: 'PreIncrement',
        trigger: { prefix: ['+', '+'] },
        precedence: 880,
    },
    {
        name: 'PreDecrement',
        trigger: { prefix: ['-', '-'] },
        precedence: 880,
    },
    {
        name: 'Ring',
        trigger: { infix: '\\circ' },
        precedence: 265,
    },
    {
        // @todo: if lhs is a list/tensor
        name: 'Transpose',
        trigger: { superfix: 'T' },
    },
    {
        // @todo: if lhs is a list/tensor
        name: 'ConjugateTranspose',
        trigger: { superfix: 'H' },
    },
    {
        name: 'StringJoin',
        trigger: { infix: ['\\lt', '\\gt'] },
        precedence: 780,
    },
    {
        name: 'Starstar',
        trigger: { infix: ['\\star', '\\star'] },
        precedence: 780,
    },
    {
        // Partial derivative using a variation of the Euler notation: `∂_xf(x)`
        // (the Euler notation uses `D_1f(x)` where "1" is for the first variable
        // For the Leibniz notation see 'Divide' that handles `∂f/∂x`
        name: 'PartialDerivative',
        trigger: { prefix: '\\partial' },
        parse: (lhs, scanner, _minPrec) => {
            var _a, _b;
            let done = false;
            let sup = NOTHING;
            let sub = NOTHING;
            while (!done) {
                scanner.skipSpace();
                if (scanner.match('_')) {
                    sub = scanner.matchRequiredLatexArgument();
                }
                else if (scanner.match('^')) {
                    sup = scanner.matchRequiredLatexArgument();
                }
                else {
                    done = true;
                }
            }
            if (getFunctionName(sub) === SEQUENCE) {
                sub = [LIST, ...getTail(sub)];
            }
            if (!sub || !sup)
                return [lhs, null];
            let rhs = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : NOTHING;
            if (rhs !== NOTHING) {
                const arg = (_b = scanner.matchArguments('group')) !== null && _b !== void 0 ? _b : NOTHING;
                rhs = [rhs, ...arg];
            }
            return [null, ['PartialDerivative', rhs, sub, sup]];
        },
        serialize: (serializer, expr) => {
            let result = '\\partial';
            const fn = getArg(expr, 1);
            const vars = getArg(expr, 2);
            const degree = getArg(expr, 3);
            if (vars !== null && vars !== NOTHING) {
                if (getFunctionHead(vars) === LIST) {
                    result +=
                        '_{' + serializer.serialize([SEQUENCE, ...getTail(vars)]) + '}';
                }
                else {
                    result += '_{' + serializer.serialize(vars) + '}';
                }
            }
            if (degree !== null && degree !== NOTHING) {
                result += '^{' + serializer.serialize(degree) + '}';
            }
            if (fn !== null && fn !== NOTHING) {
                result += serializer.serialize(fn);
            }
            return result;
        },
        precedence: 740,
    },
    {
        name: 'OverBar',
        trigger: { symbol: '\\overline' },
        requiredLatexArg: 1,
    },
    {
        name: 'UnderBar',
        trigger: { symbol: '\\underline' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverVector',
        trigger: { symbol: '\\vec' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverTile',
        trigger: { symbol: '\\tilde' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverHat',
        trigger: { symbol: '\\hat' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverHat',
        trigger: { symbol: '\\hat' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverRightArrow',
        trigger: { symbol: '\\overrightarrow' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverLeftArrow',
        trigger: { symbol: '\\overleftarrow' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverRightDoubleArrow',
        trigger: { symbol: '\\Overrightarrow' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverLeftHarpoon',
        trigger: { symbol: '\\overleftharpoon' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverRightHarpoon',
        trigger: { symbol: '\\overrightharpoon' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverLeftRightArrow',
        trigger: { symbol: '\\overleftrightarrow' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverBrace',
        trigger: { symbol: '\\overbrace' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverLineSegment',
        trigger: { symbol: '\\overlinesegment' },
        requiredLatexArg: 1,
    },
    {
        name: 'OverGroup',
        trigger: { symbol: '\\overgroup' },
        requiredLatexArg: 1,
    },
    // {
    //     name: '',
    //     trigger: { symbol: '\\mathring' },
    //     requiredLatexArg: 1,
    // },
    // {
    //     name: '',
    //     trigger: { symbol: '\\check' },
    //     requiredLatexArg: 1,
    // },
];
// https://reference.wolfram.com/language/tutorial/TextualInputAndOutput.html

function getApplyFunctionStyle(_expr, _level) {
    return 'paren';
}
function getGroupStyle(_expr, _level) {
    return 'paren';
}
function getRootStyle(_expr, level) {
    if (level > 2)
        return 'solidus';
    return 'radical';
}
function getFractionStyle(_expr, level) {
    if (level > 3)
        return 'inline-solidus';
    return 'quotient';
}

function isSpacingToken(token) {
    return (token === '<space>' ||
        token === '\\qquad' ||
        token === '\\quad' ||
        token === '\\enskip' ||
        token === '\\;' ||
        token === '\\,' ||
        token === '\\ ' ||
        token === '~');
}
/**
 * Parse a sequence of expressions separated with ',' or ';'.
 * - ',' indicate a simple sequence
 * - ';' indicate a sequence of sequences
 */
function parseSequence(head, prec, sep) {
    return (lhs, scanner, minPrec) => {
        if (minPrec >= prec)
            return [lhs, null];
        scanner.skipSpace();
        scanner.match(sep);
        if (lhs === 'Missing')
            lhs = NOTHING;
        const result = [head, lhs !== null && lhs !== void 0 ? lhs : NOTHING];
        let done = false;
        while (!done) {
            done = true;
            scanner.skipSpace();
            while (scanner.match(sep)) {
                result.push(NOTHING);
                scanner.skipSpace();
            }
            if (scanner.atEnd) {
                result.push(NOTHING);
            }
            else {
                const rhs = scanner.matchExpression(prec);
                result.push(rhs !== null && rhs !== void 0 ? rhs : NOTHING);
                done = rhs === null;
            }
            if (!done) {
                scanner.skipSpace();
                done = !scanner.match(sep);
            }
        }
        return [null, result];
    };
}
function serializeSequence(sep) {
    return (serializer, expr) => {
        return getTail(expr)
            .map((x) => serializer.serialize(x))
            .join(sep);
    };
}
function serializeLatex(serializer, expr) {
    console.assert(getFunctionHead(expr) === LATEX_TOKENS);
    // @todo: add onError handler to serialize()
    return getTail(expr)
        .map((x) => {
        const stringValue = getStringValue(x);
        // If not a string, serialize the expression to Latex
        if (stringValue === null)
            return serializer.serialize(x);
        if (stringValue === '<{>')
            return '{';
        if (stringValue === '<}>')
            return '}';
        if (stringValue === '<$>')
            return '$';
        if (stringValue === '<$$>')
            return '$$';
        if (stringValue === "<space>'")
            return ' ';
        return stringValue;
    })
        .join('');
}
const DEFINITIONS_CORE = [
    { name: LATEX_TOKENS, serialize: serializeLatex },
    {
        name: PARENTHESES,
        trigger: { matchfix: '(' },
        parse: (lhs, scanner, _minPrec) => {
            var _a;
            const originalIndex = scanner.index;
            if (!scanner.match('('))
                return [lhs, null];
            //
            // 1. Attempt to scan a base-n number
            // i.e. `(deadbeef)_{16}`
            //
            let done = false;
            let couldBeBaseNumber = true;
            let wrappedInMathTt = false;
            let maxDigit = 0;
            let digits = '';
            while (!done && couldBeBaseNumber) {
                const token = scanner.next();
                if (scanner.atEnd || token === ')') {
                    done = true;
                }
                else if (token === '\\mathtt') {
                    scanner.match('<{>');
                    wrappedInMathTt = true;
                }
                else if (isSpacingToken(token)) ;
                else if (!/^[0-9a-zA-Z]$/.test(token)) {
                    couldBeBaseNumber = false;
                }
                else {
                    maxDigit = Math.max(maxDigit, parseInt(token, 36));
                    digits += token;
                }
                if (wrappedInMathTt) {
                    scanner.match('<}>');
                }
            }
            scanner.skipSpace();
            if (couldBeBaseNumber && scanner.match('_')) {
                const radix = (_a = getNumberValue(scanner.matchRequiredLatexArgument())) !== null && _a !== void 0 ? _a : NaN;
                if (!isFinite(radix) || radix < 2 || radix > 36 || maxDigit >= radix) {
                    scanner.onError({ code: 'base-out-of-range' });
                    return [lhs, NOTHING];
                }
                return [lhs, ['BaseForm', parseInt(digits, radix), radix]];
            }
            //
            // 2. It wasn't a number in a base. Scan a sequence
            //
            scanner.index = originalIndex;
            const seq = scanner.matchBalancedExpression('(', ')', scanner.onError);
            // If it's a simple sequence, 'upgrade it' to a group
            if (!seq)
                return [lhs, [PARENTHESES]];
            if (getFunctionName(seq) === SEQUENCE) {
                return [lhs, [PARENTHESES, ...getTail(seq)]];
            }
            return [lhs, [PARENTHESES, seq]];
        },
        serialize: (serializer, expr) => serializer.wrapString(serializeSequence(',')(serializer, expr), getGroupStyle(expr, serializer.level)),
        separator: ',',
        closeFence: ')',
        precedence: 20,
    },
    {
        name: LIST,
        trigger: { matchfix: '\\lbrack' },
        separator: ',',
        closeFence: '\\rbrack',
        precedence: 20,
        parse: (lhs, scanner, _minPrec) => {
            if (lhs === null) {
                // No lhs -> it's a list
                const seq = scanner.matchBalancedExpression('\\lbrack', '\\rbrack', scanner.onError);
                if (!seq)
                    return [null, [LIST]];
                if (getFunctionName(seq) === SEQUENCE) {
                    return [lhs, [LIST, ...getTail(seq)]];
                }
                return [lhs, [LIST, seq]];
            }
            return [lhs, null];
            // There is a lhs -> it might be an index accessor, i.e. `v[23]` @todo
        },
    },
    {
        name: 'BaseForm',
        serialize: (serializer, expr) => {
            var _a, _b;
            const radix = (_a = getNumberValue(getArg(expr, 2))) !== null && _a !== void 0 ? _a : NaN;
            if (isFinite(radix) && radix >= 2 && radix <= 36) {
                const num = (_b = getNumberValue(getArg(expr, 1))) !== null && _b !== void 0 ? _b : NaN;
                if (isFinite(num)) {
                    let digits = Number(num).toString(radix);
                    let groupLength = 0;
                    if (radix === 2) {
                        groupLength = 4;
                    }
                    else if (radix === 10) {
                        groupLength = 4;
                    }
                    else if (radix === 16) {
                        groupLength = 2;
                    }
                    else if (radix > 16) {
                        groupLength = 4;
                    }
                    if (groupLength > 0) {
                        const oldDigits = digits;
                        digits = '';
                        for (let i = 0; i < oldDigits.length; i++) {
                            if (i > 0 && i % groupLength === 0) {
                                digits = '\\, ' + digits;
                            }
                            digits = oldDigits[oldDigits.length - i - 1] + digits;
                        }
                    }
                    return `(\\mathtt{${digits}})_{${radix}}`;
                }
            }
            return ('\\operatorname{BaseForm}(' +
                serializer.serialize(getArg(expr, 1)) +
                ', ' +
                serializer.serialize(getArg(expr, 2)) +
                ')');
        },
    },
    {
        name: 'Set',
        trigger: { matchfix: '\\lbrace' },
        separator: ',',
        closeFence: '\\rbrace',
        precedence: 20,
    },
    {
        name: SEQUENCE,
        trigger: { infix: ',' },
        // Unlike the matchfix version of List,
        // when the comma operator is used, the lhs and rhs are flattened,
        // i.e. `1,2,3` -> `["Sequence", 1, 2, 3],
        // but `1, (2, 3)` -> ["Sequence", 1, ["Parentheses", 2, 3]]`
        parse: parseSequence(SEQUENCE, 20, ','),
        serialize: serializeSequence(', '),
        precedence: 20,
    },
    {
        name: SEQUENCE2,
        trigger: { infix: ';' },
        parse: parseSequence(SEQUENCE2, 19, ';'),
        serialize: serializeSequence('; '),
        precedence: 19,
    },
    {
        name: MISSING,
        trigger: '\\placeholder',
        serialize: '\\placeholder',
        requiredLatexArg: 1,
    },
    {
        name: 'Subscript',
        trigger: { infix: '_' },
        precedence: 720,
        serialize: (serializer, expr) => {
            if (getArgCount(expr) === 2) {
                return (serializer.serialize(getArg(expr, 1)) +
                    '_{' +
                    serializer.serialize(getArg(expr, 2)) +
                    '}');
            }
            return '_{' + serializer.serialize(getArg(expr, 1)) + '}';
        },
        parse: (lhs, scanner, _minPrec) => {
            var _a;
            if (!scanner.match('_'))
                return [lhs, null];
            const rhs = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : MISSING;
            if (!lhs)
                return [null, ['Subscript', rhs]];
            return [null, ['Subscript', lhs, rhs]];
        },
    },
    {
        name: 'Superplus',
        trigger: { superfix: '+' },
    },
    {
        name: 'Subplus',
        trigger: { subfix: '+' },
    },
    {
        name: 'Superminus',
        trigger: { superfix: '-' },
    },
    {
        name: 'Subminus',
        trigger: { subfix: '-' },
    },
    {
        // @todo: when lhs is a complex number, 'Conjugate'
        name: 'Superstar',
        trigger: { superfix: '*' },
    },
    {
        // @todo: when lhs is a complex number, 'Conjugate'
        name: 'Superstar',
        trigger: { superfix: '\\star' },
    },
    {
        name: 'Substar',
        trigger: { subfix: '*' },
    },
    {
        name: 'Substar',
        trigger: { subfix: '\\star' },
    },
    {
        name: 'Superdagger',
        trigger: { superfix: '\\dagger' },
    },
    {
        name: 'Superdagger',
        trigger: { superfix: '\\dag' },
    },
    {
        name: PRIME,
        trigger: { superfix: '\\prime' },
        arguments: 'group',
    },
    {
        // name: 'prime',
        trigger: { superfix: '\\doubleprime' },
        parse: (lhs, _scanner) => {
            return [null, [PRIME, lhs !== null && lhs !== void 0 ? lhs : NOTHING, 2]];
        },
        arguments: 'group',
    },
    {
        name: INVERSE_FUNCTION,
        serialize: (serializer, expr) => {
            return serializer.serialize(getArg(expr, 1)) + '^{-1}';
        },
    },
    {
        name: DERIVATIVE,
        trigger: 'D',
        parse: (lhs, _scanner) => {
            return [lhs, [DERIVATIVE, 1]];
        },
        serialize: (serializer, expr) => {
            var _a;
            const degree = (_a = getNumberValue(getArg(expr, 1))) !== null && _a !== void 0 ? _a : NaN;
            if (!isFinite(degree))
                return '';
            const base = serializer.serialize(getArg(expr, 2));
            if (degree === 1) {
                return base + '^{\\prime}';
            }
            else if (degree === 2) {
                return base + '^{\\doubleprime}';
            }
            return base + '^{(' + Number(degree).toString() + ')}';
        },
    },
    {
        name: 'Piecewise',
        trigger: { environment: 'cases' },
        parse: (lhs, scanner) => {
            var _a;
            return [lhs, ['Piecewise', (_a = scanner.matchTabular()) !== null && _a !== void 0 ? _a : NOTHING]];
        },
        serialize: (serialize, expr) => {
            if (getFunctionName(getArg(expr, 1)) !== LIST)
                return '';
            const rows = getTail(getArg(expr, 1));
            let body = '';
            let rowSep = '';
            for (const row of rows) {
                body += rowSep;
                const arg1 = getArg(row, 1);
                if (arg1 !== null) {
                    body += serialize.serialize(arg1);
                    const arg2 = getArg(row, 2);
                    if (arg2 !== null)
                        body += '&' + serialize.serialize(arg2);
                }
                rowSep = '\\\\';
            }
            return '\\begin{cases}' + body + '\\end{cases}';
        },
    },
];

function isZero(ce, expr) {
    const val = getNumberValue(expr);
    if (val !== null)
        return val === 0;
    if (ce.is(['Equal', expr, 0]))
        return true;
    // @todo matchAssumptions() equal not zero.
    if (ce.is(['NotEqual', expr, 0]) === true)
        return false;
    if (ce.is(['Greater', expr, 0]) === true)
        return false;
    if (ce.is(['Less', expr, 0]) === true)
        return false;
    // @todo
    // const match = engine.matchAssumptions(['Greater', expr, '_val']);
    // if (match.some((x) => x._val > 0)) return true;
    // If this is not a number, and there are no assumptions
    // about it, we can't tell if it's zero or not.
    if (val === null)
        return undefined;
    // It was a number, but not 0
    return false;
}
function isNotZero(engine, expr) {
    const result = isZero(engine, expr);
    return result === undefined ? undefined : !result;
}
function isInfinity(ce, expr) {
    if (expr === null)
        return undefined;
    const val = getNumberValue(expr);
    if (val !== null && !Number.isFinite(val))
        return true;
    if (val !== null && isNaN(val))
        return undefined;
    const symbol = getSymbolName(expr);
    if (symbol === COMPLEX_INFINITY)
        return true;
    if (symbol === MISSING || symbol === NOTHING)
        return false;
    if (ce.is(expr, 'ComplexNumber'))
        return false;
    const name = getFunctionName(expr);
    if (name === 'Negate') {
        if (isInfinity(ce, getArg(expr, 1)))
            return true;
    }
    else if (name === 'Multiply') {
        const args = getTail(expr);
        if (args.some((x) => isInfinity(ce, x) === true)) {
            if (args.every((x) => isNotZero(ce, x) === true)) {
                return true;
            }
        }
    }
    return val === null ? undefined : false;
}
function isPositive(ce, expr) {
    if (expr === null)
        return undefined;
    const val = getNumberValue(expr);
    if (val !== null)
        return val > 0;
    const symbol = getSymbolName(expr);
    if (symbol &&
        [
            'Quarter',
            'Third',
            'Half',
            'TwoThird',
            'ThreeQuarter',
            'MinusDoublePi',
            'MinusPi',
            'QuarterPi',
            'ThirdPi',
            'HalfPi',
            'TwoThirdPi',
            'ThreeQuarterPi',
            'Pi',
            'DoublePi',
            'MachineEpsilon',
            'CatalanConstant',
            'GoldenRatio',
            'EulerGamma',
            'ExponentialE',
        ].includes(symbol)) {
        return true;
    }
    if (ce.is(['Greater', expr, 0]))
        return true;
    if (ce.is(['LessEqual', expr, 0]))
        return false;
    if (ce.is(['Less', expr, 0]))
        return false;
    const name = getFunctionName(expr);
    if (name) {
        if (name === 'Cosh' || name === 'Exp') {
            if (isReal(ce, getArg(expr, 1)))
                return true;
        }
        if (name === 'Sqrt') {
            if (isPositive(ce, getArg(expr, 1)))
                return true;
        }
        if (name === MULTIPLY || name === ADD) {
            return getTail(expr).every((x) => isPositive(ce, x) === true);
        }
        if (name === DIVIDE) {
            if (isPositive(ce, getArg(expr, 1)) && isPositive(ce, getArg(expr, 2))) {
                return true;
            }
        }
        if (name === POWER) {
            if (isPositive(ce, getArg(expr, 1)))
                return true;
        }
    }
    return undefined;
}
/** Is `expr` < 0? */
function isNegative(ce, expr) {
    const result = isPositive(ce, expr);
    if (result === true)
        return false;
    if (result === undefined)
        return undefined;
    if (isZero(ce, expr) === false)
        return true;
    return false;
}
function isReal(_ce, expr) {
    // @todo
    if (expr === null)
        return false;
    const val = getNumberValue(expr);
    if (val === null)
        return false;
    return true;
}

function gamma(c) {
    // @todo
    // Consider: https://github.com/josdejong/mathjs/blob/develop/src/function/probability/gamma.js#L37-L76
    return c;
}

({
    //
    // Constants
    //
    MachineEpsilon: {
        /*
                The difference between 1 and the next larger floating point number
                
                2^{−52}
                
                See https://en.wikipedia.org/wiki/Machine_epsilon
            */
        domain: 'RealNumber',
        constant: true,
        value: { num: Number.EPSILON.toString() },
    },
    ImaginaryUnit: {
        domain: 'ImaginaryNumber',
        constant: true,
        wikidata: 'Q193796',
    },
    ExponentialE: {
        domain: 'TranscendentalNumber',
        wikidata: 'Q82435',
        constant: true,
        value: (engine) => {
            if (engine.numericFormat === 'decimal')
                return decimal.exports.Decimal.exp(1);
            if (engine.numericFormat === 'complex')
                return complex.exports.Complex.E;
            return 2.7182818284590452354;
        },
    },
    GoldenRatio: {
        domain: 'IrrationalNumber',
        wikidata: 'Q41690',
        constant: true,
        hold: false,
        value: ['Divide', ['Add', 1, ['Sqrt', 5]], 2],
    },
    CatalanConstant: {
        domain: 'RealNumber',
        wikidata: 'Q855282',
        constant: true,
        value: { num: '0.91596559417721901505' },
    },
    EulerGamma: {
        domain: 'RealNumber',
        wikidata: 'Q273023',
        constant: true,
        value: { num: '0.577215664901532860606' },
    },
    Quarter: {
        domain: 'RationalNumber',
        wikidata: 'Q2310416',
        constant: true,
        hold: false,
        value: [DIVIDE, 3, 4],
    },
    Third: {
        domain: 'RationalNumber',
        wikidata: 'Q20021125',
        constant: true,
        hold: false,
        value: [DIVIDE, 1, 3],
    },
    Half: {
        domain: 'RationalNumber',
        wikidata: 'Q2114394',
        constant: true,
        hold: false,
        value: [DIVIDE, 1, 2],
    },
    TwoThird: {
        domain: 'RationalNumber',
        constant: true,
        hold: false,
        value: [DIVIDE, 2, 3],
    },
    ThreeQuarter: {
        domain: 'RationalNumber',
        constant: true,
        hold: false,
        value: [DIVIDE, 3, 4],
    },
    //
    // Functions
    //
    Abs: {
        domain: 'Function',
        wikidata: 'Q3317982',
        threadable: true,
        idempotent: true,
        numeric: true,
        range: ['Interval', 0, Infinity],
        evalNumber: (_ce, val) => Math.abs(val),
        evalComplex: (_ce, n) => complex.exports.Complex.abs(n),
        evalDecimal: (_ce, n) => decimal.exports.Decimal.abs(n),
    },
    Add: {
        domain: 'Function',
        wikidata: 'Q32043',
        associative: true,
        commutative: true,
        threadable: true,
        idempotent: true,
        range: 'Number',
        numeric: true,
        simplify: simplifyAdd,
        evalNumber: (_ce, ...args) => {
            if (args.length === 0)
                return 0;
            let c = 0;
            for (const arg of args)
                c += arg;
            return c;
        },
        evalComplex: (_ce, ...args) => {
            if (args.length === 0)
                return complex.exports.Complex.ZERO;
            let c = complex.exports.Complex.ZERO;
            for (const arg of args)
                c = c.add(arg);
            return c;
        },
        evalDecimal: (_ce, ...args) => {
            if (args.length === 0)
                return DECIMAL_ZERO;
            let c = DECIMAL_ZERO;
            for (const arg of args)
                c = c.add(arg);
            return c;
        },
        evaluate: (ce, ...args) => {
            // Some arguments could not be evaluated to numbers or there's a mix
            // of Decimal and Complex:
            // still try to add the ones that are numeric, keep the others as is.
            if (args.length === 0)
                return 0;
            let result = ['Add'];
            const decimals = args.filter((x) => x instanceof decimal.exports.Decimal);
            if (decimals.length > 0) {
                if (decimals.length === 1) {
                    result.push(decimals[0]);
                }
                else {
                    result.push(ce.N(['Add', ...decimals]));
                }
            }
            const complexes = args.filter((x) => x instanceof complex.exports.Complex);
            if (complexes.length > 0) {
                if (complexes.length === 1) {
                    result.push(complexes[0]);
                }
                else {
                    result.push(ce.N(['Add', ...complexes]));
                }
            }
            const numbers = args.filter((x) => typeof x === 'number');
            if (numbers.length > 0) {
                if (numbers.length === 1) {
                    result.push(numbers[0]);
                }
                else {
                    result.push(ce.N(['Add', ...numbers]));
                }
            }
            const others = args.filter((x) => typeof x !== 'number' &&
                !(x instanceof decimal.exports.Decimal) &&
                !(x instanceof complex.exports.Complex));
            result = [...result, ...others];
            if (result.length === 0)
                return 0;
            if (result.length === 1)
                return result[1];
            return result;
        },
    },
    Chop: {
        domain: 'Function',
        associative: true,
        threadable: true,
        idempotent: true,
        numeric: true,
        range: 'Number',
        evalNumber: (ce, val) => ce.chop(val),
        evalComplex: (ce, n) => ce.chop(n),
        evalDecimal: (ce, n) => ce.chop(n),
    },
    Ceil: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        /** rounds a number up to the next largest integer */
        evalNumber: (_ce, val) => Math.ceil(val),
        evalComplex: (_ce, n) => complex.exports.Complex.ceil(n),
        evalDecimal: (_ce, n) => decimal.exports.Decimal.ceil(n),
    },
    Divide: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, lhs, rhs) => lhs / rhs,
        evalComplex: (_ce, lhs, rhs) => typeof lhs === 'number' ? new complex.exports.Complex(lhs).div(rhs) : lhs.div(rhs),
        evalDecimal: (_ce, lhs, rhs) => decimal.exports.Decimal.div(lhs, rhs),
    },
    Exp: {
        domain: ['ContinuousFunction', 'MonotonicFunction'],
        wikidata: 'Q168698',
        threadable: true,
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, val) => Math.exp(val),
        evalComplex: (_ce, val) => typeof val === 'number' ? new complex.exports.Complex(val).exp() : val.exp(),
        evalDecimal: (_ce, val) => decimal.exports.Decimal.exp(val),
    },
    Erf: {
        // Error function
        domain: ['ContinuousFunction', 'MonotonicFunction'],
        range: 'Number',
        numeric: true,
    },
    Erfc: {
        // Complementary Error Function
        domain: ['ContinuousFunction', 'MonotonicFunction'],
        range: 'Number',
        numeric: true,
    },
    Factorial: {
        wikidata: 'Q120976',
        domain: 'MonotonicFunction',
        range: 'Integer',
        numeric: true,
        evalNumber: (_ce, n) => factorial(n),
        evalComplex: (_ce, c) => typeof c === 'number'
            ? gamma(new complex.exports.Complex(c + 1))
            : gamma(c.add(1)),
        evalDecimal: (_ce, d) => factorial$1(d),
    },
    Floor: {
        domain: 'Function',
        wikidata: 'Q56860783',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, x) => Math.floor(x),
        evalDecimal: (_ce, x) => decimal.exports.Decimal.floor(x),
    },
    Gamma: {
        domain: 'Function',
        wikidata: 'Q190573',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, n) => gamma$1(n),
        // evalComplex: (_ce, c: Complex): Complex => gammaComplex(c),
        evalDecimal: (_ce, d) => gamma$2(d),
    },
    LogGamma: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, n) => lngamma(n),
        // evalComplex: (_ce, c: Complex): Complex => lngammaComplex(c),
        evalDecimal: (_ce, d) => lngamma$1(d),
    },
    Ln: {
        domain: 'Function',
        wikidata: 'Q11197',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, x) => Math.log(x),
        evalComplex: (_ce, c) => typeof c === 'number' ? new complex.exports.Complex(c).log() : c.log(),
        evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x),
    },
    Log: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, base, x) => Math.log(x) / Math.log(base),
        evalComplex: (_ce, base, x) => {
            const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
            const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
            return cX.log().div(cBase.log());
        },
        evalDecimal: (_ce, base, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(base)),
    },
    Lb: {
        domain: 'Function',
        wikidata: 'Q581168',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, x) => Math.log2(x),
        evalComplex: (_ce, base, x) => {
            const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
            return cX.log().div(complex.exports.Complex.log(2));
        },
        evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(2)),
    },
    Lg: {
        domain: 'Function',
        wikidata: 'Q966582',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, x) => Math.log10(x),
        evalComplex: (_ce, base, x) => {
            const cX = typeof x === 'number' ? new complex.exports.Complex(x) : x;
            return cX.log().div(complex.exports.Complex.log(10));
        },
        evalDecimal: (_ce, x) => decimal.exports.Decimal.log(x).div(decimal.exports.Decimal.log(10)),
    },
    // LogOnePlus: { domain: 'Function' },
    Multiply: {
        domain: 'Function',
        wikidata: 'Q40276',
        associative: true,
        commutative: true,
        idempotent: true,
        range: 'Number',
        simplify: simplifyMultiply,
        numeric: true,
        evalNumber: evalNumberMultiply,
        evalComplex: (_ce, ...args) => {
            if (args.length === 0)
                return complex.exports.Complex.ONE;
            let c = complex.exports.Complex.ONE;
            for (const arg of args)
                c = c.mul(arg);
            return c;
        },
        evalDecimal: (_ce, ...args) => {
            if (args.length === 0)
                return DECIMAL_ONE;
            let c = DECIMAL_ONE;
            for (const arg of args)
                c = c.mul(arg);
            return c;
        },
        evaluate: (ce, ...args) => {
            // Some arguments could not be evaluated to numbers or there's a mix
            // of Decimal and Complex:
            // still try to add the ones that are numeric, keep the others as is.
            if (args.length === 0)
                return 0;
            let result = ['Multiply'];
            const decimals = args.filter((x) => x instanceof decimal.exports.Decimal);
            if (decimals.length > 0) {
                if (decimals.length === 1) {
                    result.push(decimals[0]);
                }
                else {
                    result.push(ce.N(['Multiply', ...decimals]));
                }
            }
            const complexes = args.filter((x) => x instanceof complex.exports.Complex);
            if (complexes.length > 0) {
                if (complexes.length === 1) {
                    result.push(complexes[0]);
                }
                else {
                    result.push(ce.N(['Multiply', ...complexes]));
                }
            }
            const numbers = args.filter((x) => typeof x === 'number');
            if (numbers.length > 0) {
                if (numbers.length === 1) {
                    result.push(numbers[0]);
                }
                else {
                    result.push(ce.N(['Multiply', ...numbers]));
                }
            }
            const others = args.filter((x) => typeof x !== 'number' &&
                !(x instanceof decimal.exports.Decimal) &&
                !(x instanceof complex.exports.Complex));
            result = [...result, ...others];
            if (result.length === 0)
                return 1;
            if (result.length === 1)
                return result[1];
            return result;
        },
    },
    Negate: {
        domain: 'Function',
        wikidata: 'Q715358',
        range: 'Number',
        simplify: (_ce, x) => { var _a; return (_a = applyNegate(x)) !== null && _a !== void 0 ? _a : ['Negate', x]; },
        numeric: true,
        evalNumber: (_ce, val) => -val,
        evalComplex: (_ce, x) => typeof x === 'number' ? new complex.exports.Complex(-x) : x.neg(),
        evalDecimal: (_ce, x) => typeof x === 'number' ? new decimal.exports.Decimal(-x) : x.neg(),
    },
    Power: {
        domain: 'Function',
        wikidata: 'Q33456',
        commutative: false,
        numeric: true,
        range: 'Number',
        simplify: (ce, ...args) => applyPower(ce, ['Power', ...args]),
        evalNumber: (_ce, base, power) => Math.pow(base, power),
        evalComplex: (_ce, base, power) => {
            const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
            const cPower = typeof power === 'number' ? new complex.exports.Complex(power) : power;
            return complex.exports.Complex.pow(cBase, cPower);
        },
        evalDecimal: (_ce, base, power) => decimal.exports.Decimal.pow(base, power),
    },
    Round: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, val) => Math.round(val),
        evalComplex: (_ce, val) => typeof val === 'number' ? new complex.exports.Complex(val).round() : val.round(),
        evalDecimal: (_ce, val) => decimal.exports.Decimal.round(val),
    },
    Sign: {
        domain: 'Function',
        range: ['Range', -1, 1],
        numeric: true,
        simplify: (ce, x) => isZero(ce, x) ? 0 : isNegative(ce, x) ? -1 : 1,
        evalNumber: (_ce, val) => (val === 0 ? 0 : val < 0 ? -1 : 1),
        evalComplex: (_ce, z) => {
            const cZ = typeof z === 'number' ? new complex.exports.Complex(z) : z;
            return cZ.div(cZ.abs());
        },
        evalDecimal: (_ce, val) => {
            if (typeof val === 'number') {
                return val === 0
                    ? DECIMAL_ZERO
                    : val < 0
                        ? DECIMAL_MINUS_ONE
                        : DECIMAL_ONE;
            }
            return val.isZero()
                ? DECIMAL_ZERO
                : val.isNeg()
                    ? DECIMAL_MINUS_ONE
                    : DECIMAL_ONE;
        },
    },
    SignGamma: {
        domain: 'Function',
        range: 'Number',
        numeric: true,
        /** The sign of the gamma function: -1 or +1 */
    },
    Sqrt: {
        domain: 'Function',
        wikidata: 'Q134237',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, val) => Math.sqrt(val),
        evalComplex: (_ce, z) => typeof z === 'number' ? new complex.exports.Complex(z).sqrt() : z.sqrt(),
        evalDecimal: (_ce, val) => decimal.exports.Decimal.sqrt(val),
    },
    Square: {
        domain: 'Function',
        wikidata: 'Q3075175',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, val) => val * val,
        evalComplex: (_ce, z) => typeof z === 'number' ? new complex.exports.Complex(z).multiply(z) : z.mul(z),
        evalDecimal: (_ce, val) => decimal.exports.Decimal.mul(val, val),
    },
    Root: {
        domain: 'Function',
        commutative: false,
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, base, power) => Math.pow(base, 1 / power),
        evalComplex: (_ce, base, power) => {
            const cBase = typeof base === 'number' ? new complex.exports.Complex(base) : base;
            const cPower = typeof power === 'number'
                ? new complex.exports.Complex(1 / power)
                : new complex.exports.Complex(complex.exports.Complex.ONE.div(power));
            return complex.exports.Complex.pow(cBase, cPower);
        },
        evalDecimal: (_ce, base, power) => decimal.exports.Decimal.pow(base, DECIMAL_ONE.div(power)),
    },
    Subtract: {
        domain: 'Function',
        wikidata: 'Q32043',
        range: 'Number',
        numeric: true,
        evalNumber: (_ce, lhs, rhs) => lhs - rhs,
        evalComplex: (_ce, lhs, rhs) => typeof lhs === 'number' ? new complex.exports.Complex(lhs).sub(rhs) : lhs.sub(rhs),
        evalDecimal: (_ce, lhs, rhs) => decimal.exports.Decimal.sub(lhs, rhs),
    },
    // @todo
    // mod (modulo). See https://numerics.diploid.ca/floating-point-part-4.html,
    // regarding 'remainder' and 'truncatingRemainder'
    // lcm
    // gcd
    // root
    // sum
    // product
});
function simplifyAdd(ce, ...args) {
    var _a, _b;
    if (args.length === 0)
        return 0;
    if (args.length === 1)
        return args[0];
    let numerTotal = 0;
    let denomTotal = 1;
    let dTotal = DECIMAL_ZERO;
    let cTotal = complex.exports.Complex.ZERO;
    let posInfinity = false;
    let negInfinity = false;
    const others = [];
    for (const arg of args) {
        const symbol = getSymbolName(arg);
        if (symbol === MISSING || symbol === NOTHING)
            return NaN;
        if (symbol === COMPLEX_INFINITY)
            return COMPLEX_INFINITY;
        if (isInfinity(ce, arg)) {
            if (isPositive(ce, arg)) {
                posInfinity = true;
            }
            else {
                negInfinity = true;
            }
        }
        const [n, d] = getRationalValue(arg);
        if (n !== null && d !== null) {
            if (isNaN(n) || isNaN(d))
                return NaN;
            numerTotal = numerTotal * d + n * denomTotal;
            denomTotal = denomTotal * d;
        }
        else {
            const c = getComplexValue(arg);
            if (c !== null) {
                if (Number.isInteger(c.re) && Number.isInteger(c.im)) {
                    cTotal = cTotal.add(c);
                }
                else {
                    others.push(arg);
                }
            }
            else {
                const d = getDecimalValue(arg);
                if (d !== null && d.isInteger()) {
                    dTotal = dTotal.add(d);
                }
                else {
                    const val = getNumberValue(arg);
                    if (val !== null && Number.isInteger(val)) {
                        numerTotal += val;
                    }
                    else if (isNotZero(ce, arg) !== false) {
                        others.push(arg);
                    }
                }
            }
        }
    }
    if (posInfinity && negInfinity)
        return NaN;
    if (posInfinity)
        return Infinity;
    if (negInfinity)
        return -Infinity;
    // Group similar terms
    // @todo
    // const terms: { [term: string]: number } = {};
    // for (const [term, coeff] of forEachTermCoeff(others)) {
    // }
    if (!dTotal.isZero())
        others.push(dTotal);
    if (!cTotal.isZero())
        others.push(cTotal);
    if (others.length === 0) {
        if (numerTotal === 0)
            return 0;
        if (denomTotal === 1)
            return numerTotal;
        return ['Divide', numerTotal, denomTotal];
    }
    if (numerTotal !== 0) {
        const g = gcd(numerTotal, denomTotal);
        numerTotal = numerTotal / g;
        denomTotal = denomTotal / g;
        if (denomTotal === 1) {
            others.push(numerTotal);
        }
        else {
            others.push(['Divide', numerTotal, denomTotal]);
        }
    }
    if (others.length === 1)
        return others[0];
    if (others.length === 2 && getFunctionName(others[1]) === NEGATE) {
        // a + (-b) -> a - b
        return ['Subtract', others[0], (_a = getArg(others[1], 1)) !== null && _a !== void 0 ? _a : MISSING];
    }
    else if (others.length === 2 && getFunctionName(others[0]) === NEGATE) {
        // (-a) + b -> b - a
        return ['Subtract', others[1], (_b = getArg(others[0], 1)) !== null && _b !== void 0 ? _b : MISSING];
    }
    return ['Add', ...others];
}
function simplifyMultiply(ce, ...args) {
    if (args.length === 0)
        return 1;
    if (args.length === 1)
        return args[0];
    const others = [];
    let numer = 1;
    let denom = 1;
    let c = complex.exports.Complex.ONE;
    for (const arg of args) {
        const val = getNumberValue(arg);
        if (val === 0)
            return 0;
        if (val !== null && (!Number.isFinite(val) || Number.isInteger(val))) {
            numer *= val;
        }
        else {
            const [n, d] = [null, null]; // getRationalValue(arg);
            if (n !== null && d !== null) {
                numer *= n;
                denom *= d;
            }
            else {
                const cVal = getComplexValue(arg);
                if (cVal !== null) {
                    if (Number.isInteger(cVal.re) && Number.isInteger(cVal.im)) {
                        c = c.mul(cVal);
                    }
                    else {
                        others.push(arg);
                    }
                }
                else {
                    // @todo: consider distributing if the head of arg is Add or Negate or Subtract or Divide
                    if (isZero(ce, arg))
                        return 0;
                    others.push(arg);
                }
            }
        }
    }
    if (c.im !== 0) {
        c = c.mul(numer);
        numer = 1;
    }
    else {
        numer = numer * c.re;
        c = complex.exports.Complex.ONE;
    }
    // Divide numer by denom to get the proper signed infinite or NaN
    if (numer === 0 || !isFinite(numer))
        return numer / denom;
    if (!c.equals(complex.exports.Complex.ONE)) {
        others.push(['Complex', c.re, c.im]);
    }
    if (others.length === 0) {
        if (denom === 1)
            return numer;
        return ['Divide', numer, denom];
    }
    if (denom !== 1) {
        others.unshift(['Divide', numer, denom]);
        numer = 1;
        denom = 1;
    }
    if (others.length === 1 && numer === 1)
        return others[0];
    if (others.length === 1 && numer === -1)
        return ['Negate', others[0]];
    if (numer === 1)
        return ['Multiply', ...others];
    if (numer === -1)
        return ['Negate', ['Multiply', ...others]];
    return ['Multiply', numer, ...others];
}
/** Apply some simplifications for `Negate`.
 *  Used by `canonical-negate` and `simplify`
 */
function applyNegate(expr) {
    var _a, _b, _c, _d;
    expr = ungroup(expr);
    if (typeof expr === 'number') {
        // Applying negation is safe on floating point numbers
        return -expr;
    }
    if (expr && isNumberObject(expr)) {
        if (expr.num[0] === '-') {
            return { num: expr.num.slice(1) };
        }
        else if (expr.num[0] === '+') {
            return { num: '-' + expr.num.slice(1) };
        }
        else {
            return { num: '-' + expr.num };
        }
    }
    if (expr instanceof decimal.exports.Decimal) {
        const d = expr;
        return d.mul(-1);
    }
    if (expr instanceof complex.exports.Complex) {
        const c = expr;
        return c.mul(-1);
    }
    const name = getFunctionName(expr);
    const argCount = getArgCount(expr);
    if (name === NEGATE && argCount === 1) {
        // [NEGATE, [NEGATE, x]] -> x
        return (_a = getArg(expr, 1)) !== null && _a !== void 0 ? _a : MISSING;
    }
    else if (name === MULTIPLY) {
        const arg = applyNegate((_b = getArg(expr, 1)) !== null && _b !== void 0 ? _b : MISSING);
        return [MULTIPLY, arg, ...getTail(expr).slice(1)];
    }
    else if (name === ADD) {
        return [ADD, ...mapArgs(expr, applyNegate)];
    }
    else if (name === SUBTRACT) {
        return [SUBTRACT, (_c = getArg(expr, 2)) !== null && _c !== void 0 ? _c : MISSING, (_d = getArg(expr, 1)) !== null && _d !== void 0 ? _d : MISSING];
    }
    else if (name === PARENTHESES && argCount === 1) {
        return applyNegate(getArg(getArg(expr, 1), 1));
    }
    return [NEGATE, expr !== null && expr !== void 0 ? expr : MISSING];
}
// The function is `numeric` so it will be passed numbers
function evalNumberMultiply(_ce, ...args) {
    if (args.length === 0)
        return 1;
    if (args.length === 1)
        return args[0];
    let c = 1;
    for (const arg of args)
        c *= arg;
    return c;
}
function ungroup(expr) {
    if (expr === null)
        return NOTHING;
    if (isAtomic(expr))
        return expr;
    if (getFunctionHead(expr) === PARENTHESES && getArgCount(expr) === 1) {
        return ungroup(getArg(expr, 1));
    }
    return applyRecursively(expr, ungroup);
}
// Used by `simplify()` and `canonical()`
// @todo: see https://docs.sympy.org/1.6/modules/core.html#pow
function applyPower(engine, expr) {
    var _a, _b;
    // @todo: using engine predicates (isEqual(x, 1)...)
    expr = ungroup(expr);
    console.assert(getFunctionName(expr) === 'Power');
    if (getArgCount(expr) !== 2)
        return expr;
    const arg1 = getArg(expr, 1);
    const val1 = (_a = getNumberValue(arg1)) !== null && _a !== void 0 ? _a : NaN;
    const arg2 = getArg(expr, 2);
    if (getSymbolName(arg2) === 'ComplexInfinity')
        return NaN;
    const val2 = (_b = getNumberValue(arg2)) !== null && _b !== void 0 ? _b : NaN;
    if (isZero(engine, arg2))
        return 1;
    if (val2 === 1)
        return arg1;
    if (val2 === 2)
        return ['Square', arg1];
    if (val2 === -1) {
        if (val1 === -1 || val1 === 1)
            return -1;
        if (!Number.isFinite(val1))
            return 0;
        return ['Divide', 1, arg1];
    }
    if (!Number.isFinite(val2)) {
        if (val1 === 0 && val2 < 0)
            return 'ComplexInfinity';
        if (val1 === 1 || val1 === -1)
            return NaN;
        if (val1 === Infinity) {
            if (val2 > 0)
                return Infinity;
            if (val2 < 0)
                return 0;
        }
        if (val1 === -Infinity && !Number.isFinite(val2))
            return NaN;
    }
    return expr;
}
// function* forEachTermCoeff(
//   terms: Expression[]
// ): Generator<[term: Expression, coef: number]> {
//   return;
// }

/**
 * If expression is a product, collect all the terms with a
 * negative exponents in the denominator, and all the terms
 * with a positive exponent (or no exponent) in the numerator.
 */
function numeratorDenominator(expr) {
    var _a, _b, _c, _d, _e, _f;
    if (getFunctionName(expr) !== MULTIPLY)
        return [[], []];
    const numerator = [];
    const denominator = [];
    const args = getTail(expr);
    for (const arg of args) {
        if (getFunctionName(arg) === POWER) {
            if (getFunctionName(getArg(arg, 2)) === NEGATE) {
                const a = (_a = getArg(arg, 1)) !== null && _a !== void 0 ? _a : NOTHING;
                const b = (_b = getArg(getArg(arg, 2), 1)) !== null && _b !== void 0 ? _b : NOTHING;
                denominator.push([POWER, a, b]);
            }
            else {
                const exponentVal = (_c = getNumberValue(getArg(arg, 2))) !== null && _c !== void 0 ? _c : NaN;
                if (exponentVal === -1) {
                    denominator.push((_d = getArg(arg, 1)) !== null && _d !== void 0 ? _d : NOTHING);
                }
                else if (exponentVal < 0) {
                    denominator.push([
                        POWER,
                        (_e = getArg(arg, 1)) !== null && _e !== void 0 ? _e : NOTHING,
                        (_f = applyNegate(getArg(arg, 2))) !== null && _f !== void 0 ? _f : NOTHING,
                    ]);
                }
                else {
                    numerator.push(arg);
                }
            }
        }
        else {
            numerator.push(arg);
        }
    }
    return [numerator, denominator];
}
function serializeRoot(serializer, style, base, degree) {
    if (base === null)
        return '\\sqrt{}';
    degree = degree !== null && degree !== void 0 ? degree : 2;
    if (style === 'solidus') {
        return (serializer.wrapShort(base) + '^{1\\/' + serializer.serialize(degree) + '}');
    }
    else if (style === 'quotient') {
        return (serializer.wrapShort(base) +
            '^{\\frac{1}{' +
            serializer.serialize(degree) +
            '}}');
    }
    const degreeValue = getNumberValue(degree);
    if (degreeValue === 2) {
        return '\\sqrt{' + serializer.serialize(base) + '}';
    }
    // It's the n-th root
    return ('\\sqrt[' +
        serializer.serialize(degree) +
        ']{' +
        serializer.serialize(base) +
        '}');
}
function parseRoot(lhs, scanner, _minPrec) {
    if (!scanner.match('\\sqrt'))
        return [lhs, null];
    const degree = scanner.matchOptionalLatexArgument();
    const base = scanner.matchRequiredLatexArgument();
    if (base === null) {
        if (degree !== null)
            return [lhs, [ROOT, NOTHING, degree]];
        return [lhs, [SQRT]];
    }
    if (degree !== null)
        return [lhs, [ROOT, base, degree]];
    return [lhs, [SQRT, base]];
}
function parseMinusSign(lhs, scanner, minPrec) {
    if (276 < minPrec)
        return [lhs, null];
    const index = scanner.index;
    if (!scanner.match('-'))
        return [lhs, null];
    const rhs = scanner.matchExpression(lhs === null ? 400 : 277);
    if (rhs === null) {
        scanner.index = index;
        return [lhs, null];
    }
    if (lhs === null)
        return [null, [NEGATE, rhs]];
    return [null, [SUBTRACT, lhs, rhs]];
}
function parsePlusSign(lhs, scanner, minPrec) {
    if (275 < minPrec)
        return [lhs, null];
    const index = scanner.index;
    if (!scanner.match('+'))
        return [lhs, null];
    const rhs = scanner.matchExpression(lhs === null ? 400 : 275);
    if (rhs === null) {
        scanner.index = index;
        return [lhs, null];
    }
    if (lhs === null)
        return [null, rhs];
    return scanner.applyOperator(ADD, lhs, rhs);
}
function serializeAdd(serializer, expr) {
    var _a, _b;
    // "add" doesn't increase the "level" for styling purposes
    // so, preventatively decrease it now.
    serializer.level -= 1;
    const name = getFunctionName(expr);
    let result = '';
    let arg = getArg(expr, 1);
    let argWasNumber = !Number.isNaN((_a = getNumberValue(arg)) !== null && _a !== void 0 ? _a : NaN);
    if (name === NEGATE) {
        result = '-' + serializer.wrap(arg, 276);
    }
    else if (name === ADD) {
        result = serializer.serialize(arg);
        const last = getArgCount(expr) + 1;
        for (let i = 2; i < last; i++) {
            arg = getArg(expr, i);
            const val = (_b = getNumberValue(arg)) !== null && _b !== void 0 ? _b : NaN;
            const argIsNumber = !Number.isNaN(val);
            let done = false;
            if (arg !== null) {
                if (argWasNumber) {
                    // Check if we can convert to an invisible plus, e.g. "1\frac{1}{2}"
                    const [numer, denom] = getRationalValue(arg);
                    if (numer !== null && denom !== null) {
                        if (isFinite(numer) && isFinite(denom) && denom !== 1) {
                            // Don't include the '+' sign, it's a rational, use 'invisible plus'
                            result +=
                                serializer.options.invisiblePlus + serializer.serialize(arg);
                            done = true;
                        }
                    }
                }
            }
            if (!done) {
                if (val < 0) {
                    // Don't include the minus sign, it will be serialized for the arg
                    result += serializer.serialize(arg);
                }
                else if (getFunctionName(arg) === NEGATE) {
                    result += serializer.wrap(arg, 275);
                }
                else {
                    const term = serializer.wrap(arg, 275);
                    if (term[0] === '-' || term[0] === '+') {
                        result += term;
                    }
                    else {
                        result = result + '+' + term;
                    }
                }
            }
            argWasNumber = argIsNumber;
        }
    }
    else if (name === SUBTRACT) {
        const arg2 = getArg(expr, 2);
        if (arg2 !== null) {
            result = serializer.wrap(arg, 275) + '-' + serializer.wrap(arg2, 275);
        }
        else {
            result = serializer.wrap(arg, 275);
        }
    }
    // Restore the level
    serializer.level += 1;
    return result;
}
function serializeMultiply(serializer, expr) {
    var _a;
    if (expr === null)
        return '';
    // "Multiply" doesn't increase the "level" for styling purposes
    // so, preventively decrease it now.
    serializer.level -= 1;
    let result = '';
    //
    // Is it a fraction?
    // (i.e. does it have a denominator, i.e. some factors with a negative power)
    //
    const [numer, denom] = numeratorDenominator(expr);
    if (denom.length > 0) {
        if (denom.length === 1 && denom[0] === 1) {
            if (numer.length === 0) {
                result = '1';
            }
            else if (numer.length === 1) {
                result = serializer.serialize(numer[0]);
            }
            else {
                result = serializeMultiply(serializer, [MULTIPLY, ...numer]);
            }
        }
        else {
            result = serializer.serialize([
                DIVIDE,
                numer.length === 1 ? numer[0] : [MULTIPLY, ...numer],
                denom.length === 1 ? denom[0] : [MULTIPLY, ...denom],
            ]);
        }
    }
    if (result) {
        // Restore the level
        serializer.level += 1;
        return result;
    }
    let isNegative = false;
    let arg = null;
    const count = getArgCount(expr) + 1;
    let prevWasNumber = false;
    for (let i = 1; i < count; i++) {
        arg = getArg(expr, i);
        if (arg !== null) {
            let term;
            //
            // 1. Should the terms be separated by an explicit MULTIPLY?
            //
            if (typeof arg === 'number' || isNumberObject(arg)) {
                term = serializer.serialize(arg);
                if (term === '-1' && !result) {
                    result = '-';
                }
                else {
                    if (term[0] === '-') {
                        term = term.slice(1);
                        isNegative = !isNegative;
                    }
                    result = result
                        ? joinLatex([result, serializer.options.multiply, term])
                        : term;
                }
                prevWasNumber = true;
            }
            else if (getFunctionName(arg) === POWER &&
                !isNaN((_a = getNumberValue(getArg(arg, 1))) !== null && _a !== void 0 ? _a : NaN)) {
                // It's a power and the base is a number...
                // add a multiply...
                result = result
                    ? joinLatex([
                        result,
                        serializer.options.multiply,
                        serializer.serialize(arg),
                    ])
                    : serializer.serialize(arg);
                prevWasNumber = true;
            }
            else {
                if (getFunctionName(arg) === NEGATE) {
                    arg = getArg(arg, 1);
                    isNegative = !isNegative;
                }
                // 2.1 Wrap the term if necessary
                // (if it's an operator of precedence less than 390)
                term = serializer.wrap(arg, 390);
                // 2.2. The terms can be separated by an invisible multiply.
                if (!result) {
                    // First term
                    result = term;
                }
                else {
                    if (prevWasNumber && getFunctionName(arg) === DIVIDE) {
                        // Can't use an invisible multiply if a number
                        // multiplied by a fraction
                        result = joinLatex([result, '\\times', term]);
                    }
                    // Not first term, use invisible multiply
                    else if (!serializer.options.invisibleMultiply) {
                        // Replace, joining the terms correctly
                        // i.e. inserting a space between '\pi' and 'x'
                        result = joinLatex([result, term]);
                    }
                    else {
                        result = joinLatex([
                            result,
                            serializer.options.invisibleMultiply,
                            term,
                        ]);
                    }
                }
                prevWasNumber = false;
            }
        }
    }
    // Restore the level
    serializer.level += 1;
    return isNegative ? '-' + result : result;
}
function parseFraction(lhs, scanner, _minPrec) {
    var _a, _b, _c, _d;
    if (!scanner.match('\\frac'))
        return [lhs, null];
    const numer = (_a = scanner.matchRequiredLatexArgument()) !== null && _a !== void 0 ? _a : MISSING;
    const denom = (_b = scanner.matchRequiredLatexArgument()) !== null && _b !== void 0 ? _b : MISSING;
    if (getFunctionName(numer) === 'PartialDerivative' &&
        (getFunctionName(denom) === 'PartialDerivative' ||
            (getFunctionName(denom) === MULTIPLY &&
                getFunctionName(getArg(denom, 1)) === 'PartialDerivative'))) {
        // It's a Leibniz notation partial derivative
        // `∂f(x)/∂x` or `∂^2f(x)/∂x∂y` or `∂/∂x f(x)`
        const degree = (_c = getArg(numer, 3)) !== null && _c !== void 0 ? _c : NOTHING;
        // Expect: getArg(numer, 2) === NOTHING -- no args
        let fn = getArg(numer, 1);
        if (fn === null || fn === NOTHING) {
            fn = (_d = scanner.matchExpression()) !== null && _d !== void 0 ? _d : NOTHING;
        }
        let vars = [];
        if (getFunctionName(denom) === MULTIPLY) {
            // ?/∂x∂y
            for (const arg of getTail(denom)) {
                if (getFunctionHead(arg) === 'PartialDerivative') {
                    const v = getArg(arg, 2);
                    if (v)
                        vars.push(v);
                }
            }
        }
        else {
            // ?/∂x
            const v = getArg(denom, 2);
            if (v)
                vars.push(v);
        }
        if (vars.length > 1) {
            vars = [LIST, ...vars];
        }
        return [
            lhs,
            ['PartialDerivative', fn, vars, degree === NOTHING ? 1 : degree],
        ];
    }
    return [lhs, [DIVIDE, numer, denom]];
}
function serializeFraction(serializer, expr) {
    console.assert(getFunctionName(expr) === DIVIDE);
    if (expr === null)
        return '';
    if (getArgCount(expr) === 1)
        return serializer.serialize(getArg(expr, 1));
    const style = getFractionStyle(expr, serializer.level);
    if (style === 'inline-solidus' || style === 'nice-solidus') {
        const numerStr = serializer.wrapShort(getArg(expr, 1));
        const denomStr = serializer.wrapShort(getArg(expr, 2));
        if (style === 'nice-solidus') {
            return `^{${numerStr}}\\!\\!/\\!_{${denomStr}}`;
        }
        return `${numerStr}\\/${denomStr}`;
    }
    else if (style === 'reciprocal') {
        return (serializer.wrap(getArg(expr, 1)) +
            serializer.wrap(getArg(expr, 2)) +
            '^{-1}');
    }
    else if (style === 'factor') {
        return ('\\frac{1}{' +
            serializer.serialize(getArg(expr, 2)) +
            '}' +
            serializer.wrap(getArg(expr, 1)));
    }
    // Quotient (default)
    return ('\\frac{' +
        serializer.serialize(getArg(expr, 1)) +
        '}{' +
        serializer.serialize(getArg(expr, 2)) +
        '}');
}
function serializePower(serializer, expr) {
    var _a;
    const arg1 = getArg(expr, 1);
    const arg2 = getArg(expr, 2);
    if (arg2 === null) {
        return serializer.serialize(arg1);
    }
    if (arg1 === null) {
        return '';
    }
    const name = getFunctionName(expr);
    if (name === SQRT || name === ROOT) {
        const style = getRootStyle(expr, serializer.level);
        return serializeRoot(serializer, style, getArg(expr, 1), getArg(expr, 2));
    }
    const val2 = (_a = getNumberValue(arg2)) !== null && _a !== void 0 ? _a : 1;
    if (val2 === -1) {
        return serializer.serialize([DIVIDE, '1', arg1]);
    }
    else if (val2 < 0) {
        return serializer.serialize([DIVIDE, '1', [POWER, arg1, -val2]]);
    }
    else if (getFunctionName(arg2) === DIVIDE) {
        if (getNumberValue(getArg(arg2, 1)) === 1) {
            // It's x^{1/n} -> it's a root
            const style = getRootStyle(expr, serializer.level);
            return serializeRoot(serializer, style, arg1, getArg(arg2, 2));
        }
    }
    else if (getFunctionName(arg2) === POWER) {
        if (getNumberValue(getArg(arg2, 2)) === -1) {
            // It's x^{n^-1} -> it's a root
            const style = getRootStyle(expr, serializer.level);
            return serializeRoot(serializer, style, arg1, getArg(arg2, 1));
        }
    }
    return serializer.wrapShort(arg1) + '^{' + serializer.serialize(arg2) + '}';
}
const DEFINITIONS_ARITHMETIC = [
    { name: 'ThreeQuarter', serialize: '\\frac{3}{4}' },
    { name: 'TwoThird', serialize: '\\frac{2}{3}' },
    { name: 'Half', serialize: '\\frac{1}{2}' },
    { name: 'Third', serialize: '\\frac{1}{3}' },
    { name: 'Quarter', serialize: '\\frac{1}{4}' },
    { name: 'CatalanConstant', serialize: 'G' },
    { name: 'GoldenRatio', serialize: '\\varphi' },
    { name: 'EulerGamma', serialize: '\\gamma' },
    { name: 'Degrees', serialize: '\\frac{\\pi}{180}' },
    { name: 'MinusDoublePi', serialize: '-2\\pi' },
    { name: 'MinusPi', serialize: '-\\pi' },
    { name: 'MinusHalfPi', serialize: '-\\frac{\\pi}{2}' },
    { name: 'QuarterPi', serialize: '\\frac{\\pi}{4}' },
    { name: 'ThirdPi', serialize: '\\frac{\\pi}{3}' },
    { name: 'HalfPi', serialize: '\\frac{\\pi}{2}' },
    { name: 'TwoThirdPi', serialize: '\\frac{2\\pi}{3}' },
    { name: 'ThreeQuarterPi', serialize: '\\frac{3\\pi}{4}' },
    { name: 'DoublePi', serialize: '2\\pi' },
    {
        name: 'Complex',
        precedence: 275,
        serialize: (serializer, expr) => {
            // Note: we should not have ['Complex'] functions in canonical expressions
            // but this is just in case...
            const re = getNumberValue(getArg(expr, 1));
            const im = getNumberValue(getArg(expr, 2));
            if (im === 0)
                return serializer.serialize(getArg(expr, 1));
            const imPart = im === 1
                ? '\\imaginaryI'
                : im === -1
                    ? '-\\imaginaryI'
                    : joinLatex([serializer.serialize(getArg(expr, 2)), '\\imaginaryI']);
            if (re === 0)
                return imPart;
            return joinLatex([serializer.serialize(getArg(expr, 1)), '+', imPart]);
        },
    },
    {
        name: 'Exp',
        serialize: (serializer, expr) => {
            var _a;
            return joinLatex([
                '\\exponentialE^{',
                serializer.serialize((_a = getArg(expr, 1)) !== null && _a !== void 0 ? _a : NOTHING),
                '}',
            ]);
        },
    },
    {
        name: 'Square',
        serialize: (serializer, expr) => serializer.wrapShort(getArg(expr, 1)) + '^2',
    },
    { trigger: { symbol: '\\infty' }, parse: { num: '+Infinity' } },
    {
        name: COMPLEX_INFINITY,
        trigger: { symbol: ['\\tilde', '\\infty'] },
        serialize: '\\tilde\\infty',
    },
    {
        name: COMPLEX_INFINITY,
        trigger: { symbol: ['\\tilde', '<{>', '\\infty', '<}>'] },
        serialize: '\\tilde\\infty',
    },
    { name: PI, trigger: { symbol: '\\pi' } },
    { name: PI, trigger: { symbol: 'π' }, serialize: '\\pi' },
    { name: EXPONENTIAL_E, trigger: { symbol: 'e' }, serialize: 'e' },
    { name: IMAGINARY_UNIT, trigger: { symbol: 'i' }, serialize: '\\imaginaryI' },
    { name: IMAGINARY_UNIT, trigger: { symbol: '\\imaginaryI' } },
    {
        name: ADD,
        trigger: { prefix: '+', infix: '+' },
        parse: parsePlusSign,
        serialize: serializeAdd,
        associativity: 'both',
        precedence: 275,
    },
    {
        name: NEGATE,
        trigger: { prefix: '-' },
        parse: parseMinusSign,
        associativity: 'left',
        precedence: 275,
    },
    {
        name: SUBTRACT,
        trigger: { infix: '-' },
        parse: parseMinusSign,
        associativity: 'both',
        precedence: 275,
    },
    {
        name: 'PlusMinus',
        trigger: { infix: '\\pm' },
        associativity: 'both',
        precedence: 270,
    },
    {
        name: 'MinusPlus',
        trigger: { infix: '\\mp' },
        associativity: 'both',
        precedence: 270,
    },
    {
        name: MULTIPLY,
        trigger: { infix: '\\times' },
        serialize: serializeMultiply,
        associativity: 'both',
        precedence: 390,
    },
    {
        name: MULTIPLY,
        trigger: { infix: '\\cdot' },
        serialize: serializeMultiply,
        associativity: 'both',
        precedence: 390,
    },
    {
        name: MULTIPLY,
        trigger: { infix: '*' },
        serialize: serializeMultiply,
        associativity: 'both',
        precedence: 390,
    },
    {
        name: DIVIDE,
        trigger: '\\frac',
        // For \frac specifically, not for \div, etc..
        // handles Leibnitz notation for partial derivatives
        parse: parseFraction,
        serialize: serializeFraction,
        requiredLatexArg: 2,
    },
    {
        name: DIVIDE,
        trigger: { infix: '\\/' },
        serialize: serializeFraction,
        associativity: 'non',
        precedence: 660, // ??? MathML has 265, but it's wrong.
        // It has to be at least higher than multiply
        // e.g. `1/2+3*x` -> `1/2 + 3*x` , not `1/(2+3*x)`
    },
    {
        name: DIVIDE,
        trigger: { infix: '/' },
        serialize: serializeFraction,
        associativity: 'non',
        precedence: 660,
    },
    {
        name: DIVIDE,
        trigger: { infix: '\\div' },
        serialize: serializeFraction,
        associativity: 'non',
        precedence: 660, // ??? according to MathML
    },
    {
        name: POWER,
        trigger: { infix: '^' },
        associativity: 'non',
        precedence: 720,
        serialize: serializePower,
    },
    {
        name: POWER,
        trigger: { infix: ['*', '*'] },
        associativity: 'non',
        precedence: 720,
        serialize: serializePower,
    },
    {
        name: SQRT,
        trigger: '\\sqrt',
        optionalLatexArg: 1,
        requiredLatexArg: 1,
        parse: parseRoot,
        serialize: serializePower,
    },
    {
        name: ROOT,
        trigger: '\\sqrt',
        optionalLatexArg: 1,
        requiredLatexArg: 1,
        parse: parseRoot,
    },
    {
        /** If the argument is a vector */
        /** @todo: domain check */
        name: 'Norm',
        trigger: { matchfix: '\\lVert' },
        closeFence: '\\rVert',
    },
    {
        /** If the argument is a vector */
        /** @todo: domain check */
        name: 'Norm',
        trigger: { matchfix: '\\|' },
        closeFence: '\\|',
    },
    {
        /** If the argument is a vector */
        /** @todo: domain check */
        name: 'Norm',
        trigger: { matchfix: ['|', '|'] },
        closeFence: ['|', '|'],
    },
    {
        /** Could be the determinant if the argument is a matrix */
        /** @todo: domain check */
        /** If a literal matrix, the `serialize` should be custom, the parens are
         * replaced with bars */
        name: 'Abs',
        trigger: { matchfix: '|' },
        closeFence: '|',
    },
    {
        name: 'Abs',
        trigger: { matchfix: '\\lvert' },
        closeFence: '\\rvert',
    },
    {
        name: 'Factorial',
        trigger: { postfix: '!' },
        precedence: 810,
    },
    {
        name: 'Factorial2',
        trigger: { postfix: ['!', '!'] },
        precedence: 810,
    },
    {
        name: 'Lcm',
        trigger: { symbol: ['\\operatorname', '<{>', 'l', 'c', 'm', '<}>'] },
    },
    {
        name: 'Gcd',
        trigger: { symbol: ['\\operatorname', '<{>', 'g', 'c', 'd', '<}>'] },
    },
    {
        name: 'Ceil',
        trigger: { symbol: ['\\operatorname', '<{>', 'c', 'e', 'i', 'l', '<}>'] },
    },
    {
        name: 'Floor',
        trigger: {
            symbol: ['\\operatorname', '<{>', 'f', 'l', 'o', 'o', 'r', '<}>'],
        },
    },
    {
        name: 'Round',
        trigger: {
            symbol: ['\\operatorname', '<{>', 'r', 'o', 'u', 'n', 'd', '<}>'],
        },
    },
    {
        name: 'Sign',
        trigger: {
            // As per ISO 80000-2, "signum" is 'sgn'
            symbol: ['\\operatorname', '<{>', 's', 'g', 'n', '<}>'],
        },
    },
];

/**
 * Trigonometric functions have some special conventions that require a
 * custom parser: they can be followed by a "-1" superscript indicating
 * that the inversion function should be used, i.e. "\sin^{-1}" for "arcsin".
 *
 */
function parseTrig(_lhs, scanner, _minPrec) {
    var _a;
    const op = scanner.next();
    let isInverse = false;
    let primeLevel = 0;
    scanner.skipSpace();
    if (scanner.match('^')) {
        scanner.skipSpace();
        if (scanner.match('<{>')) {
            scanner.skipSpace();
            // There's a superscript..., parse it.
            if (scanner.match('-') && scanner.match('1')) {
                isInverse = true;
            }
            do {
                if (scanner.match('\\doubleprime')) {
                    primeLevel += 2;
                }
                if (scanner.match('\\prime')) {
                    primeLevel += 1;
                }
                if (scanner.match("'")) {
                    primeLevel += 1;
                }
            } while (!scanner.match('<}>') && !scanner.atEnd);
        }
        let done = false;
        while (!done) {
            scanner.skipSpace();
            if (scanner.match('\\doubleprime')) {
                primeLevel += 2;
            }
            else if (scanner.match('\\prime')) {
                primeLevel += 1;
            }
            else if (scanner.match("'")) {
                primeLevel += 1;
            }
            else {
                done = true;
            }
        }
    }
    // Note: names as per NIST-DLMF
    let head = (_a = {
        '\\arcsin': 'Arcsin',
        '\\arccos': 'Arccos',
        '\\arctan': 'Arctan',
        '\\arctg': 'Arctan',
        '\\arcctg': 'Arctan',
        '\\arcsec': 'Arcsec',
        '\\arccsc': ' Arccsc',
        '\\arsinh': 'Arsinh',
        '\\arcosh': 'Arcosh',
        '\\artanh': 'Artanh',
        '\\arcsech': 'Arcsech',
        '\\arccsch': 'Arcsch',
        // '\\arg',
        '\\ch': 'Cosh',
        '\\cos': 'Cos',
        '\\cosec': 'Csc',
        '\\cosh': 'Csch',
        '\\cot': 'Cot',
        '\\cotg': 'Cot',
        '\\coth': 'Coth',
        '\\csc': 'Csc',
        '\\ctg': 'Cot',
        '\\cth': 'Coth',
        '\\sec': 'Sec',
        '\\sin': 'Sin',
        '\\sinh': 'Sinh',
        '\\sh': 'Sinh',
        '\\tan': 'Tan',
        '\\tanh': 'Tanh',
        '\\tg': 'Tan',
        '\\th': 'Tanh',
    }[op]) !== null && _a !== void 0 ? _a : op;
    if (isInverse) {
        head = [INVERSE_FUNCTION, head];
    }
    if (primeLevel >= 1) {
        head = [DERIVATIVE, primeLevel, head];
    }
    const args = scanner.matchArguments('implicit');
    if (args === null) {
        return [null, head];
    }
    return [null, [head, ...args]];
}
const DEFINITIONS_TRIGONOMETRY = [
    {
        name: 'Arcsin',
        trigger: '\\arcsin',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arccos',
        trigger: '\\arccos',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arctan',
        trigger: '\\arctan',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arctan',
        trigger: '\\arctg',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arccot',
        trigger: '\\arcctg',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arcsec',
        trigger: '\\arcsec',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arccsc',
        trigger: '\\arccsc',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arsinh',
        trigger: '\\arsinh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arcosh',
        trigger: '\\arcosh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Artanh',
        trigger: '\\artanh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arsech',
        trigger: '\\arsech',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Arcsch',
        trigger: '\\arcsch',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cosh',
        trigger: '\\ch',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cosec',
        trigger: '\\cosec',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cosh',
        trigger: '\\cosh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cot',
        trigger: '\\cot',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cot',
        trigger: '\\cotg',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Coth',
        trigger: '\\coth',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Csc',
        trigger: '\\csc',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cot',
        trigger: '\\ctg',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Coth',
        trigger: '\\cth',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Sec',
        trigger: '\\sec',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Sinh',
        trigger: '\\sinh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Sinh',
        trigger: '\\sh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Tan',
        trigger: '\\tan',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Tan',
        trigger: '\\tg',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Tanh',
        trigger: '\\tanh',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Tanh',
        trigger: '\\th',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Cos',
        trigger: '\\cos',
        arguments: 'implicit',
        parse: parseTrig,
    },
    {
        name: 'Sin',
        trigger: '\\sin',
        arguments: 'implicit',
        parse: parseTrig,
    },
];

const DEFINITIONS_ALGEBRA = [
    {
        name: 'To',
        trigger: { infix: '\\to' },
        precedence: 270, // MathML rightwards arrow
    },
];

const DEFINITIONS_SETS = [
    // Sets
    { trigger: { symbol: '\\N' }, parse: 'NaturalNumber' },
    { trigger: { symbol: '\\Z' }, parse: 'Integer' },
    { trigger: { symbol: '\\Q' }, parse: 'RationalNumber' },
    {
        trigger: { symbol: ['\\mathbb', '<{>', 'A', '<}>'] },
        parse: 'AlgebraicNumber',
    },
    { trigger: { symbol: '\\R' }, parse: 'RealNumber' },
    { trigger: { symbol: '\\C' }, parse: 'ComplexNumber' },
    { trigger: { symbol: '\\varnothing' }, parse: 'EmptySet' },
    { trigger: { symbol: '\\emptyset' }, parse: 'EmptySet' },
    {
        name: 'Complement',
        trigger: { infix: '\\complement' },
        precedence: 240,
    },
    {
        name: 'Element',
        trigger: { infix: '\\in' },
        precedence: 240,
    },
    {
        name: 'Intersection',
        trigger: { infix: '\\Cap' },
        precedence: 350,
    },
    {
        name: 'NotElement',
        trigger: { infix: '\\notin' },
        precedence: 240,
    },
    {
        name: 'SetMinus',
        trigger: { infix: '\\setminus' },
        precedence: 650,
    },
    {
        name: 'SubsetEqual',
        trigger: { infix: '\\subseteq' },
        precedence: 240,
    },
    {
        name: 'SymmetricDifference',
        trigger: { infix: '\\triangle' },
        precedence: 260,
    },
    {
        name: 'Union',
        trigger: { infix: '\\cup' },
        precedence: 350,
    },
    {
        name: 'Contains',
        trigger: { infix: '\\ni' },
        associativity: 'right',
        precedence: 160, // As per MathML, lower precedence
    },
    {
        name: 'Subset',
        trigger: { infix: '\\subset' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SquareSubset',
        trigger: { infix: '\\sqsubset' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'SquareSubsetEqual',
        trigger: { infix: '\\sqsubseteq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'Superset',
        trigger: { infix: '\\supset' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SquareSuperset',
        trigger: { infix: '\\sqsupset' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'SquareSupersetEqual',
        trigger: { infix: '\\sqsupseteq' },
        associativity: 'right',
        precedence: 265,
    },
    {
        name: 'NotSubset',
        trigger: { infix: '\\nsubset' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSuperset',
        trigger: { infix: '\\nsupset' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SupersetEqual',
        trigger: { infix: '\\supseteq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSubsetNotEqual',
        trigger: { infix: '\\nsubseteq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'NotSupersetNotEqual',
        trigger: { infix: '\\nsupseteq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SubsetNotEqual',
        trigger: { infix: '\\subsetneq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SubsetNotEqual',
        trigger: { infix: '\\varsupsetneqq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SupersetNotEqual',
        trigger: { infix: '\\supsetneq' },
        associativity: 'right',
        precedence: 240,
    },
    {
        name: 'SupersetNotEqual',
        trigger: { infix: '\\varsupsetneq' },
        associativity: 'right',
        precedence: 240,
    },
];

function parseIntegral(lhs, scanner, _minPrec) {
    if (!scanner.match('\\int'))
        return [lhs, null];
    // There could be some superscript and subscripts
    let sup = NOTHING;
    let sub = NOTHING;
    let done = false;
    while (!done) {
        scanner.skipSpace();
        if (scanner.match('_')) {
            sub = scanner.matchRequiredLatexArgument();
        }
        else if (scanner.match('^')) {
            sup = scanner.matchRequiredLatexArgument();
        }
        else {
            done = true;
        }
    }
    // @todo: that's not quite right: the integral of the function is denoted
    // by a `...dx` pattern, e.g. `\int \sin(x)dx`
    const fn = scanner.matchBalancedExpression('<{>', '<}>');
    return [lhs, ['Integral', fn !== null && fn !== void 0 ? fn : '', sup !== null && sup !== void 0 ? sup : NOTHING, sub !== null && sub !== void 0 ? sub : NOTHING]];
}
function serializeIntegral(_serializer, _expr) {
    return '';
}
const DEFINITIONS_CALCULUS = [
    {
        trigger: { symbol: '\\int' },
        parse: parseIntegral,
        serialize: serializeIntegral,
    },
];

const DEFINITIONS_SYMBOLS = [
    // Greek
    { trigger: { symbol: '\\alpha' }, parse: '\u03b1' },
    { trigger: { symbol: '\\beta' }, parse: '\u03b2' },
    { trigger: { symbol: '\\gamma' }, parse: '\u03b3' },
    { trigger: { symbol: '\\delta' }, parse: '\u03b4' },
    { trigger: { symbol: '\\epsilon' }, parse: '\u03f5' },
    { trigger: { symbol: '\\varepsilon' }, parse: '\u03b5' },
    { trigger: { symbol: '\\zeta' }, parse: '\u03b6' },
    { trigger: { symbol: '\\eta' }, parse: '\u03b7' },
    { trigger: { symbol: '\\theta' }, parse: '\u03b8' },
    { trigger: { symbol: '\\vartheta' }, parse: '\u03d1' },
    { trigger: { symbol: '\\iota' }, parse: '\u03b9' },
    { trigger: { symbol: '\\kappa' }, parse: '\u03ba' },
    { trigger: { symbol: '\\varkappa' }, parse: '\u03f0' },
    { trigger: { symbol: '\\lambda' }, parse: '\u03bb' },
    { trigger: { symbol: '\\mu' }, parse: '\u03bc' },
    { trigger: { symbol: '\\nu' }, parse: '\u03bd' },
    { trigger: { symbol: '\\xi' }, parse: '\u03be' },
    { trigger: { symbol: '\\omicron' }, parse: '\u03bf' },
    // { trigger: { symbol: '\\pi' }, parse: '\u03c0' },
    { trigger: { symbol: '\\varpi' }, parse: '\u03d6' },
    { trigger: { symbol: '\\rho' }, parse: '\u03c1' },
    { trigger: { symbol: '\\varrho' }, parse: '\u03f1' },
    { trigger: { symbol: '\\sigma' }, parse: '\u03c3' },
    { trigger: { symbol: '\\varsigma' }, parse: '\u03c2' },
    { trigger: { symbol: '\\tau' }, parse: '\u03c4' },
    { trigger: { symbol: '\\phi' }, parse: '\u03d5' },
    { trigger: { symbol: '\\varphi' }, parse: '\u03c6' },
    { trigger: { symbol: '\\upsilon' }, parse: '\u03c5' },
    { trigger: { symbol: '\\chi' }, parse: '\u03c7' },
    { trigger: { symbol: '\\psi' }, parse: '\u03c8' },
    { trigger: { symbol: '\\omega' }, parse: '\u03c9' },
    { trigger: { symbol: '\\Gamma' }, parse: '\u0393' },
    { trigger: { symbol: '\\Delta' }, parse: '\u0394' },
    { trigger: { symbol: '\\Theta' }, parse: '\u0398' },
    { trigger: { symbol: '\\Lambda' }, parse: '\u039b' },
    { trigger: { symbol: '\\Xi' }, parse: '\u039e' },
    { trigger: { symbol: '\\Pi' }, parse: '\u03a0' },
    { trigger: { symbol: '\\Sigma' }, parse: '\u03a3' },
    { trigger: { symbol: '\\Upsilon' }, parse: '\u03a5' },
    { trigger: { symbol: '\\Phi' }, parse: '\u03a6' },
    { trigger: { symbol: '\\Psi' }, parse: '\u03a8' },
    { trigger: { symbol: '\\Omega' }, parse: '\u03a9' },
    { trigger: { symbol: '\\digamma' }, parse: '\u03dd' },
    // Hebrew
    { trigger: { symbol: '\\aleph' }, parse: '\u2135' },
    { trigger: { symbol: '\\beth' }, parse: '\u2136' },
    { trigger: { symbol: '\\daleth' }, parse: '\u2138' },
    { trigger: { symbol: '\\gimel' }, parse: '\u2137' },
    // Letter-like
    { trigger: { symbol: '\\Finv' }, parse: '\u2132' },
    { trigger: { symbol: '\\Game' }, parse: '\u2141' },
    { trigger: { symbol: '\\wp' }, parse: '\u2118' },
    { trigger: { symbol: '\\eth' }, parse: '\u00f0' },
    { trigger: { symbol: '\\mho' }, parse: '\u2127' },
    // Symbols
    { trigger: { symbol: '\\clubsuit' }, parse: '\u2663' },
    { trigger: { symbol: '\\heartsuit' }, parse: '\u2661' },
    { trigger: { symbol: '\\spadesuit' }, parse: '\u2660' },
    { trigger: { symbol: '\\diamondsuit' }, parse: '\u2662' },
    { trigger: { symbol: '\\sharp' }, parse: '\u266f' },
    { trigger: { symbol: '\\flat' }, parse: '\u266d' },
    { trigger: { symbol: '\\natural' }, parse: '\u266e' },
];

function triggerLength(trigger) {
    if (Array.isArray(trigger))
        return trigger.length;
    return 1;
}
function triggerString(trigger) {
    return tokensToString(trigger);
}
// function hasDef(dic: LatexDictionary, latex: string): boolean {
//     let result = false;
//     dic.forEach((x) => {
//         if (x.trigger) {
//             if (typeof x.trigger === 'string' && x.trigger === latex) {
//                 result = true;
//             } else if (
//                 typeof x.trigger !== 'string' &&
//                 (triggerString(x.trigger.infix) === latex ||
//                     triggerString(x.trigger.postfix) === latex ||
//                     triggerString(x.trigger.symbol) === latex ||
//                     triggerString(x.trigger.prefix) === latex ||
//                     triggerString(x.trigger.matchfix) === latex ||
//                     triggerString(x.closeFence) === latex)
//             ) {
//                 result = true;
//             }
//         }
//     });
//     return result;
// }
function indexLatexDictionary(dic, onError) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const result = {
        lookahead: 1,
        name: new Map(),
        prefix: [],
        infix: [],
        postfix: [],
        matchfix: [],
        superfix: [],
        subfix: [],
        symbol: [],
        environment: new Map(),
    };
    for (const record of dic) {
        if (record.parse === undefined) {
            // By default, when a latex string triggers, the generated
            // output is the name of this record, i.e. MULTIPLY
            record.parse = record.name;
        }
        // If the trigger is a string, it's a shortcut for a symbol
        if (typeof record.trigger === 'string') {
            record.trigger = { symbol: record.trigger };
        }
        if (typeof record.serialize === 'string') {
            if (((_a = record.trigger) === null || _a === void 0 ? void 0 : _a.symbol) !== undefined) {
                if (/#[0-9]/.test(record.serialize)) {
                    onError({ code: 'unexpected-argument', arg: record.name });
                }
            }
        }
        if (record.serialize === undefined) {
            // By default, when latex is serialized for this record,
            // it is the same as the trigger (note there could be multiple
            // triggers, so we just pick one)
            if (((_b = record.trigger) === null || _b === void 0 ? void 0 : _b.postfix) !== undefined) {
                record.serialize = '#1' + triggerString(record.trigger.postfix);
            }
            else if (((_c = record.trigger) === null || _c === void 0 ? void 0 : _c.prefix) !== undefined) {
                record.serialize = triggerString(record.trigger.prefix) + '#1';
            }
            else if (((_d = record.trigger) === null || _d === void 0 ? void 0 : _d.infix) !== undefined) {
                record.serialize = '#1' + triggerString(record.trigger.infix) + '#2';
            }
            else if (((_e = record.trigger) === null || _e === void 0 ? void 0 : _e.symbol) !== undefined) {
                record.serialize = triggerString(record.trigger.symbol);
            }
            else if (((_f = record.trigger) === null || _f === void 0 ? void 0 : _f.superfix) !== undefined) {
                record.serialize =
                    '#1^{' + triggerString((_g = record.trigger) === null || _g === void 0 ? void 0 : _g.superfix) + '}';
            }
            else if (((_h = record.trigger) === null || _h === void 0 ? void 0 : _h.subfix) !== undefined) {
                record.serialize = '#1_{' + triggerString((_j = record.trigger) === null || _j === void 0 ? void 0 : _j.subfix) + '}';
            }
            else {
                record.serialize = '';
            }
        }
        if (((_k = record.trigger) === null || _k === void 0 ? void 0 : _k.infix) !== undefined) {
            if (record.precedence === undefined) {
                onError({
                    code: 'syntax-error',
                    arg: 'Infix operators require a precedence',
                });
            }
            if (!record.associativity) {
                record.associativity = 'non';
            }
        }
        if (((_l = record.trigger) === null || _l === void 0 ? void 0 : _l.symbol) !== undefined) {
            record.arguments = (_m = record.arguments) !== null && _m !== void 0 ? _m : '';
            record.optionalLatexArg = (_o = record.optionalLatexArg) !== null && _o !== void 0 ? _o : 0;
            record.requiredLatexArg = (_p = record.requiredLatexArg) !== null && _p !== void 0 ? _p : 0;
        }
        if (((_q = record.trigger) === null || _q === void 0 ? void 0 : _q.matchfix) !== undefined) {
            if (record.parse !== 'function' && !record.closeFence) {
                onError({
                    code: 'syntax-error',
                    arg: 'Matchfix operators require a close fence or a custom parse function',
                });
            }
        }
        if (record.trigger !== undefined) {
            [
                'infix',
                'prefix',
                'postfix',
                'symbol',
                'matchfix',
                'superfix',
                'subfix',
            ].forEach((x) => {
                if (record.trigger[x]) {
                    const n = triggerLength(record.trigger[x]);
                    result.lookahead = Math.max(result.lookahead, n);
                    if (result[x][n] === undefined) {
                        result[x][n] = new Map();
                    }
                    result[x][n].set(triggerString(record.trigger[x]), record);
                }
            });
            if (record.trigger.environment !== undefined) {
                result.environment.set(record.trigger.environment, record);
            }
        }
        if (record.name !== undefined) {
            result.name.set(triggerString(record.name), record);
        }
        else if (typeof record.parse === 'string') {
            result.name.set(record.parse, record);
        }
        if (record.trigger === undefined && !record.name) {
            // A trigger OR a name is required.
            // The trigger maps latex -> json
            // The name maps json -> latex
            onError({
                code: 'syntax-error',
                arg: 'Need at least a trigger or a name',
            });
        }
    }
    return result;
}
// left-operators, supfix/subfix:
// subscript
// sub-plus     super-plus
// sub-minus    super-minus
// sub-star     super-star
//              super-dagger
// over-bar     under-bar
// over-vector
// over-tilde
// over-hat
// over-dot
// overscript   underscript
// matchfix:
// angle-brack
// floor
// ceiling
// infix operators:
//->   rule
// :>   rule-delayed
// ==   eq
// !=   ne
// https://reference.wolfram.com/language/tutorial/OperatorInputForms.html
const DEFAULT_LATEX_DICTIONARY = {
    algebra: DEFINITIONS_ALGEBRA,
    arithmetic: DEFINITIONS_ARITHMETIC,
    calculus: DEFINITIONS_CALCULUS,
    core: DEFINITIONS_CORE,
    inequalities: DEFINITIONS_INEQUALITIES,
    other: DEFINITIONS_OTHERS,
    physics: [
        {
            name: 'mu-0',
            trigger: { symbol: ['\\mu', '_', '0'] },
        },
    ],
    sets: DEFINITIONS_SETS,
    symbols: DEFINITIONS_SYMBOLS,
    trigonometry: DEFINITIONS_TRIGONOMETRY,
};
// {
//     const defaultDic = getDefaultLatexDictionary();
//     let i = 0;
//     for (const x of Object.keys(FUNCTIONS)) {
//         if (x.startsWith('\\') && !hasDef(defaultDic, x)) {
//             i++;
//             console.log(i + ' No def for function ' + x);
//         }
//     }
//     for (const x of Object.keys(MATH_SYMBOLS)) {
//         if (x.startsWith('\\') && !hasDef(defaultDic, x)) {
//             i++;
//             console.log(i + ' No def for symbol ' + x);
//         }
//     }
// }
// {
//     const defaultLatexDic = indexLatexDictionary(
//         getDefaultLatexDictionary('all'),
//         () => {
//             return;
//         }
//     );
//     const defaultDic = getDefaultDictionary('all');
//     let i = 0;
//     Array.from(defaultLatexDic.name.keys()).forEach((x) => {
//         if (!findInDictionary(defaultDic, x)) {
//             console.log(Number(i++).toString() + ' No entry for ' + x);
//         }
//     });
// }

const DEFAULT_LATEX_NUMBER_OPTIONS = {
    precision: 15,
    positiveInfinity: '\\infty',
    negativeInfinity: '-\\infty',
    notANumber: '\\operatorname{NaN}',
    decimalMarker: '.',
    groupSeparator: ',',
    exponentProduct: '\\cdot',
    beginExponentMarker: '10^{',
    endExponentMarker: '}',
    notation: 'auto',
    truncationMarker: '\\ldots',
    beginRepeatingDigits: '\\overline{',
    endRepeatingDigits: '}',
    imaginaryNumber: '\\imaginaryI',
};
const DEFAULT_PARSE_LATEX_OPTIONS = {
    invisibleOperator: MULTIPLY,
    skipSpace: true,
    parseArgumentsOfUnknownLatexCommands: true,
    parseNumbers: true,
    promoteUnknownSymbols: /^[a-zA-Z]$/,
    promoteUnknownFunctions: /^[fg]$/,
    ignoreCommands: [
        '\\displaystyle',
        '\\!',
        '\\:',
        '\\enskip',
        '\\quad',
        '\\,',
        '\\;',
        '\\enspace',
        '\\qquad',
        '\\selectfont',
        '\\tiny',
        '\\scriptsize',
        '\\footnotesize',
        '\\small',
        '\\normalsize',
        '\\large',
        '\\Large',
        '\\LARGE',
        '\\huge',
        '\\Huge',
    ],
    idempotentCommands: [
        '\\left',
        '\\right',
        '\\mleft',
        '\\mright',
        '\\middle',
        '\\bigl',
        '\\bigm',
        '\\bigr',
        '\\Bigl',
        '\\Bigm',
        '\\Bigr',
        '\\biggl',
        '\\biggm',
        '\\biggr',
        '\\Biggl',
        '\\Biggm',
        '\\Biggr',
    ],
    invisiblePlusOperator: ADD,
    preserveLatex: false,
};
const DEFAULT_SERIALIZE_LATEX_OPTIONS = {
    invisibleMultiply: '',
    invisiblePlus: '',
    // invisibleApply: '',
    multiply: '\\times',
    // openGroup: '(',
    // closeGroup: ')',
    // divide: '\\frac{#1}{#2}',
    // subtract: '#1-#2',
    // add: '#1+#2',
    // negate: '-#1',
    // squareRoot: '\\sqrt{#1}',
    // nthRoot: '\\sqrt[#2]{#1}',
};
/**
 * Replace '#1', '#2' in the latex template stings with the corresponding
 * values from `replacement`, in a Latex syntax safe manner (i.e. inserting spaces when needed)
 */
function replaceLatex(template, replacement) {
    var _a;
    console.assert(typeof template === 'string');
    console.assert(template.length > 0);
    let result = template;
    for (let i = 0; i < replacement.length; i++) {
        let s = (_a = replacement[i]) !== null && _a !== void 0 ? _a : '';
        if (/[a-zA-Z*]/.test(s[0])) {
            const m = result.match(new RegExp('(.*)#' + Number(i + 1).toString()));
            if (m && /\\[a-zA-Z*]+/.test(m[1])) {
                s = ' ' + s;
            }
        }
        result = result.replace('#' + Number(i + 1).toString(), s);
    }
    return result;
}

class Scanner {
    constructor(tokens, options, dictionary, onError) {
        this.index = 0;
        this.options = {
            ...DEFAULT_LATEX_NUMBER_OPTIONS,
            ...DEFAULT_PARSE_LATEX_OPTIONS,
            ...options,
        };
        this.tokens = tokens;
        this.onError = (err) => {
            return onError({
                ...err,
                before: this.latexBefore(),
                after: this.latexAfter(),
            });
        };
        this.dictionary = dictionary;
        let def;
        this.invisibleOperatorPrecedence = 0;
        if (this.options.invisibleOperator) {
            def = this.dictionary.name.get(this.options.invisibleOperator);
            if (def === undefined) {
                onError({
                    code: 'unknown-operator',
                    arg: 'invisible operator ' + this.options.invisibleOperator,
                });
            }
            else if (def.precedence === undefined) {
                onError({
                    code: 'expected-operator',
                    arg: 'invisible operator ' + this.options.invisibleOperator,
                });
            }
            else {
                this.invisibleOperatorPrecedence = def.precedence;
            }
        }
    }
    clone(start, end) {
        return new Scanner(this.tokens.slice(start, end), this.options, this.dictionary, this.onError);
    }
    balancedClone(open, close, silentError = true) {
        if (!this.matchAll(open)) {
            if (!silentError) {
                this.onError({
                    code: 'syntax-error',
                    arg: 'Expected ' + tokensToString(open),
                });
            }
            return null;
        }
        const start = this.index;
        let end = start;
        let level = 1;
        while (!this.atEnd && level !== 0) {
            this.skipSpace();
            // In case of ambiguity, we prioritize close fence over open,
            // e.g. `|a|+b+|c|` -> `(|a|)+b+(|c|)`
            // So we check *first* if it's a closefence, before trying to
            // match an expression which would interpret an open fence
            end = this.index;
            if (this.matchAll(close)) {
                level -= 1;
            }
            else if (this.matchAll(open)) {
                level += 1;
            }
            else {
                this.next();
            }
        }
        if (level !== 0) {
            if (!silentError) {
                this.onError({
                    code: 'unbalanced-symbols',
                    arg: tokensToString(open) + tokensToString(close),
                });
            }
            this.index = start;
            return null;
        }
        return this.clone(start, end);
    }
    get atEnd() {
        return this.index >= this.tokens.length;
    }
    get peek() {
        return this.tokens[this.index];
    }
    latex(start, end) {
        return tokensToString(this.tokens.slice(start, end));
    }
    latexAhead(n) {
        return tokensToString(this.tokens.slice(this.index, this.index + n));
    }
    latexBefore() {
        return this.latex(0, this.index);
    }
    latexAfter() {
        return this.latex(this.index);
    }
    /**
     * Return at most `maxLookahead` strings made from the tokens
     * ahead.
     *
     * The index in the returned array correspond to the number of tokens.
     * Note that since a token can be longer than one char ('\\pi', but also
     * some astral plane unicode characters), the length of the string
     * does not match that index. However, knowing the index is important
     * to know by how many tokens to advance.
     *
     */
    lookAhead() {
        let n = Math.min(this.dictionary.lookahead, this.tokens.length - this.index);
        const result = [];
        while (n > 0) {
            result[n] = this.latexAhead(n--);
        }
        return result;
    }
    peekDefinition(kind) {
        let defs;
        if (kind === 'operator') {
            defs = this.lookAhead().map((x, n) => {
                var _a, _b, _c, _d, _e;
                return (_d = (_b = (_a = this.dictionary.infix[n]) === null || _a === void 0 ? void 0 : _a.get(x)) !== null && _b !== void 0 ? _b : (_c = this.dictionary.postfix[n]) === null || _c === void 0 ? void 0 : _c.get(x)) !== null && _d !== void 0 ? _d : (_e = this.dictionary.prefix[n]) === null || _e === void 0 ? void 0 : _e.get(x);
            });
        }
        else {
            defs = this.lookAhead().map((x, n) => { var _a; return (_a = this.dictionary[kind][n]) === null || _a === void 0 ? void 0 : _a.get(x); });
        }
        for (let i = defs.length; i > 0; i--) {
            if (defs[i] !== undefined)
                return [defs[i], i];
        }
        return [null, 0];
    }
    next() {
        return this.tokens[this.index++];
    }
    skipSpace() {
        // Check if the have a `{}` token sequence.
        // Those are used in Latex to force an invisible separation between commands
        if (!this.atEnd &&
            this.peek === '<{>' &&
            this.tokens[this.index + 1] === '<}>') {
            this.index += 2;
            this.skipSpace();
            return true;
        }
        let result = false;
        // Check if we have an ignorable command (e.g. \displaystyle and other
        // purely presentational commands)
        while (!this.atEnd &&
            (this.options.ignoreCommands.includes(this.peek) ||
                this.options.idempotentCommands.includes(this.peek))) {
            this.index += 1;
            this.skipSpace();
            result = true;
        }
        if (!this.options.skipSpace)
            return false;
        while (this.match('<space>'))
            result = true;
        if (result)
            this.skipSpace();
        return result;
    }
    match(target) {
        if (this.tokens[this.index] === target) {
            this.index++;
            return true;
        }
        return false;
    }
    matchAll(target) {
        let matched = true;
        if (typeof target === 'string') {
            target = [target];
        }
        let i = 0;
        do {
            matched = this.tokens[this.index + i] === target[i++];
        } while (matched && i < target.length);
        if (matched) {
            this.index += i;
        }
        return matched;
    }
    matchAny(targets) {
        if (targets.includes(this.tokens[this.index])) {
            return this.tokens[this.index++];
        }
        return '';
    }
    matchWhile(targets) {
        const result = [];
        while (targets.includes(this.tokens[this.index])) {
            result.push(this.tokens[this.index++]);
        }
        return result;
    }
    matchSign() {
        let isNegative = false;
        let done = false;
        while (!done) {
            if (this.skipSpace()) {
                done = false;
            }
            else if (this.match('-')) {
                isNegative = !isNegative;
                done = false;
            }
            else if (this.match('+')) {
                done = false;
            }
            else {
                done = true;
            }
        }
        return isNegative ? '-' : '+';
    }
    matchDecimalDigits() {
        let result = '';
        let done = false;
        while (!done) {
            result += this.matchWhile([
                '0',
                '1',
                '2',
                '3',
                '4',
                '5',
                '6',
                '7',
                '8',
                '9',
            ]).join('');
            done = true;
            if (this.options.groupSeparator) {
                const savedIndex = this.index;
                if (this.match(this.options.groupSeparator)) {
                    if (/[0-9]/.test(this.peek)) {
                        done = false;
                    }
                    else {
                        this.index = savedIndex;
                    }
                }
            }
        }
        return result;
    }
    matchSignedInteger() {
        const savedIndex = this.index;
        const sign = this.matchSign();
        const result = this.matchDecimalDigits();
        if (result)
            return (sign === '-' ? '-' : '') + result;
        this.index = savedIndex;
        return '';
    }
    matchExponent() {
        const savedIndex = this.index;
        let result = '';
        if (this.matchAny(['e', 'E', 'd', 'D'])) {
            const exponent = this.matchSignedInteger();
            if (exponent) {
                result = 'e' + exponent;
            }
        }
        if (result)
            return result;
        if (this.match('\\times')) {
            this.skipSpace();
            if (this.match('1') && this.match('0') && this.match('^')) {
                if (/[0-9]/.test(this.peek)) {
                    return 'e' + this.next();
                }
                if (this.match('<{>')) {
                    this.skipSpace();
                    const exponent = this.matchSignedInteger();
                    this.skipSpace();
                    if (this.match('<}>') && exponent) {
                        return 'e' + exponent;
                    }
                }
            }
        }
        this.index = savedIndex;
        return '';
    }
    matchNumber() {
        var _a, _b;
        if (!this.options.parseNumbers)
            return '';
        const savedIndex = this.index;
        const sign = this.matchSign();
        let result = this.matchDecimalDigits();
        if (!result) {
            this.index = savedIndex;
            return '';
        }
        result = (sign === '-' ? '-' : '') + result;
        let hasDecimalMarker = false;
        let hasExponent = false;
        if (this.match((_a = this.options.decimalMarker) !== null && _a !== void 0 ? _a : '')) {
            hasDecimalMarker = true;
            result += '.' + ((_b = this.matchDecimalDigits()) !== null && _b !== void 0 ? _b : '0');
        }
        const exponent = this.matchExponent();
        if (exponent)
            hasExponent = true;
        if (result) {
            // If the number has more than about 10 significant digits, use a Decimal or BigInt
            if (result.length + exponent.length > 12) {
                if (hasDecimalMarker || hasExponent) {
                    return result + exponent + 'd'; // Decimal number
                }
                else {
                    return result + 'n'; // BigInt
                }
            }
            return result + exponent;
        }
        this.index = savedIndex;
        return '';
    }
    matchOperator(kind, lhs = null, minPrec = 0) {
        const [def, n] = this.peekDefinition(kind);
        if (def === null)
            return null;
        if (typeof def.parse === 'function') {
            // Custom parser found
            let rhs = null;
            [lhs, rhs] = def.parse(lhs, this, minPrec);
            if (rhs === null)
                return null;
            return this.applyInvisibleOperator(lhs, rhs);
        }
        let prec = def.precedence;
        if (prec === undefined || prec < minPrec)
            return null;
        prec += def.associativity === 'left' ? 1 : 0;
        this.index += n;
        const rhs = this.matchExpression(prec);
        return this.applyInvisibleOperator(...this.applyOperator(def.parse, lhs, rhs));
    }
    matchArguments(kind) {
        if (!kind)
            return null;
        const savedIndex = this.index;
        let result = null;
        const group = this.matchMatchfixOperator();
        if (kind === 'group' && getFunctionName(group) === PARENTHESES) {
            // We got a group i.e. `f(a, b, c)`
            result = getTail(group);
        }
        else if (kind === 'implicit') {
            // Does this function allow arguments with optional parentheses?
            // (i.e. trig functions, as in `\cos x`.
            if (getFunctionName(group) === PARENTHESES) {
                result = getTail(group);
            }
            else if (group !== null) {
                // There was a matchfix, the "group" is the argument, i.e.
                // `\sin [a, b, c]`
                result = [group];
            }
            else {
                // No group, but arguments without parentheses are allowed
                // Read a primary
                // (i.e. we interpret `\cos x + 1` as `\cos(x) + 1`)
                const primary = this.matchPrimary();
                if (primary !== null)
                    result = [primary];
            }
        }
        else {
            // The element following the function does not match
            // a possible argument list
            // That's OK, but need to undo the parsing of the matchfix
            // This is the case: `f[a]` or `f|a|`
            this.index = savedIndex;
        }
        return result;
    }
    matchMatchfixOperator() {
        const [def] = this.peekDefinition('matchfix');
        if (def === null)
            return null;
        if (typeof def.parse === 'function') {
            // Custom parser: invoke it.
            return this.applyInvisibleOperator(...def.parse(null, this, 0));
        }
        const trigger = typeof def.trigger === 'object' ? def.trigger.matchfix : def.trigger;
        if (!trigger || !def.closeFence || !def.parse)
            return null;
        const arg = this.matchBalancedExpression(trigger, def.closeFence, this.onError);
        if (!arg)
            return [def.parse];
        return [def.parse, arg];
    }
    matchDefinition(kind) {
        // Find the longest string of tokens with a definition of the
        // specified kind
        const [def, tokenCount] = this.peekDefinition(kind);
        // If there is a custom parsing function associated with this
        // definition, invoke it.
        if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
            const [, result] = def.parse(null, this, 0);
            return [def, result];
        }
        this.index += tokenCount;
        return [def, null];
    }
    /**
     * A symbol can be:
     * - a constant: `\pi`
     * - a variable: `x`
     * - a function with explicit arguments `f(x)`
     * - a function with implicit arguments: `\cos x`
     * - a command: `\frac{2}{3}`
     */
    matchSymbol() {
        var _a, _b, _c, _d;
        const [def, result] = this.matchDefinition('symbol');
        // If a result is ready (because there was a parsing function associated
        // with the definition), we're done
        if (result !== null)
            return result;
        if (def === null) {
            // This is an unknown symbol.
            // Can we promote it?
            if ((_a = this.options.promoteUnknownFunctions) === null || _a === void 0 ? void 0 : _a.test(this.peek)) {
                const name = this.next();
                // this.onError({ code: 'unknown-function', arg: name });
                const group = this.matchMatchfixOperator();
                // If no arguments, return it as a symbol
                if (group === null)
                    return name;
                if (getFunctionName(group) !== PARENTHESES)
                    return null;
                return [name, ...getTail(group)];
            }
            if ((_b = this.options.promoteUnknownSymbols) === null || _b === void 0 ? void 0 : _b.test(this.peek)) {
                // this.onError({ code: 'unknown-symbol', arg: this.peek });
                return this.next();
            }
            // Not a symbol (punctuation or fence, maybe?)...
            return this.matchUnknownLatexCommand();
        }
        //
        // Is it a Latex function, e.g. `\frac{}{}`?
        //
        const requiredArgs = [];
        const optionalArgs = [];
        let arg;
        let i = (_c = def.optionalLatexArg) !== null && _c !== void 0 ? _c : 0;
        while (i > 0) {
            arg = this.matchOptionalLatexArgument();
            if (arg !== null)
                optionalArgs.push(arg);
            i--;
        }
        i = (_d = def.requiredLatexArg) !== null && _d !== void 0 ? _d : 0;
        while (i > 0) {
            arg = this.matchRequiredLatexArgument();
            // `null` indicate that no required argument was found
            if (arg === null)
                this.onError({ code: 'expected-argument' });
            // `""` indicate an empty argument, i.e. `{}` was found
            if (arg !== null)
                requiredArgs.push(arg);
            i--;
        }
        const args = this.matchArguments(def.arguments);
        if (args === null) {
            // Didn't get arguments
            if (requiredArgs.length === 0 && optionalArgs.length === 0) {
                return def.parse;
            }
            return [def.parse, ...requiredArgs, ...optionalArgs];
        }
        return [def.parse, ...requiredArgs, ...args, ...optionalArgs];
    }
    matchOptionalLatexArgument() {
        this.skipSpace();
        return this.matchBalancedExpression('[', ']');
    }
    /**
     * Match a required latex argument:
     * - either enclosed in `{}`
     * - or a single token.
     *
     * Return null if an argument was not found
     * Return '' if an empty argument `{}` was found
     */
    matchRequiredLatexArgument() {
        this.skipSpace();
        const expr = this.matchBalancedExpression('<{>', '<}>');
        if (expr)
            return expr;
        // Is it a single digit?
        if (/^[0-9]$/.test(this.peek)) {
            // ... only match the digit, i.e. `x^23` is `x^{2}3`, not x^{23}
            return parseFloat(this.next());
        }
        // Is it a single letter (but not a special letter)?
        if (/^[^\\#]$/.test(this.peek)) {
            return this.next();
        }
        // Otherwise, this can only be a symbol.
        // `frac{1}2+1` is not valid, neither is `\frac\frac123`
        return this.matchSymbol();
    }
    /**
     *  Match a superfix/subfix operator, e.g. `^{*}`
     */
    matchSupsub(lhs) {
        if (lhs === null)
            return null;
        let result = null;
        this.skipSpace();
        [
            ['^', 'superfix'],
            ['_', 'subfix'],
        ].forEach((x) => {
            var _a, _b, _c;
            if (result !== null)
                return;
            const [triggerChar, opKind] = x;
            const beforeTrigger = this.index;
            if (!this.match(triggerChar))
                return;
            const savedIndex = this.index;
            let def;
            let n = 0;
            if (this.match('<{>')) {
                // Supsub with an argument
                [def, n] = this.peekDefinition(opKind);
                if (def) {
                    //
                    // It's a supfix/subfix operator (
                    //  i.e. `^{*}` for `superstar`
                    //
                    if (typeof def.parse === 'function') {
                        result = def.parse(lhs, this, 0)[1];
                    }
                    else {
                        this.index += n;
                        if (this.match('<}>')) {
                            result = [(_a = def.parse) !== null && _a !== void 0 ? _a : def.name, lhs];
                        }
                        else {
                            // Not a supfix/subfix
                            // For example, "^{-1}", start with `"-"` from `superminus`,
                            // but the "1" after it makes it not match
                            this.index = savedIndex;
                        }
                    }
                }
                else {
                    this.index = savedIndex;
                }
            }
            else {
                //
                // Single token argument for a sup/subfix
                //
                [def, n] = this.peekDefinition(opKind);
                if (def) {
                    if (typeof def.parse === 'function') {
                        result = def.parse(lhs, this, 0)[1];
                    }
                    else {
                        this.index += n;
                        result = [(_b = def.parse) !== null && _b !== void 0 ? _b : def.name, lhs];
                    }
                }
                else {
                    this.index = savedIndex;
                }
            }
            if (result === null) {
                def = (_c = this.dictionary.infix[1]) === null || _c === void 0 ? void 0 : _c.get(triggerChar);
                if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
                    this.index = beforeTrigger;
                    result = def.parse(lhs, this, 0)[1];
                }
                else if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'string') {
                    [lhs, result] = this.applyOperator(def.parse, lhs, this.matchRequiredLatexArgument());
                    result = this.applyInvisibleOperator(lhs, result);
                }
                else {
                    result = this.applyInvisibleOperator(lhs, triggerChar);
                }
            }
            if (result !== null) {
                // There could be some arguments following the supsub, e.g.
                // `f^{-1}(x)`
                const args = this.matchArguments(def === null || def === void 0 ? void 0 : def.arguments);
                if (args !== null)
                    result = [result, ...args];
            }
        });
        return result;
    }
    matchPostfix(lhs) {
        if (lhs === null)
            return null;
        const [def, n] = this.peekDefinition('postfix');
        if (def === null || def === undefined)
            return null;
        if (typeof def.parse === 'function') {
            [, lhs] = def.parse(lhs, this, 0);
            if (lhs === null)
                return null;
            return lhs;
        }
        this.index += n;
        return [def.parse, lhs];
    }
    matchString() {
        let result = '';
        let done = this.atEnd;
        while (!done) {
            if (this.match('<space>')) {
                result += ' ';
            }
            else {
                const token = this.peek;
                if (token === ']') {
                    done = true;
                }
                else if (!/^<({|}|\$|\$\$|space)>$/.test(token)) {
                    result += this.next();
                }
                else if (token[0] === '\\') {
                    // TeX will give a 'Missing \endcsname inserted' error
                    // if it encounters any command when expecting a string.
                    // We're a bit more lax.
                    this.onError({ code: 'unexpected-command' });
                    result += this.next();
                }
                else {
                    // It's '<{>', '<}>', '<$>' or '<$$>
                    done = true;
                }
            }
            done = done || this.atEnd;
        }
        return result;
    }
    matchEnvironmentName(command, envName) {
        if (this.match(command)) {
            const savedIndex = this.index;
            if (this.match('<{>')) {
                const name = this.matchString();
                if (this.match('<}>') && name === envName) {
                    return true;
                }
            }
            this.index = savedIndex;
        }
        return false;
    }
    /**
     * Match an expression in a tabular format,
     * where row are separated by `\\` and columns by `&`
     *
     * Return rows of sparse columns as a list: empty rows are indicated with NOTHING,
     * and empty cells are also indicated with NOTHING.
     */
    matchTabular() {
        const result = ['list'];
        let row = ['list'];
        let expr = null;
        let done = false;
        while (!this.atEnd && !done) {
            if (this.match('&')) {
                // new column
                // Push even if expr is NULL (it represents a skipped column)
                row.push(expr !== null && expr !== void 0 ? expr : NOTHING);
                expr = null;
            }
            else if (this.match('\\\\') || this.match('\\cr')) {
                // new row
                this.skipSpace();
                // Parse but drop optional argument (used to indicate spacing between lines)
                this.matchOptionalLatexArgument();
                if (expr !== null)
                    row.push(expr);
                result.push(row);
                row = ['list'];
                expr = null;
            }
            else {
                const rhs = this.matchExpression();
                if (rhs === null)
                    done = true;
                if (expr !== null) {
                    expr = this.applyInvisibleOperator(expr, rhs);
                }
                else {
                    expr = rhs;
                }
            }
        }
        // Capture any leftover row
        if (row.length > 1) {
            result.push(row);
        }
        return result;
    }
    matchEnvironment() {
        var _a;
        if (this.match('\\begin')) {
            if (this.match('<{>')) {
                const name = this.matchString();
                if (this.match('<}>')) {
                    const start = this.index;
                    let end = this.index;
                    // Find the end of the environment
                    let level = 1;
                    while (!this.atEnd && level !== 0) {
                        end = this.index;
                        if (this.matchEnvironmentName('\\begin', name)) {
                            level += 1;
                        }
                        else if (this.matchEnvironmentName('\\end', name)) {
                            level -= 1;
                        }
                        else {
                            this.next();
                        }
                    }
                    const def = this.dictionary.environment.get(name);
                    if (typeof (def === null || def === void 0 ? void 0 : def.parse) === 'function') {
                        return def.parse(null, this.clone(start, end), 0)[1];
                    }
                    return (_a = def === null || def === void 0 ? void 0 : def.parse) !== null && _a !== void 0 ? _a : null;
                }
            }
        }
        return null;
    }
    /**
     * Apply the operator `op` to the left-hand-side and right-hand-side
     * expression. Applies the associativity rule specified by the definition,
     * i.e. 'op(a, op(b, c))` -> `op(a, b, c)`, etc...
     *
     * `op` is the name of the operator which should have a corresponding
     * definition.
     *
     * If `op` is an infix operator, it should have both a lhs and rhs.
     * If `op` is a postfix operator, it should only have a lhs.
     * If `op` is a prefix operator, the lhs is returned as the first element
     * of the return tuple.
     *
     * @return a tuple: [lhs, rhs]
     */
    applyOperator(op, lhs, rhs) {
        var _a, _b, _c, _d;
        const def = this.dictionary.name.get(op);
        if (def === undefined) {
            this.onError({ code: 'unknown-operator' });
            return [lhs, rhs];
        }
        if (((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.prefix) !== undefined && lhs === null && rhs !== null) {
            return [null, [def.name, rhs]];
        }
        if (((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.postfix) !== undefined && lhs !== null) {
            return [null, [def.name, lhs]];
        }
        if (((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.matchfix) !== undefined ||
            ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.infix) !== undefined) {
            // infix
            if (def.associativity === 'non') {
                return [null, [op, lhs !== null && lhs !== void 0 ? lhs : 'Missing', rhs !== null && rhs !== void 0 ? rhs : 'Missing']];
            }
            if (getFunctionName(lhs) === op) {
                // Possible associativity
                if (def.associativity === 'both') {
                    if (getFunctionName(rhs) === op) {
                        // +(+(a, b), +(c, d)) -> +(a, b, c, d)
                        if (Array.isArray(lhs)) {
                            return [null, lhs.concat(getTail(rhs))];
                        }
                        if (isFunctionObject(lhs)) {
                            return [null, lhs.fn.concat(getTail(rhs))];
                        }
                    }
                    else if (rhs) {
                        if (Array.isArray(lhs)) {
                            lhs.push(rhs);
                        }
                        if (isFunctionObject(lhs)) {
                            lhs.fn.push(rhs);
                        }
                    }
                    return [null, lhs];
                }
                if (def.associativity === 'left') {
                    return [null, [op, lhs !== null && lhs !== void 0 ? lhs : MISSING, rhs !== null && rhs !== void 0 ? rhs : MISSING]];
                }
                // Right-associative
                if (Array.isArray(lhs)) {
                    return [null, [op, lhs[1], [op, lhs[2], rhs !== null && rhs !== void 0 ? rhs : MISSING]]];
                }
                if (isFunctionObject(lhs)) {
                    lhs.fn[2] = [op, lhs.fn[2], rhs !== null && rhs !== void 0 ? rhs : MISSING];
                }
                return [null, lhs];
            }
            else if (getFunctionName(rhs) === op) {
                // Possible associativity
                if (def.associativity === 'both') {
                    if (Array.isArray(rhs) && lhs) {
                        rhs.splice(1, 0, lhs);
                    }
                    if (isFunctionObject(rhs) && lhs) {
                        rhs.fn.splice(1, 0, lhs);
                    }
                    return [null, rhs];
                }
                if (def.associativity === 'right') {
                    return [null, [op, lhs !== null && lhs !== void 0 ? lhs : MISSING, rhs !== null && rhs !== void 0 ? rhs : MISSING]];
                }
                // Left-associative
                if (Array.isArray(rhs)) {
                    return [null, [op, rhs[1], [op, rhs[2], lhs !== null && lhs !== void 0 ? lhs : MISSING]]];
                }
                if (isFunctionObject(rhs)) {
                    rhs.fn[2] = [op, rhs.fn[2], lhs !== null && lhs !== void 0 ? lhs : MISSING];
                }
                return [null, rhs];
            }
            return [null, [op, lhs !== null && lhs !== void 0 ? lhs : 'Missing', rhs !== null && rhs !== void 0 ? rhs : 'Missing']];
        }
        return [lhs, null];
    }
    /**
     * Apply an invisible operator between two expressions.
     *
     * If no `invisibleOperator` was specified, use the `latex` operator.
     *
     * If the lhs is a number and the rhs is a fraction of integers,
     * assume an 'invisible plus', that is '2 3/4' -> ['add', 2, [divide, 3, 4]]
     * unless `invisiblePlusOperator` is empty
     *
     */
    applyInvisibleOperator(lhs, rhs) {
        if (lhs === null)
            return rhs;
        if (rhs === null)
            return lhs;
        // @todo: handle invisible plus
        if (this.options.invisiblePlusOperator) {
            if ((typeof lhs === 'number' || isNumberObject(lhs)) &&
                isRationalNumber(rhs)) {
                [lhs, rhs] = this.applyOperator(this.options.invisiblePlusOperator, lhs, rhs);
                if (lhs === null)
                    return rhs;
                return null;
            }
        }
        if (this.options.invisibleOperator) {
            [lhs, rhs] = this.applyOperator(this.options.invisibleOperator, lhs, rhs);
            if (lhs === null)
                return rhs;
            return null;
        }
        // No invisible operator, use 'Latex'
        let fn = [LATEX_TOKENS];
        if (getFunctionName(lhs) === LATEX_TOKENS) {
            fn = fn.concat(getTail(lhs));
        }
        else {
            fn.push(lhs);
        }
        if (rhs !== null) {
            if (getFunctionName(rhs) === LATEX_TOKENS) {
                fn = fn.concat(getTail(rhs));
            }
            else {
                fn.push(rhs);
            }
        }
        if (this.options.invisibleOperator) {
            this.onError({ code: 'unexpected-sequence' });
        }
        return fn;
    }
    matchUnknownLatexCommand() {
        var _a;
        const command = this.peek;
        if (!command || command[0] !== '\\') {
            return null;
        }
        this.next();
        if (command === '\\operatorname') {
            this.skipSpace();
            if (this.peek === '<{>') {
                let result = '';
                this.next();
                while (!this.atEnd && this.tokens[this.index] !== '<}>') {
                    result += this.next();
                }
                return result;
            }
            return (_a = this.next()) !== null && _a !== void 0 ? _a : MISSING;
        }
        const optArgs = [];
        const reqArgs = [];
        let done = false;
        do {
            done = true;
            let expr = this.matchOptionalLatexArgument();
            if (expr !== null) {
                optArgs.push(expr);
                done = false;
            }
            this.skipSpace();
            if (this.peek === '<{>') {
                expr = this.matchRequiredLatexArgument();
                if (expr !== null) {
                    reqArgs.push(expr);
                    done = false;
                }
            }
        } while (!done);
        if (optArgs.length > 0 || reqArgs.length > 0) {
            return [command, ...reqArgs, ...optArgs];
        }
        return command;
    }
    /**
     * <primary> :=
     * (<number> | <symbol> | <environment> | <matchfix-expr>) <subsup>* <postfix-operator>*
     *
     * <symbol> ::= (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
     *
     * <matchfix-expr> :=
     *  <matchfix-op-open> <expression> [<matchfix-op-separator> <expression>] <matchfix-op-close>
     *
     */
    matchPrimary(_minPrec) {
        let result = null;
        const originalIndex = this.index;
        //
        // 1. Is it a number?
        //
        const num = this.matchNumber();
        if (num)
            result = { num: num };
        //
        // 2. Is it a matchfix expression?
        //    (group fence, absolute value, integral, etc...)
        // (check before other latex commands)
        //
        if (result === null)
            result = this.matchMatchfixOperator();
        //
        // 3. Is it an environment?
        // `\begin{...}...\end{...}`
        // (check before other latex commands)
        //
        if (result === null)
            result = this.matchEnvironment();
        //
        // 4. Is it a symbol, a Latex command or a function call?
        //    `x` or `\pi'
        //    `f(x)` or `\sin(\pi)
        //    `\frac{1}{2}`
        //
        if (result === null)
            result = this.matchSymbol();
        //
        // 5. Are there subsup or postfix operators?
        //
        let supsub = null;
        do {
            supsub = this.matchSupsub(result);
            result = supsub !== null && supsub !== void 0 ? supsub : result;
        } while (supsub !== null);
        let postfix = null;
        do {
            postfix = this.matchPostfix(result);
            result = postfix !== null && postfix !== void 0 ? postfix : result;
        } while (postfix !== null);
        return this.decorate(result, originalIndex);
    }
    matchBalancedExpression(open, close, onError) {
        const scanner = this.balancedClone(open, close);
        if (!scanner) {
            // eslint-disable-next-line no-unused-expressions
            onError === null || onError === void 0 ? void 0 : onError({
                code: 'unbalanced-symbols',
                arg: tokensToString(open) + tokensToString(close),
            });
            return null;
        }
        const result = scanner.matchExpression();
        if (!scanner.atEnd) {
            // eslint-disable-next-line no-unused-expressions
            onError === null || onError === void 0 ? void 0 : onError({
                code: 'unbalanced-symbols',
                arg: tokensToString(open) + tokensToString(close),
            });
        }
        return result;
    }
    /**
     *  Parse an expression:
     *
     * <expression> ::=
     *  | <primary>
     *  | <prefix-op> <primary>
     *  | <primary> <infix-op> <expression>
     *
     * Stop when an operator of precedence less than `minPrec` is encountered
     */
    matchExpression(minPrec = 0) {
        let lhs = null;
        const originalIndex = this.index;
        this.skipSpace();
        //
        // 1. Do we have a primary?
        // (we check first to capture "-1" as a negative number, and not as a prefix
        // operator applied to a number).
        //
        lhs = this.matchPrimary(minPrec);
        //
        // 2. Do we have a prefix operator?
        //
        if (lhs === null)
            lhs = this.matchOperator('prefix');
        //
        // 3. Are there some infix operators?
        //
        let done = false;
        while (!this.atEnd && !done) {
            this.skipSpace();
            let result = this.matchOperator('infix', lhs, minPrec);
            if (result === null && lhs !== null) {
                // We've encountered something else than an infix operator
                // OR an infix operator with a lower priority.
                // Could be "y" after "x": time to apply the invisible operator
                // if the next element is:
                // - a symbol: `2x`, `2f(x)` (after `2`)
                // - a number: `x2` (after `x`)
                // - a matchfix open: `x(n+1)` (after `x`)
                // (i.e. not an operator)
                const [op] = this.peekDefinition('operator');
                if (op === null) {
                    const rhs = this.matchExpression(this.invisibleOperatorPrecedence);
                    if (rhs !== null) {
                        result = this.applyInvisibleOperator(lhs, rhs);
                    }
                }
            }
            if (result !== null) {
                lhs = result;
            }
            else {
                // We could not apply the infix operator: the rhs may
                // have been a postfix operator, or something else
                done = true;
            }
        }
        return this.decorate(lhs, originalIndex);
    }
    /**
     * Add latex or other requested metadata to the expression
     */
    decorate(expr, start) {
        if (expr === null)
            return null;
        if (this.options.preserveLatex) {
            const latex = this.latex(start, this.index);
            if (Array.isArray(expr)) {
                expr = { latex, fn: expr };
            }
            else if (typeof expr === 'number') {
                expr = { latex, num: Number(expr).toString() };
            }
            else if (typeof expr === 'string') {
                expr = { latex, sym: expr };
            }
            else if (typeof expr === 'object' && expr !== null) {
                expr.latex = latex;
            }
        }
        return expr;
    }
}

// Some vocabulary:
// 123.456e78
// - 123.456 = significand
// - 123 = wholePart
// - 456 = fractionalPart
// - 79 = exponent
//
// Avoid using mantissa which has several definitions and is ambiguous.
/**
 * Return a formatted fractional part by detecting repeating patterns.
 * 1234567 -> 123 456 7...
 * 1233333 -> 12(3)
 */
function formatFractionalPart(m, options) {
    const originalLength = m.length;
    const originalM = m;
    // The last digit may have been rounded off, if it exceeds the precision,
    // which could throw off the repeating pattern detection. Ignore it.
    m = m.slice(0, -1);
    for (let i = 0; i < m.length - 16; i++) {
        // Offset is the part of the fractional part that is not repeating
        const offset = m.substr(0, i);
        // Try to find a repeating pattern of length j
        for (let j = 0; j < 17; j++) {
            const cycle = m.substr(i, j + 1);
            const times = Math.floor((m.length - offset.length) / cycle.length);
            if (times > 1) {
                if ((offset + cycle.repeat(times + 1)).startsWith(m)) {
                    // We've found a repeating pattern!
                    if (cycle === '0') {
                        // Psych! That pattern is '0'...
                        return offset.replace(/(\d{3})/g, '$1' + options.groupSeparator);
                    }
                    // There is what looks like a true repeating pattern...
                    return (offset.replace(/(\d{3})/g, '$1' + options.groupSeparator) +
                        options.beginRepeatingDigits +
                        cycle +
                        // cycle.replace(/(\d{3})/g, '$1' + options.groupSeparator) +
                        options.endRepeatingDigits);
                }
            }
        }
    }
    // There was no repeating pattern we could find...
    // Are we displaying fewer digits than were provided?
    // Display a truncation marker.
    const extraDigits = originalLength > options.precision - 1;
    m = originalM;
    if (extraDigits) {
        m = m.substr(0, options.precision - 1);
    }
    // Insert group separators if necessary
    if (options.groupSeparator) {
        m = m.replace(/(\d{3})/g, '$1' + options.groupSeparator);
        if (m.endsWith(options.groupSeparator)) {
            m = m.slice(0, -options.groupSeparator.length);
        }
    }
    if (extraDigits)
        return m + options.truncationMarker;
    return m;
}
function formatExponent(exp, options) {
    var _a;
    if (!exp)
        return '';
    if (options.beginExponentMarker) {
        return (options.beginExponentMarker + exp + ((_a = options.endExponentMarker) !== null && _a !== void 0 ? _a : ''));
    }
    return '10^{' + exp + '}';
}
/*
 * @param expr - A number, can be represented as a string
 *  particularly useful for arbitrary precision numbers) or a number (-12.45)
 * @return A textural representation of the number, formatted according to the
 * `options`
 */
function serializeNumber(expr, options) {
    var _a, _b;
    let num;
    if (typeof expr === 'number') {
        num = expr;
    }
    else if (isNumberObject(expr)) {
        num = expr.num;
    }
    else {
        return '';
    }
    if (num === Infinity || num === 'Infinity' || num === '+Infinity') {
        return options.positiveInfinity;
    }
    else if (num === -Infinity || num === '-Infinity') {
        return options.negativeInfinity;
    }
    else if (num === 'NaN' || (typeof num === 'number' && Number.isNaN(num))) {
        return options.notANumber;
    }
    if (typeof num === 'number') {
        if (options.notation === 'engineering') {
            return serializeEngineeringNotationNumber(num, options);
        }
        return serializeAutoNotationNumber(num.toString(), options);
    }
    // If we end with a letter ('n' or 'd' for bigint or decimal)
    // remove it.
    if (/[a-zA-Z]$/.test(num))
        num = num.slice(0, -1);
    let sign = '';
    if (num[0] === '-') {
        sign = '-';
        num = num.substr(1);
    }
    else if (num[0] === '+') {
        num = num.substr(1);
    }
    // Remove any leading zeros
    while (num[0] === '0') {
        num = num.substr(1);
    }
    if (num.length === 0)
        return sign + '0';
    if (num[0] === '.')
        num = '0' + num;
    let exponent = '';
    if (num.indexOf('.') >= 0) {
        const m = num.match(/(\d*)\.(\d*)([e|E]([-+]?[0-9]*))?/);
        if (!m)
            return '';
        const base = m[1];
        const fractionalPart = m[2];
        exponent = (_a = m[4]) !== null && _a !== void 0 ? _a : '';
        if (base === '0') {
            let p = 0; // Index of the first non-zero digit after the decimal
            while (fractionalPart[p] === '0' && p < fractionalPart.length) {
                p += 1;
            }
            let r = '';
            if (p <= 4) {
                r = '0' + options.decimalMarker;
                r += fractionalPart.substr(0, p);
                r += formatFractionalPart(num.substr(r.length), options);
            }
            else if (p + 1 >= options.precision) {
                r = '0';
                sign = '';
            }
            else {
                r = num[p];
                const f = formatFractionalPart(num.substr(p + 1), options);
                if (f) {
                    r += options.decimalMarker + f;
                }
            }
            if (r !== '0') {
                if (num.length - 1 > options.precision &&
                    !(options.endRepeatingDigits && r.endsWith(options.endRepeatingDigits)) &&
                    options.truncationMarker &&
                    !r.endsWith(options.truncationMarker)) {
                    r += options.truncationMarker;
                }
                if (p > 4) {
                    r +=
                        options.exponentProduct +
                            formatExponent((1 - p).toString(), options);
                }
            }
            num = r;
        }
        else {
            num = base.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
            const f = formatFractionalPart(fractionalPart, options);
            if (f) {
                num += options.decimalMarker + f;
                // if (num.length - 1 > config.precision && !num.endsWith('}') && !num.endsWith('\\ldots')) {
                //     num += '\\ldots';
                // }
            }
        }
    }
    else if (num.length > options.precision) {
        const len = num.length;
        let r = num[0];
        const f = formatFractionalPart(num.substr(1), options);
        if (f) {
            r += options.decimalMarker + f;
            if (options.truncationMarker && !r.endsWith(options.truncationMarker)) {
                if (options.endRepeatingDigits &&
                    !r.endsWith(options.endRepeatingDigits)) {
                    r += options.truncationMarker;
                }
            }
        }
        if (r !== '1') {
            r += options.exponentProduct;
        }
        else {
            r = '';
        }
        num = r + formatExponent((len - 1).toString(), options);
    }
    else {
        const m = num.match(/([0-9]*)\.?([0-9]*)([e|E]([-+]?[0-9]+))?/);
        if (m) {
            num = m[1];
            if (m[2])
                num += options.decimalMarker + m[2];
            exponent = (_b = m[4]) !== null && _b !== void 0 ? _b : '';
        }
        num = num.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
    }
    const exponentString = formatExponent(exponent, options);
    return (sign +
        num +
        (exponentString ? options.exponentProduct + exponentString : ''));
}
function serializeEngineeringNotationNumber(value, options) {
    if (value === 0)
        return '0';
    // Ensure the exponent is a multiple of 3
    const y = Math.abs(value);
    let exponent = Math.round(Math.log10(y));
    exponent = exponent - (exponent % 3);
    if (y < 1000)
        exponent = 0;
    const significand = y / Math.pow(10, exponent);
    let significandString = '';
    const m = significand.toString().match(/^(.*)\.(.*)$/);
    if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
        significandString = m[1] + options.decimalMarker + m[2];
    }
    if (options.groupSeparator) {
        significandString = formatFractionalPart(significand.toExponential(), options);
    }
    let exponentString = '';
    if (exponent !== 0) {
        exponentString = formatExponent(exponent.toString(), options);
    }
    return (value < 0 ? '-' : '') + significandString + exponentString;
}
function serializeAutoNotationNumber(valString, options) {
    let m = valString.match(/^(.*)[e|E]([-+]?[0-9]+)$/i);
    let exponent = undefined;
    // if valString === '-1234567.89e-123'
    // m[1] = '-1234567.89'
    // m[2] = -123
    if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
        // There is an exponent...
        exponent = formatExponent(m[2], options);
        if (exponent) {
            exponent = options.exponentProduct + exponent;
        }
    }
    let wholePart = valString;
    let fractionalPart = '';
    m = (exponent ? m[1] : valString).match(/^(.*)\.(.*)$/);
    if ((m === null || m === void 0 ? void 0 : m[1]) && m[2]) {
        wholePart = m[1];
        fractionalPart = m[2];
    }
    if (options.groupSeparator) {
        wholePart = wholePart.replace(/\B(?=(\d{3})+(?!\d))/g, options.groupSeparator);
        fractionalPart = formatFractionalPart(fractionalPart, options);
    }
    if (fractionalPart)
        fractionalPart = options.decimalMarker + fractionalPart;
    return wholePart + fractionalPart + (exponent !== null && exponent !== void 0 ? exponent : '');
}

function getSymbolStyle(expr, _level) {
    console.assert(typeof expr === 'string' || isSymbolObject(expr));
    const sym = getSymbolName(expr);
    if (sym === null)
        return 'asis';
    return sym.length > 1 ? 'upright' : 'asis';
}
function serializeMatchfix(serializer, expr, def) {
    var _a, _b;
    let segments = [];
    if (typeof ((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.matchfix) === 'string') {
        segments.push((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.matchfix);
    }
    else if (def.trigger && Array.isArray(def.trigger.matchfix)) {
        segments = [...def.trigger.matchfix];
    }
    if (getArgCount(expr) >= 1) {
        let sep = '';
        for (const arg of getTail(expr)) {
            if (arg) {
                segments.push(sep);
                segments.push(serializer.serialize(arg));
                sep = def.separator;
            }
        }
    }
    segments.push(tokensToString(def.closeFence));
    return joinLatex(segments);
}
function serializeOperator(serializer, expr, def) {
    var _a, _b, _c, _d, _e;
    let result = '';
    const count = getArgCount(expr);
    const name = getFunctionName(expr);
    if (((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.superfix) || ((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.subfix)) {
        if (count !== 1) {
            serializer.onError({
                code: 'operator-requires-one-operand',
                arg: serializer.serializeSymbol(name),
            });
        }
        return replaceLatex(def.serialize, [
            serializer.serialize(getArg(expr, 1)),
        ]);
    }
    if ((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.postfix) {
        if (count !== 1) {
            serializer.onError({
                code: 'postfix-operator-requires-one-operand',
                arg: serializer.serializeSymbol(name),
            });
        }
        return replaceLatex(def.serialize, [
            serializer.wrap(getArg(expr, 1), def.precedence),
        ]);
    }
    if ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.prefix) {
        if (count !== 1) {
            serializer.onError({
                code: 'prefix-operator-requires-one-operand',
                arg: serializer.serializeSymbol(name),
            });
        }
        return replaceLatex(def.serialize, [
            serializer.wrap(getArg(expr, 1), def.precedence + 1),
        ]);
    }
    if ((_e = def.trigger) === null || _e === void 0 ? void 0 : _e.infix) {
        result = serializer.wrap(getArg(expr, 1), def.precedence);
        for (let i = 2; i < count + 1; i++) {
            const arg = getArg(expr, i);
            if (arg !== null) {
                result = replaceLatex(def.serialize, [
                    result,
                    serializer.wrap(arg, def.precedence),
                ]);
            }
        }
    }
    return result;
}
class Serializer {
    constructor(options, dictionary, onError) {
        this.level = -1;
        this.options = options;
        if (options.invisibleMultiply) {
            if (!/#1/.test(options.invisibleMultiply) ||
                !/#2/.test(options.invisibleMultiply)) {
                onError({
                    code: 'expected-argument',
                    arg: 'invisibleMultiply',
                });
            }
        }
        this.onError = onError;
        this.dictionary = dictionary;
    }
    /**
     * Serialize the expression, and if the expression is an operator
     * of precedence less than or equal to prec, wrap it in some paren.
     * @todo: don't wrap abs
     */
    wrap(expr, prec) {
        if (expr === null)
            return '';
        if (prec === undefined) {
            return '(' + this.serialize(expr) + ')';
        }
        if (typeof expr === 'number' ||
            isNumberObject(expr) ||
            typeof expr === 'string' ||
            isSymbolObject(expr)) {
            return this.serialize(expr);
        }
        const name = getFunctionName(expr);
        if (name && name !== PARENTHESES) {
            const def = this.dictionary.name.get(name);
            if (def && def.precedence !== undefined && def.precedence < prec) {
                return this.wrapString(this.serialize(expr), getApplyFunctionStyle(expr, this.level));
            }
        }
        return this.serialize(expr);
    }
    /** If this is a "short" expression (atomic), wrap it.
     *
     */
    wrapShort(expr) {
        if (expr === null)
            return '';
        const exprStr = this.serialize(expr);
        if (getFunctionName(expr) === PARENTHESES)
            return exprStr;
        if (typeof expr !== 'number' &&
            !isNumberObject(expr) &&
            !/(^(.|\\[a-zA-Z*]+))$/.test(exprStr)) {
            // It's a long expression, wrap it
            return this.wrapString(exprStr, getGroupStyle(expr, this.level + 1));
        }
        return exprStr;
    }
    wrapString(s, style) {
        if (style === 'none')
            return s;
        return '(' + s + ')';
    }
    serializeSymbol(expr, def) {
        const head = getFunctionHead(expr);
        if (!head) {
            console.assert(typeof expr === 'string' || isSymbolObject(expr));
            // It's a symbol
            if (typeof (def === null || def === void 0 ? void 0 : def.serialize) === 'string') {
                return def.serialize;
            }
            const name = getSymbolName(expr);
            if (name === null)
                return '';
            switch (getSymbolStyle(expr, this.level)) {
                case 'upright':
                    return '\\operatorname{' + name + '}';
                //            case 'asis':
                default:
                    return name;
            }
        }
        //
        // It's a function
        //
        const args = getTail(expr);
        if (!def) {
            // We don't know anything about this function
            if (typeof head === 'string' && head.length > 0 && head[0] === '\\') {
                //
                // 1. Is is an unknown latex command?
                //
                // This looks like a Latex command. Serialize
                // the arguments as Latex arguments
                let result = head;
                for (const arg of args) {
                    result += '{' + this.serialize(arg) + '}';
                }
                return result;
            }
            //
            // 2. Is it an unknown function call?
            //
            // It's a function we don't know.
            // Maybe it came from `promoteUnknownSymbols`
            // Serialize the arguments as function arguments
            return `${this.serialize(head)}(${args
                .map((x) => this.serialize(x))
                .join(', ')})`;
            // return `\\operatorname{Apply}(${this.serialize(head)}, ${this.serialize([
            //   'List',
            //   ...args,
            // ])})`;
        }
        if (def.requiredLatexArg > 0) {
            //
            // 3. Is it a known Latex command?
            //
            // This looks like a Latex command. Serialize the arguments as Latex
            // arguments
            let optionalArg = '';
            let requiredArg = '';
            let i = 0;
            while (i < def.requiredLatexArg) {
                requiredArg += '{' + this.serialize(args[i++]) + '}';
            }
            while (i < Math.min(args.length, def.optionalLatexArg + def.requiredLatexArg)) {
                const optValue = this.serialize(args[1 + i++]);
                if (optValue) {
                    optionalArg += '[' + optValue + ']';
                }
            }
            return def.serialize + (optionalArg + requiredArg);
        }
        //
        // 4. Is it a known function?
        //
        getApplyFunctionStyle(expr, this.level);
        return def.serialize + this.serialize([PARENTHESES, ...args]);
    }
    serializeDictionary(dict) {
        return `\\left[\\begin{array}{lll}${Object.keys(dict)
            .map((x) => {
            return `\\textbf{${x}} & \\rightarrow & ${this.serialize(dict[x])}`;
        })
            .join('\\\\')}\\end{array}\\right]`;
    }
    serialize(expr) {
        if (expr === null)
            return '';
        this.level += 1;
        const result = (() => {
            var _a, _b, _c, _d;
            //
            // 1. Is it a number
            //
            const numericValue = serializeNumber(expr, this.options);
            if (numericValue)
                return numericValue;
            //
            // 2. Is it a string?
            //
            const stringValue = getStringValue(expr);
            if (stringValue !== null)
                return `\\text{${stringValue}}`;
            //
            // 3. Is it a symbol?
            //
            const symbolName = getSymbolName(expr);
            if (symbolName !== null) {
                return this.serializeSymbol(expr, this.dictionary.name.get(symbolName));
            }
            //
            // 4. Is it a dictionary?
            //
            const dict = getDictionary(expr);
            if (dict !== null)
                return this.serializeDictionary(dict);
            //
            // 5. Is it a named function?
            //
            const fnName = getFunctionName(expr);
            if (fnName) {
                if (fnName[0] === '\\') {
                    // 5.1 An unknown Latex command, possibly with arguments.
                    // This can happen if we encountered an unrecognized Latex command
                    // during parsing, e.g. "\foo{x + 1}"
                    const args = getTail(expr);
                    if (args.length === 0)
                        return fnName;
                    return (fnName +
                        '{' +
                        args
                            .map((x) => this.serialize(x))
                            .filter((x) => Boolean(x))
                            .join('}{') +
                        '}');
                }
                //
                // 5.2 A function, operator or matchfix operator
                //
                const def = this.dictionary.name.get(fnName);
                if (def) {
                    let result = '';
                    // If there is a custom serializer function, use it.
                    if (typeof def.serialize === 'function') {
                        result = def.serialize(this, expr);
                    }
                    if (!result &&
                        (def.precedence !== undefined ||
                            ((_a = def.trigger) === null || _a === void 0 ? void 0 : _a.superfix) ||
                            ((_b = def.trigger) === null || _b === void 0 ? void 0 : _b.subfix))) {
                        result = serializeOperator(this, expr, def);
                    }
                    if (!result && ((_c = def.trigger) === null || _c === void 0 ? void 0 : _c.matchfix)) {
                        result = serializeMatchfix(this, expr, def);
                    }
                    if (!result && ((_d = def.trigger) === null || _d === void 0 ? void 0 : _d.symbol)) {
                        result = this.serializeSymbol(expr, def);
                    }
                    return result;
                }
            }
            if (Array.isArray(expr) || isFunctionObject(expr)) {
                // It's a function, but without definition.
                // It could be a [['derive', "f"], x]
                // serializeSymbol() will take care of it.
                return this.serializeSymbol(expr);
            }
            // This doesn't look like a symbol, or a function,
            // or anything we were expecting.
            // This is an invalid expression, for example an
            // object literal with no known fields, or an invalid number:
            // `{num: 'not a number'}`
            // `{foo: 'not an expression}`
            this.onError({
                code: 'syntax-error',
                arg: JSON.stringify(expr),
            });
        })();
        this.level -= 1;
        return result !== null && result !== void 0 ? result : '';
    }
}

class LatexSyntax {
    constructor(options) {
        var _a, _b;
        const onError = (err) => {
            if (typeof window !== 'undefined') {
                if (!err.before || !err.after) {
                    console.warn(err.code + (err.arg ? ': ' + err.arg : ''));
                }
                else {
                    console.warn(err.code +
                        (err.arg ? ': ' + err.arg : '') +
                        '\n' +
                        '%c' +
                        '|  ' +
                        err.before +
                        '%c' +
                        err.after +
                        '\n' +
                        '%c' +
                        '|  ' +
                        String(' ').repeat(err.before.length) +
                        '▲', 'font-weight: bold', 'font-weight: normal; color: rgba(160, 160, 160)', 'font-weight: bold; color: hsl(4deg, 90%, 50%)');
                }
            }
            return;
        };
        this.onError = (_a = options === null || options === void 0 ? void 0 : options.onError) !== null && _a !== void 0 ? _a : onError;
        const opts = { ...(options !== null && options !== void 0 ? options : {}) };
        delete opts.dictionary;
        delete opts.onError;
        this.options = {
            ...DEFAULT_LATEX_NUMBER_OPTIONS,
            ...DEFAULT_SERIALIZE_LATEX_OPTIONS,
            ...DEFAULT_PARSE_LATEX_OPTIONS,
            ...opts,
        };
        this.dictionary = indexLatexDictionary((_b = options === null || options === void 0 ? void 0 : options.dictionary) !== null && _b !== void 0 ? _b : LatexSyntax.getDictionary(), this.onError);
    }
    static getDictionary(domain = 'all') {
        if (domain === 'all') {
            let result = [];
            for (const domain of Object.keys(DEFAULT_LATEX_DICTIONARY)) {
                result = [...result, ...DEFAULT_LATEX_DICTIONARY[domain]];
            }
            return result;
        }
        if (!DEFAULT_LATEX_DICTIONARY[domain])
            return [];
        return [...DEFAULT_LATEX_DICTIONARY[domain]];
    }
    parse(latex) {
        var _a;
        const scanner = new Scanner(tokenize(latex, []), this.options, this.dictionary, this.onError);
        const result = scanner.matchExpression();
        if (!scanner.atEnd) {
            // eslint-disable-next-line no-unused-expressions
            (_a = this.onError) === null || _a === void 0 ? void 0 : _a.call(this, { code: 'syntax-error' });
        }
        return result !== null && result !== void 0 ? result : '';
    }
    serialize(expr) {
        const serializer = new Serializer(this.options, this.dictionary, this.onError);
        return serializer.serialize(expr);
    }
}
function parse(latex, options) {
    const syntax = new LatexSyntax(options);
    return syntax.parse(latex);
}
/**
 * Serialize a MathJSON expression as a Latex string.
 *
 */
function serialize(expr, options) {
    const syntax = new LatexSyntax(options);
    return syntax.serialize(expr);
}

// This is the root of the `math-json` package (i.e.  `math-json.js` and
const version = '0.4.2';

export { LatexSyntax, parse, serialize, version };
