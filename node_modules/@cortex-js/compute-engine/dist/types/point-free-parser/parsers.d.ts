/* 0.4.2 */export declare type DiagnosticCode = 'binary-number-expected' | 'closing-bracket-expected' | 'decimal-number-expected' | 'eof-expected' | 'empty-verbatim-symbol' | 'end-of-comment-expected' | 'exponent-expected' | 'expression-expected' | 'hexadecimal-number-expected' | 'invalid-symbol-name' | 'invalid-escape-sequence' | 'invalid-unicode-codepoint-string' | 'invalid-unicode-codepoint-value' | 'literal-expected' | 'multiline-string-expected' | 'multiline-whitespace-expected' | 'opening-bracket-expected' | 'primary-expected' | 'string-literal-opening-delimiter-expected' | 'string-literal-closing-delimiter-expected' | 'symbol-expected' | 'unbalanced-verbatim-symbol' | 'unexpected-symbol';
export declare type DiagnosticMessage = DiagnosticCode | [DiagnosticCode, ...any];
/**
 * The parser will attempt to continue parsing even when an error is
 * encountered.
 *
 * However, in the rare cases where parsing cannot proceed, this
 * error will be thrown.
 *
 * This would happen if a `#error` directive is encountered.
 */
export declare class FatalParsingError extends Error {
    constructor(msg: string);
}
export declare type Fixit = [start: number, end: number, value: string];
export declare type ParsingDiagnostic = {
    severity: 'warning' | 'error';
    message: DiagnosticMessage;
    range: [start: number, end: number, position?: number];
    fixits?: Fixit[];
};
export interface Rules {
    parse<T = any>(name: string, parser: Parser | string, url?: string): Result<T>;
    has(name: string): boolean;
}
export declare type Combinator<T = any> = [
    label: string,
    parser: (parser: Parser) => Result<T>
];
/**
 * The `Parser` keeps track of what we are parsing (the source) and what we have
 * parsed so far (the offset).
 */
export declare class Parser {
    private rules;
    readonly url: string;
    readonly source: string;
    protected _offset: number;
    length: number;
    private _trace;
    constructor(rules: Rules, source: string, url: string);
    get(offset: number): number;
    atEnd(): boolean;
    atLinebreak(): boolean;
    atString(s: string): boolean;
    slice(start: number, end?: number): string;
    get offset(): number;
    trace(rule: string | Combinator | ((parser: Parser) => Result)): string[];
    skipTo(offset: number): Parser;
    fatalError(msg: string): void;
    hasRule(rule: string): boolean;
    parse<T>(rule: string | Combinator<T> | ((parser: Parser) => Result<T>), fromOffset?: number): Result<T>;
    parseWhitespace(): Result<boolean>;
    ignore(): Result;
    failure(): Result;
}
/**
 * The result of applying a parsing rule:
 * - `Ignore`: the rule matched and the result can be ignored
 * - `Failure`: the rule did not match at all. Maybe try something else?
 * - `Success`: the rule matched and generated a value that can be passed on.
 * - `Error`: the rule matched, then something went wrong. Probably a
 * syntax error. It still produced a value so the parsing can attempt to
 * recover and continue (Panic Mode).
 */
export declare class Result<IR = any> {
    readonly _parser: Parser;
    _value: undefined | null | IR;
    _diagnostics?: ParsingDiagnostic[];
    _range: [start: number, end: number];
    constructor(parser: Parser);
    copyDiagnostics(from: Result<any>): void;
    get parser(): Parser;
    get diagnostics(): ParsingDiagnostic[];
    get isFailure(): boolean;
    get isEmpty(): boolean;
    get isSuccess(): boolean;
    get isError(): boolean;
    get start(): number;
    get end(): number;
    set end(val: number);
    set range(val: [start: number, end: number]);
    get value(): IR | undefined | null;
    set value(val: IR | undefined | null);
    /**
     * Use when a portion of the source has been successfully parsed.
     */
    success(val: IR): Result<IR>;
    /**
     * A `failure` indicates a failed attempt to parse, with no presumption
     * of success, for example when exploring multiple alternatives.
     *
     * `state` indicate where to restart parsing from.
     *
     * The `error` includes the origin (offset) of the failure. It could be after
     * the `state`.
     *
     */
    failure(): Result;
    /**
     * An `ignore` result indicates success in parsing, but with a result that
     * can be ignored.
     *
     * This is useful for whitespace, keywords, braces and other similar syntactic
     * constructs.
     *
     * `next` is the offset from which parsing can continue.
     * `start` is the offset in the source where the element was first ignored.
     *
     */
    ignore(): Result;
    ignoreUntil(offset: number): Result;
    /**
     * An `error` is used when an unexpected failure was encountered.
     * It typically indicates a syntax error.
     *
     * Nonetheless, an attempt is made to recover.
     *
     * The range indicate the portion of the source covered by this result.
     * The optional `pos` indicate where the error occurred. It's the `end`
     * by default.
     *
     */
    error(value: IR, msg: DiagnosticMessage | ((Parser: any) => DiagnosticMessage), fixits?: Fixit[]): Result<IR>;
    errorAt(value: IR | null, msg: DiagnosticMessage | ((Parser: any) => DiagnosticMessage), pos: number, fixits?: Fixit[]): Result<IR>;
    errorFrom(result: Result, value: IR): Result<IR>;
    warning(msg: DiagnosticMessage, fixits?: Fixit[]): Result;
}
export declare function skipUntil(parser: Parser, value: number): number;
export declare function skipUntilString(parser: Parser, pattern: string): number;
