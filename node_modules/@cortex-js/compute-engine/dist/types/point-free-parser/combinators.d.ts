/* 0.4.2 */import { Result, Combinator } from './parsers';
/**
 * An element bracketed by open and close delimiters.
 *
 */
export declare function between<IR>(open: string, something: string | Combinator<IR>, close: string): Combinator<IR>;
export declare function manySeparatedBetween<IR>(open: string, something: string | Combinator<IR>, separator: string, close: string, f: (values: Result<IR>[]) => IR): Combinator<IR>;
/**
 * 0 or more elements, separated and bracketed with open and close delimiters
 * */
export declare function someSeparatedBetween<IR>(open: string, something: string | Combinator<IR>, separator: string, close: string, f: (values: (IR | undefined | null)[]) => IR): Combinator<IR>;
/**
 * Combinator for a table of operators.
 * Each operator has a precedence, and can be either a prefix,
 * suffix, left-associating infix, or right-association infix.
 *
 * Prefix and suffix have no whitespace between the operator and its term.
 *
 * Infix have either whitespace on both sides *or* no whitespace.
 *
 * This requirement is necessary to parse multi-line statements without
 * requiring statement separators.
 *
 */
export declare type OpRecord<U> = [
    data: U,
    op: string,
    prec: number,
    assoc?: 'prefix' | 'suffix' | 'left' | 'right'
];
export declare type OpsTable<U> = OpRecord<U>[];
/**
 * Return the ops sorted by length of the symbol so that,
 * e.g. '<<-' is before '<-'
 */
/**
 * A sequence of prefix, infix and suffix operators with `term`
 * operands.
 *
 * The `f` mapping function is called according to the specified
 * precedence info in the `OpsTable`
 */
export declare function operatorSequence<IR, U>(ops: OpsTable<U>, term: string | Combinator<IR>, f: (op: U, lhs?: IR, rhs?: IR) => IR): Combinator<IR>;
/**
 * Parse a prefix operator
 */
