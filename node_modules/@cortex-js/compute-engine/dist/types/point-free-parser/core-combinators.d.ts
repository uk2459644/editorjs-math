/* 0.4.2 */import { Combinator, Parser, DiagnosticMessage, Result } from './parsers';
export declare function normalize<IR>(c: string | Combinator | ((parser: Parser) => Result<IR>)): string | ((parser: Parser) => Result<IR>);
export declare function description(c: string | Combinator): string;
export declare function parseCodepoint(parser: Parser, value: number): Result<string>;
export declare function codepoint(value: number): Combinator<string>;
/**
 * Apply a function to one or more results.
 *
 * Similar to an _action_ with YACC/Bison.
 *
 * Compute the semantic value of the whole construct from the semantic
 * values of its parts.
 */
/**
 *
 * Combine one or more results into a single result using the `f()` function.
 *
 * Keep all the diagnostics (if any of the results has an error, the overall
 * result is an error).
 * If there are no results, the result is empty (not a failure).
 */
export declare function combine<T>(parser: Parser, f: (...results: Result[]) => T, results: Result[], errors?: Result[], msg?: DiagnosticMessage | ((Parser: any) => DiagnosticMessage)): Result<T>;
export declare function parseString(parser: Parser, value: string): Result<string>;
/** Combinator for a sequence of one or more characters */
export declare function literal(value: string): Combinator<string>;
/** Combinator that accepts a "fancy" Unicode alternative for
 * "value".
 *
 * Value can consist of more than one character, for example "!=".
 * It will match the corresponding "≠" fancy version. The fancy
 * versions include the characters listed in FANCY_UNICODE. The
 * fancy version is assumed to be a single Unicode character.
 *
 * Note that superscript numbers and subscript numbers are not
 * included since they need to be handled contextually.
 */
export declare function fancyLiteral(value: string): Combinator<string>;
export declare function regex(regex: RegExp): Combinator<string>;
/**
 * Generator for an ordered, non-empty, sequence of elements separated
 * by whitespace.
 *
 * If the first one fails, the sequence fails (softly).
 * After the first one, if a generator fails, the sequence returns an
 * error.
 */
export declare function sequence<IR>(cs: (string | Combinator)[], f: (...results: Result[]) => IR): Combinator<IR>;
/**
 * Explore multiple alternatives.
 * Select the one that advances the most.
 */
export declare function best<IR>(cs: Combinator[]): Combinator<IR>;
/**
 * Explore multiple alternatives.
 * Select the first one that matches.
 *
 */
export declare function either<IR = any>(cs: (string | Combinator)[], f?: (result: Result) => IR): Combinator;
/**
 *  1 or more `something`
 */
export declare function many<IR>(something: Combinator<IR>, f: (...results: Result<IR>[]) => IR): Combinator<IR>;
/**
 * 0 or more `something`.
 *
 * The parser of this combinator will never fail (since ø is an acceptable match).
 * If there are 0 something, the parser will return an Ignore result.
 */
export declare function some<IR>(something: string | Combinator<IR>, f: (...results: Result<IR>[]) => IR): Combinator<IR>;
/**
 *  Succeeds even if `something` fails
 */
export declare function maybe<T>(something: Combinator<T> | string): Combinator<T>;
/**
 * Return an error if `something` is a failure
 */
export declare function must<T>(something: string | Combinator<T>, inMsg?: DiagnosticMessage | ((Parser: any) => DiagnosticMessage)): Combinator<T>;
export declare function eof(): Combinator<boolean>;
