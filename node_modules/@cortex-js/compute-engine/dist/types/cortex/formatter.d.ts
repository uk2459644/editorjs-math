/* 0.4.2 */export declare type FormattingOptions = {
    indentChar: string;
    indentCharWidth: number;
    indentWidth: number;
    margin: number;
    softMargin: number;
    aroundInfixOperator: string;
    aroundRelationalOperator: string;
    afterSeparator: string;
    cost: FormattingCosts;
};
export declare type FormattingCosts = {
    softMargin: number;
    margin: number;
    linebreak: number;
    commentLinebreak: number;
    flowLinebreak: number;
    callLinebreak: number;
    argLinebreak: number;
};
export declare abstract class FormattingBlock {
    protected fmt: Formatter;
    /** Return a printable string representing this block */
    abstract serialize(offset: number): string;
    /** When starting at `offset`, what is the cost of this block */
    abstract cost(offset: number): number;
    /** When starting at `offset`, what is the column after this block */
    abstract nextCol(offset: number): number;
    /** Output debug representation of the block */
    abstract debug(): string;
    constructor(fmt: Formatter);
}
export declare class EmptyBlock extends FormattingBlock {
    constructor(fmt: Formatter);
    debug(): string;
    serialize(_offset: number): string;
    nextCol(offset: number): number;
    cost(_offset: number): number;
}
/**
 *
 *      |                 |        |
 *
 *      |    [--------]*  |        |
 *
 *      |    [------------|---]*   |
 *
 *      |    [------------|--------|---]*
 *
 *      |                 |        |
 *      0                          margin
 *                        soft-margin
 *
 */
export declare class TextBlock extends FormattingBlock {
    s: string;
    constructor(fmt: Formatter, s: string);
    debug(): string;
    serialize(_offset: number): string;
    nextCol(offset: number): number;
    cost(offset: number): number;
}
/**
 * A block that places its elements in a single line
 *
 * 0    offset
 * |
 * |    [--------][-----------][------][----------]*
 * |
 */
export declare class LineBlock extends FormattingBlock {
    private blocks;
    constructor(fmt: Formatter, ...blocks: FormattingBlock[]);
    debug(): string;
    serialize(offset: number): string;
    nextCol(offset: number): number;
    cost(offset: number): number;
}
/**
 * A block that arranges its elements vertically, separated by line breaks.
 *
 *      0    offset
 *      |
 *      |    [---1----]
 *      |    [-----2------]
 *      |    [--3--]
 *      |    [----4----]
 *      |    *
 *      |
 */
export declare class StackBlock extends FormattingBlock {
    private blocks;
    constructor(fmt: Formatter, ...blocks: FormattingBlock[]);
    debug(): string;
    serialize(offset: number): string;
    nextCol(offset: number): number;
    cost(offset: number): number;
}
/**
 * A block that arranges its elements like a justified paragraph
 *
 *      |                            |
 *      |    [---1----][----2------] |
 *      |    [--3---][----4-----]    |
 *      |    [--5--][--6---][--7--]  |
 *      |    [---8----]*             |
 *      |                            |
 *
 */
export declare class WrapBlock extends FormattingBlock {
    private blocks;
    constructor(fmt: Formatter, ...blocks: FormattingBlock[]);
    debug(): string;
    solution(offset: number): FormattingBlock;
    serialize(offset: number): string;
    nextCol(offset: number): number;
    cost(offset: number): number;
}
export declare class ChoiceBlock extends FormattingBlock {
    private blocks;
    constructor(fmt: Formatter, ...blocks: FormattingBlock[]);
    debug(): string;
    choice(offset: number): FormattingBlock;
    serialize(offset: number): string;
    nextCol(offset: number): number;
    cost(offset: number): number;
}
export declare class Formatter {
    private options;
    constructor(options?: Partial<FormattingOptions>);
    get cost(): FormattingCosts;
    get margin(): number;
    get softMargin(): number;
    indentChars(n?: number): string;
    indentLength(n?: number): number;
    linebreak(a?: string, b?: string): string;
    countLinebreaks(s: string): number;
    normalizedBlocks(blocks: (string | FormattingBlock)[]): FormattingBlock[];
    /** A binary or ternary operator: +, -, etc... */
    infixOperator(op: string): TextBlock;
    /** A relational operator: =, <=, etc.. */
    relationalOperator(op: string): TextBlock;
    separator(op: string): TextBlock;
    fence(f: string): TextBlock;
    /** A single line of unbroken text */
    text(s?: string): EmptyBlock | TextBlock;
    /** Horizontal juxtaposition of a list of blocks */
    line(...inBlocks: (string | FormattingBlock)[]): FormattingBlock;
    /** A list of block stacked on top of one another */
    stack(...inBlocks: (string | FormattingBlock)[]): FormattingBlock;
    /** Packs its constituent layouts horizontally, inserting line breaks
     * between them so as to minimize the total cost of output, in a manner
     * analogous to the composition of words in paragraph.
     *
     * Output after line breaks begins at the starting column of the entire
     * block.
     * */
    wrap(...inBlocks: (string | FormattingBlock)[]): FormattingBlock;
    /** Indent a block by `indent` units. The value of a unit is specified in the options */
    indent(block: FormattingBlock, indent?: number): FormattingBlock;
    choice(...inBlocks: (string | FormattingBlock)[]): FormattingBlock;
    fencedBlock(open: string, block: FormattingBlock, close: string): FormattingBlock;
    fencedList(open: string, sep: string | FormattingBlock, close: string, blocks: FormattingBlock[]): FormattingBlock;
    list(sep: string | FormattingBlock, blocks: FormattingBlock[]): FormattingBlock;
}
