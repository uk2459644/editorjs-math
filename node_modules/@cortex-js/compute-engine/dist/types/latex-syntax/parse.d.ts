/* 0.4.2 */import { Expression, ErrorCode, ErrorListener } from '../public';
import { ParseLatexOptions, LatexDictionaryEntry, LatexToken, NumberFormattingOptions } from './public';
import { IndexedLatexDictionary } from './definitions';
export declare class Scanner<T extends number = number> implements Scanner<T> {
    index: number;
    readonly tokens: LatexToken[];
    readonly onError: ErrorListener<ErrorCode>;
    readonly dictionary: IndexedLatexDictionary<T>;
    readonly options: Required<NumberFormattingOptions> & Required<ParseLatexOptions>;
    private invisibleOperatorPrecedence;
    constructor(tokens: LatexToken[], options: Required<NumberFormattingOptions> & Required<ParseLatexOptions>, dictionary: IndexedLatexDictionary<T>, onError: ErrorListener<ErrorCode>);
    clone(start: number, end: number): Scanner<T>;
    balancedClone(open: LatexToken | LatexToken[], close: LatexToken | LatexToken[], silentError?: boolean): Scanner<T> | null;
    get atEnd(): boolean;
    get peek(): LatexToken;
    latex(start: number, end?: number): string;
    latexAhead(n: number): string;
    latexBefore(): string;
    latexAfter(): string;
    /**
     * Return at most `maxLookahead` strings made from the tokens
     * ahead.
     *
     * The index in the returned array correspond to the number of tokens.
     * Note that since a token can be longer than one char ('\\pi', but also
     * some astral plane unicode characters), the length of the string
     * does not match that index. However, knowing the index is important
     * to know by how many tokens to advance.
     *
     */
    lookAhead(): string[];
    peekDefinition(kind: 'symbol' | 'infix' | 'matchfix' | 'prefix' | 'postfix' | 'superfix' | 'subfix' | 'operator'): [LatexDictionaryEntry<T> | null, number];
    next(): LatexToken;
    skipSpace(): boolean;
    match(target: LatexToken): boolean;
    matchAll(target: LatexToken | LatexToken[]): boolean;
    matchAny(targets: LatexToken[]): LatexToken;
    matchWhile(targets: LatexToken[]): LatexToken[];
    matchSign(): string;
    matchDecimalDigits(): string;
    matchSignedInteger(): string;
    matchExponent(): string;
    matchNumber(): string;
    matchOperator(kind: 'infix' | 'prefix' | 'postfix', lhs?: Expression<T> | null, minPrec?: number): Expression<T> | null;
    matchArguments(kind: undefined | '' | 'group' | 'implicit'): Expression<T>[] | null;
    matchMatchfixOperator(): Expression<T> | null;
    matchDefinition(kind: 'symbol' | 'infix' | 'matchfix' | 'prefix' | 'postfix' | 'superfix' | 'subfix' | 'operator'): [LatexDictionaryEntry<T> | null, Expression<T> | null];
    /**
     * A symbol can be:
     * - a constant: `\pi`
     * - a variable: `x`
     * - a function with explicit arguments `f(x)`
     * - a function with implicit arguments: `\cos x`
     * - a command: `\frac{2}{3}`
     */
    matchSymbol(): Expression<T> | null;
    matchOptionalLatexArgument(): Expression<T> | null;
    /**
     * Match a required latex argument:
     * - either enclosed in `{}`
     * - or a single token.
     *
     * Return null if an argument was not found
     * Return '' if an empty argument `{}` was found
     */
    matchRequiredLatexArgument(): Expression<T> | null;
    /**
     *  Match a superfix/subfix operator, e.g. `^{*}`
     */
    matchSupsub(lhs: Expression<T> | null): Expression<T> | null;
    matchPostfix(lhs: Expression<T> | null): Expression<T> | null;
    matchString(): string;
    matchEnvironmentName(command: '\\begin' | '\\end', envName: string): boolean;
    /**
     * Match an expression in a tabular format,
     * where row are separated by `\\` and columns by `&`
     *
     * Return rows of sparse columns as a list: empty rows are indicated with NOTHING,
     * and empty cells are also indicated with NOTHING.
     */
    matchTabular(): null | Expression<T>;
    matchEnvironment(): Expression<T> | null;
    /**
     * Apply the operator `op` to the left-hand-side and right-hand-side
     * expression. Applies the associativity rule specified by the definition,
     * i.e. 'op(a, op(b, c))` -> `op(a, b, c)`, etc...
     *
     * `op` is the name of the operator which should have a corresponding
     * definition.
     *
     * If `op` is an infix operator, it should have both a lhs and rhs.
     * If `op` is a postfix operator, it should only have a lhs.
     * If `op` is a prefix operator, the lhs is returned as the first element
     * of the return tuple.
     *
     * @return a tuple: [lhs, rhs]
     */
    applyOperator(op: string, lhs: Expression<T> | null, rhs: Expression<T> | null): NonNullable<[Expression<T> | null, Expression<T> | null]>;
    /**
     * Apply an invisible operator between two expressions.
     *
     * If no `invisibleOperator` was specified, use the `latex` operator.
     *
     * If the lhs is a number and the rhs is a fraction of integers,
     * assume an 'invisible plus', that is '2 3/4' -> ['add', 2, [divide, 3, 4]]
     * unless `invisiblePlusOperator` is empty
     *
     */
    applyInvisibleOperator(lhs: Expression<T> | null, rhs: Expression<T> | null): Expression<T> | null;
    matchUnknownLatexCommand(): Expression<T> | null;
    /**
     * <primary> :=
     * (<number> | <symbol> | <environment> | <matchfix-expr>) <subsup>* <postfix-operator>*
     *
     * <symbol> ::= (<symbol-id> | (<latex-command><latex-arguments>)) <arguments>
     *
     * <matchfix-expr> :=
     *  <matchfix-op-open> <expression> [<matchfix-op-separator> <expression>] <matchfix-op-close>
     *
     */
    matchPrimary(_minPrec?: number): Expression<T> | null;
    matchBalancedExpression(open: LatexToken | LatexToken[], close: LatexToken | LatexToken[], onError?: ErrorListener<ErrorCode>): Expression<T> | null;
    /**
     *  Parse an expression:
     *
     * <expression> ::=
     *  | <primary>
     *  | <prefix-op> <primary>
     *  | <primary> <infix-op> <expression>
     *
     * Stop when an operator of precedence less than `minPrec` is encountered
     */
    matchExpression(minPrec?: number): Expression<T> | null;
    /**
     * Add latex or other requested metadata to the expression
     */
    decorate(expr: Expression<T> | null, start: number): Expression<T> | null;
}
