/* 0.4.2 */import type { Expression, ErrorCode, ErrorListener } from '../public';
import { NumberFormattingOptions, LatexString, SerializeLatexOptions } from './public';
import { IndexedLatexDictionary, IndexedLatexDictionaryEntry } from './definitions';
export declare class Serializer<T extends number = number> implements Serializer<T> {
    readonly dictionary: IndexedLatexDictionary<T>;
    readonly onError: ErrorListener<ErrorCode>;
    readonly options: Required<NumberFormattingOptions> & Required<SerializeLatexOptions>;
    level: number;
    constructor(options: Required<NumberFormattingOptions> & Required<SerializeLatexOptions>, dictionary: IndexedLatexDictionary<T>, onError: ErrorListener<ErrorCode>);
    /**
     * Serialize the expression, and if the expression is an operator
     * of precedence less than or equal to prec, wrap it in some paren.
     * @todo: don't wrap abs
     */
    wrap(expr: Expression<T> | null, prec?: number): string;
    /** If this is a "short" expression (atomic), wrap it.
     *
     */
    wrapShort(expr: Expression<T> | null): string;
    wrapString(s: string, style: 'paren' | 'leftright' | 'big' | 'none'): string;
    serializeSymbol(expr: Expression<T>, def?: IndexedLatexDictionaryEntry<T>): string;
    serializeDictionary(dict: {
        [key: string]: Expression<T>;
    }): string;
    serialize(expr: T | Expression<T> | null): LatexString;
}
