/* 0.4.2 */import type { Expression, MathJsonRealNumber, MathJsonSymbol, MathJsonFunction, MathJsonString } from '../public';
import { Decimal } from 'decimal.js';
import { Complex } from 'complex.js';
import { Numeric } from '../compute-engine/public';
/**
 * The `ExpressionX` type is used internally to make computations with
 * arbitrarily large floating point and complex numbers
 *
 */
export declare type ExpressionX = Expression<Numeric>;
/**
 * These constants are the 'primitive' functions and constants that are used
 * for some basic manipulations such as parsing, and transforming to canonical
 * form.
 *
 */
export declare const PARENTHESES = "Parentheses";
export declare const IDENTITY = "Identity";
export declare const LATEX_TOKENS = "LatexTokens";
export declare const LIST = "List";
export declare const MISSING = "Missing";
export declare const NOTHING = "Nothing";
export declare const SEQUENCE = "Sequence";
export declare const SEQUENCE2 = "Sequence2";
export declare const ADD = "Add";
export declare const DERIVATIVE = "Derivative";
export declare const DIVIDE = "Divide";
export declare const EXP = "Exp";
export declare const INVERSE_FUNCTION = "InverseFunction";
export declare const MULTIPLY = "Multiply";
export declare const NEGATE = "Negate";
export declare const POWER = "Power";
export declare const PRIME = "Prime";
export declare const ROOT = "Root";
export declare const SQRT = "Sqrt";
export declare const SUBTRACT = "Subtract";
export declare const COMPLEX_INFINITY = "ComplexInfinity";
export declare const PI = "Pi";
export declare const EXPONENTIAL_E = "ExponentialE";
export declare const IMAGINARY_UNIT = "ImaginaryUnit";
export declare function isNumberObject(expr: Expression | null): expr is MathJsonRealNumber;
export declare function isSymbolObject(expr: Expression | null): expr is MathJsonSymbol;
export declare function isStringObject(expr: Expression | null): expr is MathJsonString;
export declare function isFunctionObject<T extends number = number>(expr: Expression<T> | null): expr is MathJsonFunction<T>;
export declare function isDictionaryObject<T extends number = number>(expr: Expression<T>): expr is MathJsonRealNumber;
export declare function getNumberValue<T extends number = number>(expr: Expression<T> | null): number | null;
/** Only return non-null if the expression is a Complex number.
 * Return null if it's a number, or a symbol (other than  `ImaginaryUnit` or
 * `ComplexInfinity`)
 *
 */
export declare function getComplexValue(expr: Complex | Expression | null): Complex | null;
/**
 * Return a multiple of the imaginary unit, e.g.
 * - 'ImaginaryUnit'
 * - ['Negate', 'ImaginaryUnit']
 * - ['Multiply', 5, 'ImaginaryUnit']
 * - ['Multiply', 'ImaginaryUnit', 5]
 */
export declare function getImaginaryValue(expr: Expression): number | null;
export declare function getDecimalValue(expr: Decimal | Expression | null): Decimal | null;
/**  If expr is a string literal, return it.
 *
 * A string literal is a JSON string that begins and ends with
 * **U+0027 APOSTROPHE** : **`'`** or an object literal with a `str` key.
 */
export declare function getStringValue(expr: Expression | null): string | null;
/**
 * Return a rational (numer over denom) representation of the expression,
 * if possible, `[null, null]` otherwise.
 *
 * The expression can be:
 * - Some symbols: "ThreeQuarte", "Half"...
 * - ["Power", d, -1]
 * - ["Power", n, 1]
 * - ["Divide", n, d]
 *
 * The denominator is always > 0.
 */
export declare function getRationalValue(expr: Expression): [number, number] | [null, null];
/**
 *  Reduce the numerator and denominator:
 * `\frac{2}{4} -> \frac{1}{2})`
 */
export declare function simplifyRational([numer, denom]: [number, number] | [null, null]): [number, number] | [null, null];
/**
 * Return the numerator and denominator of a product with the specified symbol.
 * For example:
 * `3π` -> [3, 1]
 * `3π/2` -> [3, 2]
 * `1/2 * π` -> [1, 2]
 */
export declare function getRationalSymbolicValue(expr: Expression, symbol: string): [number, number] | [null, null];
/** True if the expression is of the form \frac{n}{m} where n and m are both integers
 *
 * Note this detects fewer patterns than `getRationalValue()`, but it is
 * intended to detect rational numbers used with invisible plus, i.e. `1\frac{1}{2}`
 *
 */
export declare function isRationalNumber(expr: Expression): boolean;
/**
 * Return the head of any expression, including symbols and numbers.
 *
 */
export declare function getHead(expr: Expression): Expression | null;
/**
 * The head of a function can be a string or an expression.
 *
 * Return `null` if the expression is not a function.
 *
 * Examples:
 * * `["Negate", 5]`  -> `"Negate"`
 * * `[["Prime", "f"], "x"]` -> `["Prime", "f"]`
 */
export declare function getFunctionHead<T extends number = number>(expr: Expression<T> | null): Expression<T> | null;
/**
 * True if the expression is a number, a symbol or a string
 * (i.e. not a function and not a dictionary)
 */
export declare function isAtomic(expr: Expression | null): boolean;
export declare function getFunctionName<T extends number = number>(expr: Expression<T> | null): typeof MULTIPLY | typeof POWER | typeof DIVIDE | typeof ADD | typeof SUBTRACT | typeof NEGATE | typeof DERIVATIVE | typeof INVERSE_FUNCTION | typeof LATEX_TOKENS | typeof SQRT | typeof ROOT | typeof PARENTHESES | typeof LIST | typeof MISSING | typeof PRIME | typeof IDENTITY | typeof NOTHING | typeof SEQUENCE | typeof SEQUENCE2 | typeof PRIME | 'PartialDerivative' | 'Union' | 'Intersection' | 'SetMinus' | 'Cosh' | 'Exp' | 'Re' | 'And' | 'Not' | 'Equal' | 'NotEqual' | 'Element' | 'NotElement' | 'Complex' | 'Hold' | 'Evaluate' | '';
export declare function getSymbolName(expr: Expression | null): string | null;
/**
 * Return all the elements but the first one, i.e. the arguments of a
 * function.
 */
export declare function getTail<T extends number = number>(expr: Expression<T> | null): Expression<T>[];
export declare function applyRecursively<T extends number = number>(expr: Expression<T>, fn: (x: Expression<T>) => Expression<T>): Expression<T>;
/**
 * Apply a function to the arguments of a function and return an array of T
 */
export declare function mapArgs<T>(expr: Expression, fn: (x: Expression) => T): T[];
export declare function getArg<T extends number = number>(expr: Expression<T> | null, n: number): Expression<T> | null;
export declare function getArgCount<T extends number = number>(expr: Expression<T>): number;
export declare function getDictionary<T extends number = number>(expr: Expression<T>): {
    [key: string]: Expression<T>;
} | null;
/**
 * Structurally compare two expressions, ignoring metadata.
 *
 * Compare with `match()` which ignores differences in representation.
 *
 * @revisit: is this really needed? Or just use `match()`?
 */
export declare function equalExpr<T extends number = number>(lhs: Expression<T> | null, rhs: Expression<T> | null): boolean;
/**
 * Return the nth term in expr.
 * If expr is not a "add" function, returns null.
 */
/**
 * Return the coefficient of the expression, assuming vars are variables.
 */
export declare function coef(_expr: Expression, _vars: string[]): Expression | null;
