/* 0.4.2 */import { DictionaryCategory, ErrorSignal, Expression, WarningSignal } from '../public';
import { CollectionDefinition, ComputeEngine as ComputeEngineInterface, Definition, Dictionary, Domain, Form, FunctionDefinition, Numeric, NumericFormat, RuleSet, RuntimeScope, Scope, SetDefinition, Simplification, SymbolDefinition } from './public';
import { InternalComputeEngine } from './internal-compute-engine';
import { ExpressionMap } from './expression-map';
export declare class ComputeEngine<T extends number = number> implements ComputeEngineInterface {
    readonly internal: InternalComputeEngine;
    static getDictionaries(categories?: DictionaryCategory[] | 'all'): Readonly<Dictionary<Numeric>>[];
    constructor(options?: {
        dictionaries?: Readonly<Dictionary<Numeric>>[];
    });
    get precision(): number;
    set precision(p: number | 'machine');
    get numericFormat(): NumericFormat;
    set numericFormat(f: NumericFormat);
    get tolerance(): number;
    set tolerance(val: number);
    get context(): RuntimeScope<Numeric>;
    pushScope(dictionary: Readonly<Dictionary<Numeric>>, scope?: Partial<Scope>): void;
    popScope(): void;
    get assumptions(): ExpressionMap<T, boolean>;
    shouldContinueExecution(): boolean;
    checkContinueExecution(): void;
    signal(sig: ErrorSignal | WarningSignal): void;
    getFunctionDefinition(name: string): FunctionDefinition | null;
    getSymbolDefinition(name: string): SymbolDefinition<Numeric> | null;
    getSetDefinition(name: string): SetDefinition<Numeric> | null;
    getCollectionDefinition(name: string): CollectionDefinition<Numeric> | null;
    getDefinition(name: string): Definition<Numeric> | null;
    getRules(topic: string | string[]): RuleSet;
    format(expr: Expression | null, forms?: Form | Form[]): Expression | null;
    /**
     * Return the canonical form of an expression.
     */
    canonical(expr: Expression | null): Expression | null;
    /**
     * Return a numerical approximation of an expression.
     */
    N(expr: Expression): Expression | null;
    /**
     * Attempt to simplify an expression, that is rewrite it in a simpler form,
     * making use of the available assumptions.
     *
     * The simplification steps will proceed multiple times until either:
     * 1/ the expression stop changing
     * 2/ the number of iteration exceeds `iterationLimit`
     * 3/ the time to compute exceeds `timeLimit`, expressed in seconds
     *
     * If no `timeLimit` or `iterationLimit` are provided, the values
     * from the current ComputeEngine context are used. By default those
     * values are an infinite amount of iterations and a 2s time limit.
     *
     */
    simplify(expr: Expression, options?: {
        timeLimit?: number;
        iterationLimit?: number;
        simplifications?: Simplification[];
    }): Expression | null;
    /**
     * Return a simplified and numerically approximation of an expression
     * in canonical form.
     *
     * The simplification steps will proceed multiple times until either:
     * 1/ the expression stop changing
     * 2/ the number of iteration exceeds `iterationLimit`
     * 3/ the time to compute exceeds `timeLimit`, expressed in seconds
     *
     * If no `timeLimit` or `iterationLimit` are provided, the values
     * from the current ComputeEngine context are used. By default those
     * values are an infinite amount of iterations and a 2s time limit.
     */
    evaluate(expr: Expression, options?: {
        timeLimit?: number;
        iterationLimit?: number;
    }): Promise<Expression | null>;
    parse(s: string): Expression;
    serialize(x: Expression): string;
    domain(expr: Expression): Expression | null;
    /** Query the assumption database
     */
    is(symbol: Expression, domain: Domain): boolean | undefined;
    is(predicate: Expression): boolean | undefined;
    ask(pattern: Expression): {
        [symbol: string]: Expression;
    }[];
    assume(symbol: Expression, domain: Domain): 'contradiction' | 'tautology' | 'ok';
    assume(predicate: Expression): 'contradiction' | 'tautology' | 'ok';
    replace(rules: RuleSet<T>, expr: Expression<T>): Expression<T>;
    getVars(expr: Expression): Set<string>;
    chop(n: Numeric): Numeric;
    isZero(x: Expression<T>): boolean | undefined;
    isNotZero(x: Expression<T>): boolean | undefined;
    isNumeric(x: Expression<T>): boolean | undefined;
    isInfinity(x: Expression<T>): boolean | undefined;
    isFinite(x: Expression<T>): boolean | undefined;
    isNonNegative(x: Expression<T>): boolean | undefined;
    isPositive(x: Expression<T>): boolean | undefined;
    isNegative(x: Expression<T>): boolean | undefined;
    isNonPositive(x: Expression<T>): boolean | undefined;
    isInteger(x: Expression<T>): boolean | undefined;
    isRational(x: Expression<T>): boolean | undefined;
    isAlgebraic(x: Expression<T>): boolean | undefined;
    isReal(x: Expression<T>): boolean | undefined;
    isExtendedReal(x: Expression<T>): boolean | undefined;
    isComplex(x: Expression<T>): boolean | undefined;
    isOne(x: Expression<T>): boolean | undefined;
    isNegativeOne(x: Expression<T>): boolean | undefined;
    isElement(x: Expression<T>, set: Expression<T>): boolean | undefined;
    isSubsetOf(lhs: Domain | null, rhs: Domain | null): boolean;
    isEqual(lhs: Expression, rhs: Expression): boolean | undefined;
    isLess(lhs: Expression, rhs: Expression): boolean | undefined;
    isLessEqual(lhs: Expression, rhs: Expression): boolean | undefined;
    isGreater(lhs: Expression, rhs: Expression): boolean | undefined;
    isGreaterEqual(lhs: Expression, rhs: Expression): boolean | undefined;
}
export declare function format(expr: Expression, forms: Form | Form[]): Expression | null;
export declare function evaluate(expr: Expression): Promise<Expression | null>;
