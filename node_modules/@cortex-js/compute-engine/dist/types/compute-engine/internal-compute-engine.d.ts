/* 0.4.2 */import { DictionaryCategory, Expression, ErrorSignal, WarningSignal } from '../public';
import { CollectionDefinition, ComputeEngine, Definition, Dictionary, Domain, Form, FunctionDefinition, Numeric, NumericFormat, RuleSet, RuntimeScope, Scope, SetDefinition, Simplification, SymbolDefinition } from './public';
import { ExpressionMap } from './expression-map';
import { LatexSyntax } from '../latex-syntax/latex-syntax';
/**
 * The internal  compute engine implements the ComputeEngine interface
 * but does not:
 * - account for time limits
 * - account for iteration limits
 * - apply a canonical form
 *
 * It is used for recursive calls, and by the "top-level" `ComputeEngine`.
 */
export declare class InternalComputeEngine implements ComputeEngine<Numeric> {
    static getDictionaries(categories?: DictionaryCategory[] | 'all'): Readonly<Dictionary<Numeric>>[];
    private _precision;
    private _numericFormat;
    private _latexSyntax?;
    private _tolerance;
    private _rules?;
    /**
     * The current scope.
     *
     * A scope is a dictionary that contains the definition of local symbols.
     *
     * Scopes form a stack, and definitions in more recent
     * scopes can obscure definitions from older scopes.
     *
     */
    context: RuntimeScope<Numeric>;
    /** Absolute time beyond which evaluation should not proceed */
    deadline?: number;
    constructor(options?: {
        dictionaries?: Readonly<Dictionary<Numeric>>[];
    });
    get precision(): number;
    set precision(p: number | 'machine');
    get numericFormat(): NumericFormat;
    set numericFormat(f: NumericFormat);
    get tolerance(): number;
    set tolerance(val: number);
    /** Generator function (indicated by the leading '*') that returns all the
     *  rules in all the topics requested.
     */
    getRules(topics: string | string[]): RuleSet;
    get latexSyntax(): LatexSyntax;
    pushScope(dictionary: Readonly<Dictionary<Numeric>>, scope?: Partial<Scope>): void;
    popScope(): void;
    get assumptions(): ExpressionMap<Numeric, boolean>;
    signal(_sig: ErrorSignal | WarningSignal): void;
    get timeLimit(): undefined | number;
    get recursionLimit(): undefined | number;
    get iterationLimit(): undefined | number;
    shouldContinueExecution(): boolean;
    checkContinueExecution(): void;
    getFunctionDefinition(name: string): FunctionDefinition | null;
    getSymbolDefinition(name: string): SymbolDefinition<Numeric> | null;
    getSetDefinition(name: string): SetDefinition<Numeric> | null;
    getCollectionDefinition(name: string): CollectionDefinition<Numeric> | null;
    getDefinition(name: string): Definition<Numeric> | null;
    canonical(expr: Expression | null): Expression | null;
    format(expr: Expression | null, forms?: Form | Form[]): Expression | null;
    evaluate(expr: Expression, options?: {
        timeLimit?: number;
        iterationLimit?: number;
    }): Promise<Expression | null>;
    simplify(expr: Expression, options?: {
        simplifications?: Simplification[];
    }): Expression | null;
    N(expr: Expression, options?: {
        precision?: number;
    }): Expression | null;
    is(arg1: Expression, arg2?: Domain): boolean | undefined;
    ask(pattern: Expression): {
        [symbol: string]: Expression;
    }[];
    assume(arg1: Expression, arg2?: Domain): 'contradiction' | 'tautology' | 'ok';
    replace(rules: RuleSet, expr: Expression<Numeric>): Expression<Numeric>;
    domain(expr: Expression): Domain | null;
    getVars(expr: Expression): Set<string>;
    chop(n: Numeric): Numeric;
    parse(s: string): Expression;
    serialize(x: Expression): string;
    isZero(x: Expression): boolean | undefined;
    isNotZero(x: Expression): boolean | undefined;
    isNumeric(x: Expression): boolean | undefined;
    isInfinity(x: Expression): boolean | undefined;
    isFinite(x: Expression): boolean | undefined;
    isNonNegative(x: Expression): boolean | undefined;
    isPositive(x: Expression): boolean | undefined;
    isNegative(x: Expression): boolean | undefined;
    isNonPositive(x: Expression): boolean | undefined;
    isInteger(x: Expression): boolean | undefined;
    isRational(x: Expression): boolean | undefined;
    isAlgebraic(x: Expression): boolean | undefined;
    isReal(x: Expression): boolean | undefined;
    isExtendedReal(x: Expression): boolean | undefined;
    isComplex(x: Expression): boolean | undefined;
    isOne(x: Expression): boolean | undefined;
    isNegativeOne(x: Expression): boolean | undefined;
    isElement(x: Expression, set: Expression): boolean | undefined;
    isSubsetOf(lhs: Domain | null, rhs: Domain | null): boolean;
    isEqual(lhs: Expression, rhs: Expression): boolean | undefined;
    isLess(lhs: Expression, rhs: Expression): boolean | undefined;
    isLessEqual(lhs: Expression, rhs: Expression): boolean | undefined;
    isGreater(lhs: Expression, rhs: Expression): boolean | undefined;
    isGreaterEqual(lhs: Expression, rhs: Expression): boolean | undefined;
}
