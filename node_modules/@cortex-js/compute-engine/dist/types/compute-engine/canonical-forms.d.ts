/* 0.4.2 */import { Expression } from '../public';
import { Form, ComputeEngine } from './public';
export declare function canonicalNumberForm(expr: Expression, engine: ComputeEngine): Expression;
/**
 * Transform the expression so that object literals for numbers, symbols and
 * functions are used only when necessary, i.e. when they have associated
 * metadata attributes. Otherwise, use a plain number, string or array
 *
 * For example:
 *
 * ```
 * {num: 2} -> 2
 * {sym: "x"} -> "x"
 * {fn:['add', {num: 1}, {sym: "x"}]} -> ['add', 1, "x"]
 * ```
 *
 */
export declare function jsonForm(expr: Expression | null, engine: ComputeEngine): Expression | null;
export declare function strippedMetadataForm(expr: Expression | null, engine: ComputeEngine): Expression | null;
export declare function objectLiteralForm(expr: Expression, engine: ComputeEngine): Expression;
/**
 * Transform the expression so that the arguments of functions that have the
 * `isCommutative` attributes are ordered as follow:
 *
 * - Real numbers
 * - Complex numbers
 * - Symbols
 * - Functions
 *
 * Within Real Numbers:
 * - by their value
 *
 * Within Complex numbers:
 * - by the value of their imaginary component,
 * - then by the value of their real component
 *
 * Within Symbols:
 * - constants (`isConstant === true`) before non-constants
 * - then alphabetically
 *
 * Within Functions:
 * - if a `[MULTIPLY]` or a `[POWER]`... @todo
 *
 */
export declare function sortedForm(expr: Expression, engine: ComputeEngine): Expression;
/**
 *  Return the expression in canonical form:
 *
 * - `"divide"`, `"exp"`,` `"subtract"`, `"root"`, `"exp"` replaced with
 *      `"add"`, `"multiply"`, "`power"`
 * - some trivial simplifications (multiply by 1, addition of 0, division by 1)
 * - terms sorted
 *
 */
export declare function canonicalForm(expr: Expression | null, engine: ComputeEngine): Expression | null;
/**
 * Return a string escaped as necessary to comply with the JSON format
 *
 */
export declare function escapeText(s: string): string;
/**
 * Transform an expression by applying one or more rewriting rules to it,
 * recursively.
 *
 * There are many ways to symbolically manipulate an expression, but
 * transformations with `form` have the following characteristics:
 *
 * - they don't require calculations or assumptions about the domain of free
 * variables or the value of constants
 * - the output expression is expressed with more primitive functions,
 * for example subtraction is replaced with addition
 *
 */
export declare function format(engine: ComputeEngine, expr: Expression | null, forms: Form[]): Expression | null;
